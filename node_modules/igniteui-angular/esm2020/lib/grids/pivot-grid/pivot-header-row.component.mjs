import { ChangeDetectionStrategy, Component, Inject, ViewChild, ViewChildren } from '@angular/core';
import { SortingDirection } from '../../data-operations/sorting-strategy';
import { IgxGridForOfDirective } from '../../directives/for-of/for_of.directive';
import { AbsoluteScrollStrategy, AutoPositionStrategy, VerticalAlignment } from '../../services/public_api';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { IgxGridHeaderRowComponent } from '../headers/grid-header-row.component';
import { DropPosition } from '../moving/moving.service';
import { PivotUtil } from './pivot-util';
import * as i0 from "@angular/core";
import * as i1 from "../headers/grid-header-group.component";
import * as i2 from "../filtering/excel-style/grid.excel-style-filtering.component";
import * as i3 from "../filtering/excel-style/excel-style-search.component";
import * as i4 from "@angular/common";
import * as i5 from "../../icon/icon.component";
import * as i6 from "../../directives/prefix/prefix.directive";
import * as i7 from "../../directives/suffix/suffix.directive";
import * as i8 from "../../directives/for-of/for_of.directive";
import * as i9 from "../../badge/badge.component";
import * as i10 from "../../chips/chips-area.component";
import * as i11 from "../../chips/chip.component";
import * as i12 from "../../directives/drag-drop/drag-drop.directive";
import * as i13 from "../../drop-down/drop-down.component";
import * as i14 from "../../drop-down/drop-down-item.component";
import * as i15 from "../../drop-down/drop-down-navigation.directive";
import * as i16 from "../headers/pipes";
import * as i17 from "../common/pipes";
/**
 *
 * For all intents & purposes treat this component as what a <thead> usually is in the default <table> element.
 *
 * This container holds the pivot grid header elements and their behavior/interactions.
 *
 * @hidden @internal
 */
export class IgxPivotHeaderRowComponent extends IgxGridHeaderRowComponent {
    constructor(grid, ref, cdr, renderer) {
        super(ref, cdr);
        this.grid = grid;
        this.ref = ref;
        this.cdr = cdr;
        this.renderer = renderer;
        this.aggregateList = [];
        this.filterDropdownDimensions = new Set();
        this.filterAreaDimensions = new Set();
        this._dropPos = DropPosition.AfterDropTarget;
        this._subMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Bottom,
            closeAnimation: undefined
        };
        this._subMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        /**
        * @hidden
        * @internal
        * Default is a single empty level since default depth is 1
        */
        this.columnDimensionsByLevel = [[]];
    }
    get headerForOf() {
        return this.headerContainers.last;
    }
    /**
    * @hidden @internal
    */
    get isFiltersButton() {
        let chipsWidth = 0;
        this.filterDropdownDimensions.clear();
        this.filterAreaDimensions.clear();
        if (this.filterArea?.chipsList && this.filterArea.chipsList.length !== 0) {
            const styles = getComputedStyle(this.pivotFilterContainer.nativeElement);
            const containerPaddings = parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
            chipsWidth += containerPaddings + (this.filtersButton && this.filterArea?.chipsList.length > 1 ? this.filtersButton.el.nativeElement.getBoundingClientRect().width : 0);
            this.filterArea.chipsList.forEach(chip => {
                const dim = this.grid.filterDimensions.find(x => x.memberName === chip.id);
                if (dim) {
                    // 8 px margin between chips
                    const currentChipWidth = chip.nativeElement.getBoundingClientRect().width + 8;
                    if (chipsWidth + currentChipWidth < this.grid.pivotRowWidths) {
                        this.filterAreaDimensions.add(dim);
                    }
                    else {
                        this.filterDropdownDimensions.add(dim);
                    }
                    chipsWidth += currentChipWidth;
                }
            });
            return this.filterDropdownDimensions.size > 0;
        }
        return false;
    }
    /**
    * @hidden
    * @internal
    */
    get totalDepth() {
        const columnDimensions = this.grid.columnDimensions;
        if (columnDimensions.length === 0) {
            return 1;
        }
        let totalDepth = columnDimensions.map(x => PivotUtil.getDimensionDepth(x) + 1).reduce((acc, val) => acc + val);
        if (this.grid.hasMultipleValues) {
            totalDepth += 1;
        }
        return totalDepth;
    }
    /**
    * @hidden
    * @internal
    */
    get maxContainerHeight() {
        return this.totalDepth * this.grid.renderedRowHeight;
    }
    /**
    * @hidden
    * @internal
    */
    calcHeight(col, index) {
        return !col.columnGroup && col.level < this.totalDepth && col.level === index ? (this.totalDepth - col.level) * this.grid.rowHeight : this.grid.rowHeight;
    }
    /**
    * @hidden
    * @internal
    */
    isDuplicateOfExistingParent(col, lvl) {
        const parentCollection = lvl > 0 ? this.columnDimensionsByLevel[lvl - 1] : [];
        const duplicate = parentCollection.indexOf(col) !== -1;
        return duplicate;
    }
    /**
    * @hidden
    * @internal
    */
    isMultiRow(col, lvl) {
        const isLeaf = !col.columnGroup;
        return isLeaf && lvl !== this.totalDepth - 1;
    }
    /**
    * @hidden
    * @internal
    */
    populateColumnDimensionsByLevel() {
        const res = [];
        for (let i = 0; i < this.totalDepth; i++) {
            res[i] = [];
        }
        const cols = this.unpinnedColumnCollection;
        // populate column dimension matrix recursively
        this.populateDimensionRecursively(cols.filter(x => x.level === 0), 0, res);
        this.columnDimensionsByLevel = res;
    }
    populateDimensionRecursively(currentLevelColumns, level = 0, res) {
        currentLevelColumns.forEach(col => {
            if (res[level]) {
                res[level].push(col);
                if (col.columnGroup && col.children.length > 0) {
                    const visibleColumns = col.children.toArray().filter(x => !x.hidden);
                    this.populateDimensionRecursively(visibleColumns, level + 1, res);
                }
                else if (level < this.totalDepth - 1) {
                    for (let i = level + 1; i <= this.totalDepth - 1; i++) {
                        res[i].push(col);
                    }
                }
            }
        });
    }
    /**
    * @hidden
    * @internal
    */
    ngOnChanges(changes) {
        if (changes.unpinnedColumnCollection) {
            this.populateColumnDimensionsByLevel();
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragStart(event, area) {
        this.cdr.detectChanges();
        for (let chip of this.notificationChips) {
            const parent = chip.nativeElement.parentElement;
            if (area.chipsList.toArray().indexOf(chip) === -1 &&
                parent.children.length > 0 &&
                parent.children.item(0).id !== 'empty') {
                chip.nativeElement.hidden = false;
                parent.parentElement.scrollTo({ left: chip.nativeElement.offsetLeft });
            }
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragEnd() {
        for (let chip of this.notificationChips) {
            chip.nativeElement.hidden = true;
        }
    }
    /**
    * @hidden
    * @internal
    */
    getAreaHeight(area) {
        const chips = area.chipsList;
        return chips && chips.length > 0 ? chips.first.nativeElement.offsetHeight : 0;
    }
    /**
    * @hidden
    * @internal
    */
    rowRemoved(event) {
        const row = this.grid.pivotConfiguration.rows.find(x => x.memberName === event.owner.id);
        this.grid.toggleDimension(row);
    }
    /**
    * @hidden
    * @internal
    */
    columnRemoved(event) {
        const col = this.grid.pivotConfiguration.columns.find(x => x.memberName === event.owner.id);
        this.grid.toggleDimension(col);
    }
    /**
    * @hidden
    * @internal
    */
    valueRemoved(event) {
        const value = this.grid.pivotConfiguration.values.find(x => x.member === event.owner.id || x.displayName === event.owner.id);
        this.grid.toggleValue(value);
    }
    /**
    * @hidden
    * @internal
    */
    filterRemoved(event) {
        const filter = this.grid.pivotConfiguration.filters.find(x => x.memberName === event.owner.id);
        this.grid.toggleDimension(filter);
        if (this.filterDropdownDimensions.size > 0) {
            this.onFiltersAreaDropdownClick({ target: this.filtersButton.el.nativeElement }, undefined, false);
        }
        else {
            this.grid.filteringService.hideESF();
        }
    }
    onFiltersSelectionChanged(event) {
        this.dropdownChips.chipsList.forEach(chip => {
            if (chip.id !== event.owner.id) {
                chip.selected = false;
            }
        });
        this.onFiltersAreaDropdownClick({ target: this.filtersButton.el.nativeElement }, this.grid.filterDimensions.find(dim => dim.memberName === event.owner.id), false);
    }
    /**
    * @hidden
    * @internal
    */
    onFilteringIconPointerDown(event) {
        event.stopPropagation();
        event.preventDefault();
    }
    /**
    * @hidden
    * @internal
    */
    onFilteringIconClick(event, dimension) {
        event.stopPropagation();
        event.preventDefault();
        let dim = dimension;
        const col = this.grid.dimensionDataColumns.find(x => x.field === dim.memberName || x.field === dim.member);
        this.grid.filteringService.toggleFilterDropdown(event.target, col);
    }
    /**
    * @hidden
    * @internal
    */
    onSummaryClick(eventArgs, value, dropdown, chip) {
        this._subMenuOverlaySettings.target = eventArgs.currentTarget;
        this.updateDropDown(value, dropdown, chip);
    }
    /**
     * @hidden @internal
     */
    onFiltersAreaDropdownClick(event, dimension, shouldReattach = true) {
        let dim = dimension || this.filterDropdownDimensions.values().next().value;
        const col = this.grid.dimensionDataColumns.find(x => x.field === dim.memberName || x.field === dim.member);
        if (shouldReattach) {
            this.dropdownChips.chipsList.forEach(chip => {
                chip.selected = false;
            });
            this.dropdownChips.chipsList.first.selected = true;
        }
        this.grid.filteringService.toggleFiltersESF(this.esf, event.target, col, shouldReattach);
    }
    /**
    * @hidden
    * @internal
    */
    onAggregationChange(event) {
        if (!this.isSelected(event.newSelection.value)) {
            this.value.aggregate = event.newSelection.value;
            this.grid.pipeTrigger++;
        }
    }
    /**
    * @hidden
    * @internal
    */
    isSelected(val) {
        return this.value.aggregate.key === val.key;
    }
    /**
    * @hidden
    * @internal
    */
    onChipSort(_event, dimension) {
        const startDirection = dimension.sortDirection || SortingDirection.None;
        const direction = startDirection + 1 > SortingDirection.Desc ?
            SortingDirection.None : startDirection + 1;
        this.grid.sortDimension(dimension, direction);
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragOver(event, dimension) {
        if (!event.dragChip || !event.dragChip.data?.pivotArea)
            return;
        const typeMismatch = dimension !== undefined ? this.grid.pivotConfiguration.values.find(x => x.member === event.dragChip.id
            || x.displayName === event.dragChip.id) :
            !this.grid.pivotConfiguration.values.find(x => x.member === event.dragChip.id || x.displayName === event.dragChip.id);
        if (typeMismatch) {
            // cannot drag between dimensions and value
            return;
        }
        // if we are in the left half of the chip, drop on the left
        // else drop on the right of the chip
        const clientRect = event.owner.nativeElement.getBoundingClientRect();
        const pos = clientRect.width / 2;
        this._dropPos = event.originalEvent.offsetX > pos ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;
        if (this._dropPos === DropPosition.AfterDropTarget) {
            event.owner.nativeElement.previousElementSibling.style.visibility = 'hidden';
            event.owner.nativeElement.nextElementSibling.style.visibility = '';
        }
        else {
            event.owner.nativeElement.nextElementSibling.style.visibility = 'hidden';
            event.owner.nativeElement.previousElementSibling.style.visibility = '';
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragLeave(event) {
        event.owner.nativeElement.previousElementSibling.style.visibility = 'hidden';
        event.owner.nativeElement.nextElementSibling.style.visibility = 'hidden';
        this._dropPos = DropPosition.AfterDropTarget;
    }
    /**
    * @hidden
    * @internal
    */
    onAreaDragLeave(event, area) {
        const dataChips = area.chipsList.toArray().filter(x => this.notificationChips.toArray().indexOf(x) === -1);
        dataChips.forEach(element => {
            if (element.nativeElement.previousElementSibling) {
                element.nativeElement.previousElementSibling.style.visibility = 'hidden';
            }
            if (element.nativeElement.nextElementSibling) {
                element.nativeElement.nextElementSibling.style.visibility = 'hidden';
            }
        });
    }
    /**
    * @hidden
    * @internal
    */
    onValueDrop(event, area) {
        if (!(event.dragChip && event.dragChip.data?.pivotArea) && !(event.dragData?.chip && !!event.dragData.chip.data.pivotArea))
            return;
        //values can only be reordered
        const values = this.grid.pivotConfiguration.values;
        const dragId = event.dragChip?.id || event.dragData?.chip.id;
        const chipsArray = area.chipsList.toArray();
        let chipIndex = chipsArray.indexOf(event.owner) !== -1 ? chipsArray.indexOf(event.owner) : chipsArray.length;
        chipIndex = this._dropPos === DropPosition.AfterDropTarget ? chipIndex + 1 : chipIndex;
        const value = values.find(x => x.member === dragId || x.displayName === dragId);
        if (value) {
            const dragChipIndex = chipsArray.indexOf(event.dragChip || event.dragData.chip);
            this.grid.moveValue(value, dragChipIndex >= chipIndex ? chipIndex : chipIndex - 1);
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDrop(event, area, dimensionType) {
        if (!(event.dragChip && event.dragChip.data?.pivotArea) && !(event.dragData?.chip && !!event.dragData.chip.data.pivotArea))
            return;
        const dragId = event.dragChip?.id || event.dragData?.chip.id;
        const currentDim = this.grid.getDimensionsByType(dimensionType);
        const chipsArray = area.chipsList.toArray();
        const chip = chipsArray.find(x => x.id === dragId);
        const isNewChip = chip === undefined;
        const isReorder = event.owner.id !== undefined;
        //const chipIndex = chipsArray.indexOf(event.owner) !== -1 ? chipsArray.indexOf(event.owner) : chipsArray.length;
        const chipIndex = currentDim.findIndex(x => x.memberName === event.owner.id) !== -1 ?
            currentDim.findIndex(x => x.memberName === event.owner.id) : currentDim.length;
        const targetIndex = this._dropPos === DropPosition.AfterDropTarget ? chipIndex + 1 : chipIndex;
        if (isNewChip) {
            // chip moved from an external collection
            const dim = this.grid.allDimensions.find(x => x && x.memberName === dragId);
            if (!dim) {
                // you have dragged something that is not a dimension
                return;
            }
            this.grid.moveDimension(dim, dimensionType, targetIndex);
        }
        else if (isReorder) {
            // chip from same collection, reordered.
            const newDim = currentDim.find(x => x.memberName === dragId);
            const dragChipIndex = currentDim.findIndex(x => x.memberName === dragId);
            this.grid.moveDimension(newDim, dimensionType, dragChipIndex > chipIndex ? targetIndex : targetIndex - 1);
        }
        this.grid.pipeTrigger++;
        this.grid.dimensionsChange.emit({ dimensions: currentDim, dimensionCollectionType: dimensionType });
        // clean states
        this.onDimDragEnd();
        this.onAreaDragLeave(event, area);
    }
    updateDropDown(value, dropdown, chip) {
        this.value = value;
        dropdown.width = chip.nativeElement.clientWidth + 'px';
        this.aggregateList = PivotUtil.getAggregateList(value, this.grid);
        this.cdr.detectChanges();
        dropdown.open(this._subMenuOverlaySettings);
    }
}
IgxPivotHeaderRowComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: IgxPivotHeaderRowComponent, deps: [{ token: IGX_GRID_BASE }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
IgxPivotHeaderRowComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.0", type: IgxPivotHeaderRowComponent, selector: "igx-pivot-header-row", viewQueries: [{ propertyName: "esf", first: true, predicate: ["esf"], descendants: true }, { propertyName: "filterArea", first: true, predicate: ["filterAreaHidden"], descendants: true }, { propertyName: "filtersButton", first: true, predicate: ["filterIcon"], descendants: true }, { propertyName: "dropdownChips", first: true, predicate: ["dropdownChips"], descendants: true }, { propertyName: "pivotFilterContainer", first: true, predicate: ["pivotFilterContainer"], descendants: true }, { propertyName: "notificationChips", predicate: ["notifyChip"], descendants: true }, { propertyName: "headerContainers", predicate: ["headerVirtualContainer"], descendants: true, read: IgxGridForOfDirective }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div>\n    <div class=\"igx-grid-thead__wrapper igx-grid-thead__wrapper--pivot\" role=\"row\" [style.width.px]=\"width\">\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div class='igx-grid__tr-pivot--filter-container'>\n                <div #pivotFilterContainer *ngIf=\"grid.showPivotConfigurationUI\"\n                     class=\"igx-grid__tr-pivot igx-grid__tr-pivot--filter\" [style.min-width.px]=\"grid.pivotRowWidths - 1\"\n                     [style.max-width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, filterArea)\"\n                     igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\" (pointerdown)=\"$event.preventDefault()\">\n                    <!-- Filter area -->\n                    <igx-chips-area #filterArea droppable='true'>\n                    <span id='empty' igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\"\n                          *ngIf=\"grid.filterDimensions.length === 0\"\n                          class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_filter_drop_area}}</span>\n                        <ng-container *ngFor=\"let filter of this.filterAreaDimensions; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(filterArea)'></span>\n                            <igx-chip [id]=\"filter.memberName\" [draggable]=\"true\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'filter' }\"\n                                      [removable]=\"true\" (remove)=\"filterRemoved($event)\" (dragOver)=\"onDimDragOver($event, 2)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, filterArea, 2)\"\n                                      (moveStart)='onDimDragStart($event, filterArea)' (moveEnd)='onDimDragEnd()'>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, filter)'>filter_list</igx-icon>\n                                {{filter.memberName}}\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(filterArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, filterArea, 2)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_filter_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                    <div class=\"igx-grid__pivot-filter-toggle\" *ngIf=\"isFiltersButton && grid.filterDimensions.length !== 0\">\n                        <igx-icon #filterIcon (pointerdown)='onFilteringIconPointerDown($event)' (click)='onFiltersAreaDropdownClick($event)'>filter_list</igx-icon>\n                        <igx-badge value=\"{{this.filterDropdownDimensions.size}}\"></igx-badge>\n                    </div>\n                </div>\n                <div class='igx-grid__tr-pivot--drop-row-area' (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                     (dropped)=\"onDimDrop($event, rowArea, 0)\">\n                </div>\n            </div>\n\n            <div class=\"igx-grid__tr-pivot-group\">\n                <div #pivotColumnContainer *ngIf=\"grid.showPivotConfigurationUI\" class=\"igx-grid__tr-pivot\"\n                     (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop (igxDragLeave)=\"onAreaDragLeave($event, colArea)\">\n                    <!-- Columns area -->\n                    <igx-chips-area #colArea droppable='true'>\n                    <span id='empty' (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop\n                        *ngIf=\"grid.columnDimensions.length === 0\" class='igx-grid__pivot-empty-chip-area'>\n                        {{grid.resourceStrings.igx_grid_pivot_empty_column_drop_area}}</span>\n                        <ng-container *ngFor=\"let col of grid.columnDimensions; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(colArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"col.memberName\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'column' }\"\n                                      [removable]=\"true\" (remove)=\"columnRemoved($event)\" (dragOver)=\"onDimDragOver($event, 1)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, colArea, 1)\"\n                                      (moveStart)='onDimDragStart($event, colArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, col)\">\n                                <igx-icon igxPrefix>view_column</igx-icon>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, col)'>filter_list</igx-icon>\n                                {{col.memberName}}\n                                <igx-icon *ngIf=\"col.sortDirection\" igxSuffix> {{ col.sortDirection < 2 ? 'arrow_upward'\n                                    : 'arrow_downward' }}</igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(colArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, colArea, 1)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_column_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n\n                <div #pivotValueContainer *ngIf=\"grid.showPivotConfigurationUI\" class=\"igx-grid__tr-pivot\"\n                     (pointerdown)=\"$event.preventDefault()\" (dropped)=\"onValueDrop($event, valueArea)\" igxDrop\n                     (igxDragLeave)=\"onAreaDragLeave($event, valueArea)\">\n                    <!-- Value area -->\n                    <igx-chips-area #valueArea droppable='true'>\n                    <span id='empty' (dropped)=\"onValueDrop($event, valueArea)\" igxDrop *ngIf=\"grid.values.length === 0\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_value_drop_area}}</span>\n                    <ng-container *ngFor=\"let value of grid.values; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(valueArea)'></span>\n                            <igx-chip #currChip [draggable]=\"true\" [id]=\"value.displayName || value.member\" [data]=\"{ pivotArea: 'value' }\"\n                                      [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"valueRemoved($event)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragOver)=\"onDimDragOver($event)\"\n                                      (dragDrop)=\"onValueDrop($event, valueArea)\">\n                                <div class=\"igx-grid__tr-pivot-toggle-icons\" igxPrefix\n                                     (click)='onSummaryClick($event, value, dropdown, currChip)'\n                                     (pointerdown)='$event.stopPropagation()' [igxDropDownItemNavigation]=\"dropdown\">\n                                    <igx-icon>functions</igx-icon>\n                                    <igx-icon>arrow_drop_down</igx-icon>\n                                </div>\n                                <ng-container *ngTemplateOutlet=\"grid.valueChipTemplate ? grid.valueChipTemplate : valueChipDefaultTemplate; context: { $implicit: value }\"></ng-container>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(valueArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onValueDrop($event, valueArea)\" #notifyValueChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_value_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div role=\"rowgroup\" class=\"igx-grid-thead__wrapper\" [style.width.px]=\"width\"\n         [attr.aria-activedescendant]=\"activeDescendant\" [class.igx-grid__tr--mrl]=\"hasMRL\">\n\n        <!-- Column headers area -->\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div #pivotContainer class=\"igx-grid__tr-pivot igx-grid__tr-pivot--row-area\"\n                 [style.width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                 (dropped)=\"onDimDrop($event, rowArea, 0)\" (pointerdown)=\"$event.preventDefault()\">\n                <!-- Row area -->\n                <igx-chips-area #rowArea droppable='true'>\n                    <ng-container *ngIf=\"grid.showPivotConfigurationUI\">\n                    <span id='empty' igxDrop (dropped)=\"onDimDrop($event, rowArea, 0)\"\n                        *ngIf=\"grid.rowDimensions.length === 0 && grid.showPivotConfigurationUI\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_row_drop_area}}</span>\n                    <ng-container *ngFor=\"let row of grid.rowDimensions; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(rowArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"row.memberName\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'row' }\"\n                                      [removable]=\"true\" (remove)=\"rowRemoved($event)\" (dragLeave)=\"onDimDragLeave($event)\"\n                                      (dragDrop)=\"onDimDrop($event, rowArea, 0)\" (dragOver)=\"onDimDragOver($event, 0)\"\n                                      (moveStart)='onDimDragStart($event, rowArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, row)\">\n                                <igx-icon igxPrefix>table_rows</igx-icon>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, row)'>filter_list</igx-icon>\n                                {{ row.memberName}}\n                                <igx-icon *ngIf=\"row.sortDirection\" igxSuffix> {{ row.sortDirection < 2 ? 'arrow_upward'\n                                    : 'arrow_downward' }}</igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(rowArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, rowArea, 0)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_row_drop_chip}}\n                        </igx-chip>\n                    </ng-container>\n                </igx-chips-area>\n            </div>\n\n            <!-- Pinned columns collection from the start -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles | igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n            <div class=\"igx-grid-thead--virtualizationWrapper\" [style.max-height.px]='maxContainerHeight'>\n                <div class=\"igx-grid-thead__group igx-grid-thead--virtualizationContainer\" [style.height.px]='totalDepth > 1 ? grid.rowHeight : undefined' *ngFor='let dimLevelColumns of columnDimensionsByLevel; let i = index' [style.width.px]='grid.unpinnedWidth'>\n                    <ng-template igxGridFor #headerVirtualContainer let-column\n                                 [igxGridForOf]=\"dimLevelColumns\" [igxGridForOfUniqueSizeCache] = 'true' [igxForScrollContainer]=\"grid.parentVirtDir\"\n                                 [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\"\n                                 [igxForSizePropName]=\"'calcPixelWidth'\" [igxForScrollOrientation]=\"'horizontal'\">\n                        <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                               [style.height.px]='totalDepth > 1 ? calcHeight(column, i) : undefined'\n                                               [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                               [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [class.igx-grid__tr-pivot--columnDimensionLeaf] = 'isDuplicateOfExistingParent(column, i)'\n                                               [class.igx-grid__tr-pivot--columnMultiRowSpan] = 'isMultiRow(column, i)'\n                        >\n                        </igx-grid-header-group>\n                    </ng-template>\n                </div>\n            </div>\n\n            <!-- Pinned columns collection at the end -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && !grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.left]=\"column.rightPinnedOffset\" (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n        </div>\n    </div>\n</div>\n<!-- Header thumb area -->\n<div class=\"igx-grid-thead__thumb\" [hidden]=\"!grid.hasVerticalScroll()\" [style.width.px]=\"grid.scrollSize\">\n</div>\n\n<igx-drop-down #dropdown (selectionChanging)='onAggregationChange($event)'>\n    <igx-drop-down-item *ngFor=\"let item of aggregateList\" [selected]='isSelected(item)' [value]='item'>\n        {{ item.label }}\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<div [hidden]='true'>\n    <igx-grid-excel-style-filtering [maxHeight]='grid.excelStyleFilterMaxHeight' [minHeight]='grid.excelStyleFilterMinHeight' #esf>\n        <div igxExcelStyleColumnOperations>\n            <igx-chips-area #dropdownChips>\n                <igx-chip *ngFor=\"let filter of this.filterDropdownDimensions\" [id]=\"filter.memberName\"\n                [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"filterRemoved($event)\"\n                (chipClick)='onFiltersSelectionChanged($event)' [selectable]='true' [selected]='filter === this.filterDropdownDimensions.values().next().value'>\n                {{filter.memberName}}\n            </igx-chip>\n        </igx-chips-area>\n        </div>\n        <igx-excel-style-filter-operations>\n            <igx-excel-style-search></igx-excel-style-search>\n        </igx-excel-style-filter-operations>\n    </igx-grid-excel-style-filtering>\n</div>\n\n<div style=\"visibility: hidden; position: absolute; top: -10000px\">\n    <igx-chips-area #filterAreaHidden droppable='true'>\n        <igx-chip *ngFor=\"let filter of grid.filterDimensions\" [id]=\"filter.memberName\" [draggable]=\"true\"\n            [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"filterRemoved($event)\">\n            <igx-icon igxPrefix>filter_list</igx-icon>\n            {{filter.memberName}}\n        </igx-chip>\n    </igx-chips-area>\n</div>\n\n<ng-template #valueChipDefaultTemplate let-value>\n    {{value.aggregate.key}}({{value.displayName || value.member}})\n</ng-template>\n", dependencies: [{ kind: "component", type: i1.IgxGridHeaderGroupComponent, selector: "igx-grid-header-group", inputs: ["column"] }, { kind: "component", type: i2.IgxGridExcelStyleFilteringComponent, selector: "igx-grid-excel-style-filtering", inputs: ["column", "minHeight", "maxHeight"], outputs: ["loadingStart", "loadingEnd", "initialized", "sortingChanged", "columnChange", "listDataLoaded"] }, { kind: "directive", type: i2.IgxExcelStyleColumnOperationsTemplateDirective, selector: "igx-excel-style-column-operations,[igxExcelStyleColumnOperations]" }, { kind: "directive", type: i2.IgxExcelStyleFilterOperationsTemplateDirective, selector: "igx-excel-style-filter-operations,[igxExcelStyleFilterOperations]" }, { kind: "component", type: i3.IgxExcelStyleSearchComponent, selector: "igx-excel-style-search" }, { kind: "directive", type: i4.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i4.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: i5.IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "directive", type: i6.IgxPrefixDirective, selector: "igx-prefix,[igxPrefix]" }, { kind: "directive", type: i7.IgxSuffixDirective, selector: "igx-suffix,[igxSuffix]" }, { kind: "directive", type: i8.IgxGridForOfDirective, selector: "[igxGridFor][igxGridForOf]", inputs: ["igxGridForOf", "igxGridForOfUniqueSizeCache", "igxGridForOfVariableSizes"], outputs: ["dataChanging"] }, { kind: "component", type: i9.IgxBadgeComponent, selector: "igx-badge", inputs: ["id", "type", "value", "icon"] }, { kind: "component", type: i10.IgxChipsAreaComponent, selector: "igx-chips-area", inputs: ["class", "width", "height"], outputs: ["reorder", "selectionChange", "moveStart", "moveEnd"] }, { kind: "component", type: i11.IgxChipComponent, selector: "igx-chip", inputs: ["id", "tabIndex", "data", "draggable", "animateOnRelease", "hideBaseOnDrag", "removable", "removeIcon", "selectable", "selectIcon", "class", "disabled", "selected", "color", "resourceStrings"], outputs: ["selectedChange", "moveStart", "moveEnd", "remove", "chipClick", "selectedChanging", "selectedChanged", "keyDown", "dragEnter", "dragLeave", "dragOver", "dragDrop"] }, { kind: "directive", type: i12.IgxDropDirective, selector: "[igxDrop]", inputs: ["igxDrop", "dropChannel", "dropStrategy"], outputs: ["enter", "over", "leave", "dropped"], exportAs: ["drop"] }, { kind: "component", type: i13.IgxDropDownComponent, selector: "igx-drop-down", inputs: ["allowItemsFocus", "labelledBy"], outputs: ["opening", "opened", "closing", "closed"] }, { kind: "component", type: i14.IgxDropDownItemComponent, selector: "igx-drop-down-item" }, { kind: "directive", type: i15.IgxDropDownItemNavigationDirective, selector: "[igxDropDownItemNavigation]", inputs: ["igxDropDownItemNavigation"] }, { kind: "pipe", type: i16.IgxHeaderGroupWidthPipe, name: "igxHeaderGroupWidth" }, { kind: "pipe", type: i16.IgxHeaderGroupStylePipe, name: "igxHeaderGroupStyle" }, { kind: "pipe", type: i17.IgxGridTopLevelColumns, name: "igxTopLevel" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: IgxPivotHeaderRowComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-pivot-header-row', template: "<div>\n    <div class=\"igx-grid-thead__wrapper igx-grid-thead__wrapper--pivot\" role=\"row\" [style.width.px]=\"width\">\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div class='igx-grid__tr-pivot--filter-container'>\n                <div #pivotFilterContainer *ngIf=\"grid.showPivotConfigurationUI\"\n                     class=\"igx-grid__tr-pivot igx-grid__tr-pivot--filter\" [style.min-width.px]=\"grid.pivotRowWidths - 1\"\n                     [style.max-width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, filterArea)\"\n                     igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\" (pointerdown)=\"$event.preventDefault()\">\n                    <!-- Filter area -->\n                    <igx-chips-area #filterArea droppable='true'>\n                    <span id='empty' igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\"\n                          *ngIf=\"grid.filterDimensions.length === 0\"\n                          class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_filter_drop_area}}</span>\n                        <ng-container *ngFor=\"let filter of this.filterAreaDimensions; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(filterArea)'></span>\n                            <igx-chip [id]=\"filter.memberName\" [draggable]=\"true\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'filter' }\"\n                                      [removable]=\"true\" (remove)=\"filterRemoved($event)\" (dragOver)=\"onDimDragOver($event, 2)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, filterArea, 2)\"\n                                      (moveStart)='onDimDragStart($event, filterArea)' (moveEnd)='onDimDragEnd()'>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, filter)'>filter_list</igx-icon>\n                                {{filter.memberName}}\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(filterArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, filterArea, 2)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_filter_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                    <div class=\"igx-grid__pivot-filter-toggle\" *ngIf=\"isFiltersButton && grid.filterDimensions.length !== 0\">\n                        <igx-icon #filterIcon (pointerdown)='onFilteringIconPointerDown($event)' (click)='onFiltersAreaDropdownClick($event)'>filter_list</igx-icon>\n                        <igx-badge value=\"{{this.filterDropdownDimensions.size}}\"></igx-badge>\n                    </div>\n                </div>\n                <div class='igx-grid__tr-pivot--drop-row-area' (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                     (dropped)=\"onDimDrop($event, rowArea, 0)\">\n                </div>\n            </div>\n\n            <div class=\"igx-grid__tr-pivot-group\">\n                <div #pivotColumnContainer *ngIf=\"grid.showPivotConfigurationUI\" class=\"igx-grid__tr-pivot\"\n                     (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop (igxDragLeave)=\"onAreaDragLeave($event, colArea)\">\n                    <!-- Columns area -->\n                    <igx-chips-area #colArea droppable='true'>\n                    <span id='empty' (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop\n                        *ngIf=\"grid.columnDimensions.length === 0\" class='igx-grid__pivot-empty-chip-area'>\n                        {{grid.resourceStrings.igx_grid_pivot_empty_column_drop_area}}</span>\n                        <ng-container *ngFor=\"let col of grid.columnDimensions; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(colArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"col.memberName\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'column' }\"\n                                      [removable]=\"true\" (remove)=\"columnRemoved($event)\" (dragOver)=\"onDimDragOver($event, 1)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, colArea, 1)\"\n                                      (moveStart)='onDimDragStart($event, colArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, col)\">\n                                <igx-icon igxPrefix>view_column</igx-icon>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, col)'>filter_list</igx-icon>\n                                {{col.memberName}}\n                                <igx-icon *ngIf=\"col.sortDirection\" igxSuffix> {{ col.sortDirection < 2 ? 'arrow_upward'\n                                    : 'arrow_downward' }}</igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(colArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, colArea, 1)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_column_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n\n                <div #pivotValueContainer *ngIf=\"grid.showPivotConfigurationUI\" class=\"igx-grid__tr-pivot\"\n                     (pointerdown)=\"$event.preventDefault()\" (dropped)=\"onValueDrop($event, valueArea)\" igxDrop\n                     (igxDragLeave)=\"onAreaDragLeave($event, valueArea)\">\n                    <!-- Value area -->\n                    <igx-chips-area #valueArea droppable='true'>\n                    <span id='empty' (dropped)=\"onValueDrop($event, valueArea)\" igxDrop *ngIf=\"grid.values.length === 0\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_value_drop_area}}</span>\n                    <ng-container *ngFor=\"let value of grid.values; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(valueArea)'></span>\n                            <igx-chip #currChip [draggable]=\"true\" [id]=\"value.displayName || value.member\" [data]=\"{ pivotArea: 'value' }\"\n                                      [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"valueRemoved($event)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragOver)=\"onDimDragOver($event)\"\n                                      (dragDrop)=\"onValueDrop($event, valueArea)\">\n                                <div class=\"igx-grid__tr-pivot-toggle-icons\" igxPrefix\n                                     (click)='onSummaryClick($event, value, dropdown, currChip)'\n                                     (pointerdown)='$event.stopPropagation()' [igxDropDownItemNavigation]=\"dropdown\">\n                                    <igx-icon>functions</igx-icon>\n                                    <igx-icon>arrow_drop_down</igx-icon>\n                                </div>\n                                <ng-container *ngTemplateOutlet=\"grid.valueChipTemplate ? grid.valueChipTemplate : valueChipDefaultTemplate; context: { $implicit: value }\"></ng-container>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(valueArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onValueDrop($event, valueArea)\" #notifyValueChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_value_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div role=\"rowgroup\" class=\"igx-grid-thead__wrapper\" [style.width.px]=\"width\"\n         [attr.aria-activedescendant]=\"activeDescendant\" [class.igx-grid__tr--mrl]=\"hasMRL\">\n\n        <!-- Column headers area -->\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div #pivotContainer class=\"igx-grid__tr-pivot igx-grid__tr-pivot--row-area\"\n                 [style.width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                 (dropped)=\"onDimDrop($event, rowArea, 0)\" (pointerdown)=\"$event.preventDefault()\">\n                <!-- Row area -->\n                <igx-chips-area #rowArea droppable='true'>\n                    <ng-container *ngIf=\"grid.showPivotConfigurationUI\">\n                    <span id='empty' igxDrop (dropped)=\"onDimDrop($event, rowArea, 0)\"\n                        *ngIf=\"grid.rowDimensions.length === 0 && grid.showPivotConfigurationUI\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_row_drop_area}}</span>\n                    <ng-container *ngFor=\"let row of grid.rowDimensions; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(rowArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"row.memberName\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'row' }\"\n                                      [removable]=\"true\" (remove)=\"rowRemoved($event)\" (dragLeave)=\"onDimDragLeave($event)\"\n                                      (dragDrop)=\"onDimDrop($event, rowArea, 0)\" (dragOver)=\"onDimDragOver($event, 0)\"\n                                      (moveStart)='onDimDragStart($event, rowArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, row)\">\n                                <igx-icon igxPrefix>table_rows</igx-icon>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, row)'>filter_list</igx-icon>\n                                {{ row.memberName}}\n                                <igx-icon *ngIf=\"row.sortDirection\" igxSuffix> {{ row.sortDirection < 2 ? 'arrow_upward'\n                                    : 'arrow_downward' }}</igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(rowArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, rowArea, 0)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_row_drop_chip}}\n                        </igx-chip>\n                    </ng-container>\n                </igx-chips-area>\n            </div>\n\n            <!-- Pinned columns collection from the start -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles | igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n            <div class=\"igx-grid-thead--virtualizationWrapper\" [style.max-height.px]='maxContainerHeight'>\n                <div class=\"igx-grid-thead__group igx-grid-thead--virtualizationContainer\" [style.height.px]='totalDepth > 1 ? grid.rowHeight : undefined' *ngFor='let dimLevelColumns of columnDimensionsByLevel; let i = index' [style.width.px]='grid.unpinnedWidth'>\n                    <ng-template igxGridFor #headerVirtualContainer let-column\n                                 [igxGridForOf]=\"dimLevelColumns\" [igxGridForOfUniqueSizeCache] = 'true' [igxForScrollContainer]=\"grid.parentVirtDir\"\n                                 [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\"\n                                 [igxForSizePropName]=\"'calcPixelWidth'\" [igxForScrollOrientation]=\"'horizontal'\">\n                        <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                               [style.height.px]='totalDepth > 1 ? calcHeight(column, i) : undefined'\n                                               [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                               [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [class.igx-grid__tr-pivot--columnDimensionLeaf] = 'isDuplicateOfExistingParent(column, i)'\n                                               [class.igx-grid__tr-pivot--columnMultiRowSpan] = 'isMultiRow(column, i)'\n                        >\n                        </igx-grid-header-group>\n                    </ng-template>\n                </div>\n            </div>\n\n            <!-- Pinned columns collection at the end -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && !grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.left]=\"column.rightPinnedOffset\" (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n        </div>\n    </div>\n</div>\n<!-- Header thumb area -->\n<div class=\"igx-grid-thead__thumb\" [hidden]=\"!grid.hasVerticalScroll()\" [style.width.px]=\"grid.scrollSize\">\n</div>\n\n<igx-drop-down #dropdown (selectionChanging)='onAggregationChange($event)'>\n    <igx-drop-down-item *ngFor=\"let item of aggregateList\" [selected]='isSelected(item)' [value]='item'>\n        {{ item.label }}\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<div [hidden]='true'>\n    <igx-grid-excel-style-filtering [maxHeight]='grid.excelStyleFilterMaxHeight' [minHeight]='grid.excelStyleFilterMinHeight' #esf>\n        <div igxExcelStyleColumnOperations>\n            <igx-chips-area #dropdownChips>\n                <igx-chip *ngFor=\"let filter of this.filterDropdownDimensions\" [id]=\"filter.memberName\"\n                [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"filterRemoved($event)\"\n                (chipClick)='onFiltersSelectionChanged($event)' [selectable]='true' [selected]='filter === this.filterDropdownDimensions.values().next().value'>\n                {{filter.memberName}}\n            </igx-chip>\n        </igx-chips-area>\n        </div>\n        <igx-excel-style-filter-operations>\n            <igx-excel-style-search></igx-excel-style-search>\n        </igx-excel-style-filter-operations>\n    </igx-grid-excel-style-filtering>\n</div>\n\n<div style=\"visibility: hidden; position: absolute; top: -10000px\">\n    <igx-chips-area #filterAreaHidden droppable='true'>\n        <igx-chip *ngFor=\"let filter of grid.filterDimensions\" [id]=\"filter.memberName\" [draggable]=\"true\"\n            [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"filterRemoved($event)\">\n            <igx-icon igxPrefix>filter_list</igx-icon>\n            {{filter.memberName}}\n        </igx-chip>\n    </igx-chips-area>\n</div>\n\n<ng-template #valueChipDefaultTemplate let-value>\n    {{value.aggregate.key}}({{value.displayName || value.member}})\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }]; }, propDecorators: { esf: [{
                type: ViewChild,
                args: ['esf']
            }], filterArea: [{
                type: ViewChild,
                args: ['filterAreaHidden', { static: false }]
            }], filtersButton: [{
                type: ViewChild,
                args: ['filterIcon']
            }], dropdownChips: [{
                type: ViewChild,
                args: ['dropdownChips']
            }], pivotFilterContainer: [{
                type: ViewChild,
                args: ['pivotFilterContainer']
            }], notificationChips: [{
                type: ViewChildren,
                args: ['notifyChip']
            }], headerContainers: [{
                type: ViewChildren,
                args: ['headerVirtualContainer', { read: IgxGridForOfDirective }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3QtaGVhZGVyLXJvdy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvcGl2b3QtZ3JpZC9waXZvdC1oZWFkZXItcm93LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LWhlYWRlci1yb3cuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILHVCQUF1QixFQUV2QixTQUFTLEVBRVQsTUFBTSxFQUlOLFNBQVMsRUFFVCxZQUFZLEVBQ2YsTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFDMUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sMENBQTBDLENBQUM7QUFHakYsT0FBTyxFQUFFLHNCQUFzQixFQUFFLG9CQUFvQixFQUFxQyxpQkFBaUIsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQy9JLE9BQU8sRUFBYyxhQUFhLEVBQWlCLE1BQU0sMEJBQTBCLENBQUM7QUFFcEYsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDakYsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRXhELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxjQUFjLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFekM7Ozs7Ozs7R0FPRztBQU1ILE1BQU0sT0FBTywwQkFBMkIsU0FBUSx5QkFBeUI7SUErRHJFLFlBQ2tDLElBQW1CLEVBQ3ZDLEdBQTRCLEVBQzVCLEdBQXNCLEVBQ3RCLFFBQW1CO1FBRTdCLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFMYyxTQUFJLEdB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MEJBQTBCLHVzQkF3RGEscUJBQXFCLHlFQ2hHekUsazVrQkFpUEE7MkZEek1hLDBCQUEwQjtrQkFMdEMsU0FBUztzQ0FDVyx1QkFBdUIsQ0FBQyxNQUFNLFlBQ3JDLHNCQUFzQjs7MEJBbUUzQixNQUFNOzJCQUFDLGFBQWE7NkhBMUNBLEdBQUc7c0JBQTNCLFNBQVM7dUJBQUMsS0FBSztnQkFLeUMsVUFBVTtzQkFBbEUsU0FBUzt1QkFBQyxrQkFBa0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7Z0JBS2hCLGFBQWE7c0JBQTVDLFNBQVM7dUJBQUMsWUFBWTtnQkFLWSxhQUFhO3NCQUEvQyxTQUFTO3VCQUFDLGVBQWU7Z0JBS2dCLG9CQUFvQjtzQkFBN0QsU0FBUzt1QkFBQyxzQkFBc0I7Z0JBTzFCLGlCQUFpQjtzQkFEdkIsWUFBWTt1QkFBQyxZQUFZO2dCQVNuQixnQkFBZ0I7c0JBRHRCLFlBQVk7dUJBQUMsd0JBQXdCLEVBQUUsRUFBRSxJQUFJLEVBQUUscUJBQXFCLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEluamVjdCxcbiAgICBPbkNoYW5nZXMsXG4gICAgUXVlcnlMaXN0LFxuICAgIFJlbmRlcmVyMixcbiAgICBWaWV3Q2hpbGQsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBWaWV3Q2hpbGRyZW5cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJQmFzZUNoaXBFdmVudEFyZ3MsIElneENoaXBDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jaGlwcy9jaGlwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hDaGlwc0FyZWFDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jaGlwcy9jaGlwcy1hcmVhLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTb3J0aW5nRGlyZWN0aW9uIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL3NvcnRpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgSWd4R3JpZEZvck9mRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9mb3Itb2YvZm9yX29mLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJU2VsZWN0aW9uRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vZHJvcC1kb3duL2Ryb3AtZG93bi5jb21tb24nO1xuaW1wb3J0IHsgSWd4RHJvcERvd25Db21wb25lbnQgfSBmcm9tICcuLi8uLi9kcm9wLWRvd24vZHJvcC1kb3duLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBBYnNvbHV0ZVNjcm9sbFN0cmF0ZWd5LCBBdXRvUG9zaXRpb25TdHJhdGVneSwgT3ZlcmxheVNldHRpbmdzLCBQb3NpdGlvblNldHRpbmdzLCBWZXJ0aWNhbEFsaWdubWVudCB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3B1YmxpY19hcGknO1xuaW1wb3J0IHsgQ29sdW1uVHlwZSwgSUdYX0dSSURfQkFTRSwgUGl2b3RHcmlkVHlwZSB9IGZyb20gJy4uL2NvbW1vbi9ncmlkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJZ3hHcmlkSGVhZGVyR3JvdXBDb21wb25lbnQgfSBmcm9tICcuLi9oZWFkZXJzL2dyaWQtaGVhZGVyLWdyb3VwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hHcmlkSGVhZGVyUm93Q29tcG9uZW50IH0gZnJvbSAnLi4vaGVhZGVycy9ncmlkLWhlYWRlci1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7IERyb3BQb3NpdGlvbiB9IGZyb20gJy4uL21vdmluZy9tb3Zpbmcuc2VydmljZSc7XG5pbXBvcnQgeyBJUGl2b3RBZ2dyZWdhdG9yLCBJUGl2b3REaW1lbnNpb24sIElQaXZvdFZhbHVlLCBQaXZvdERpbWVuc2lvblR5cGUgfSBmcm9tICcuL3Bpdm90LWdyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBpdm90VXRpbCB9IGZyb20gJy4vcGl2b3QtdXRpbCc7XG5cbi8qKlxuICpcbiAqIEZvciBhbGwgaW50ZW50cyAmIHB1cnBvc2VzIHRyZWF0IHRoaXMgY29tcG9uZW50IGFzIHdoYXQgYSA8dGhlYWQ+IHVzdWFsbHkgaXMgaW4gdGhlIGRlZmF1bHQgPHRhYmxlPiBlbGVtZW50LlxuICpcbiAqIFRoaXMgY29udGFpbmVyIGhvbGRzIHRoZSBwaXZvdCBncmlkIGhlYWRlciBlbGVtZW50cyBhbmQgdGhlaXIgYmVoYXZpb3IvaW50ZXJhY3Rpb25zLlxuICpcbiAqIEBoaWRkZW4gQGludGVybmFsXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHNlbGVjdG9yOiAnaWd4LXBpdm90LWhlYWRlci1yb3cnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9waXZvdC1oZWFkZXItcm93LmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdEhlYWRlclJvd0NvbXBvbmVudCBleHRlbmRzIElneEdyaWRIZWFkZXJSb3dDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICAgIHB1YmxpYyBhZ2dyZWdhdGVMaXN0OiBJUGl2b3RBZ2dyZWdhdG9yW10gPSBbXTtcblxuICAgIHB1YmxpYyB2YWx1ZTogSVBpdm90VmFsdWU7XG4gICAgcHVibGljIGZpbHRlckRyb3Bkb3duRGltZW5zaW9uczogU2V0PGFueT4gPSBuZXcgU2V0PGFueT4oKTtcbiAgICBwdWJsaWMgZmlsdGVyQXJlYURpbWVuc2lvbnM6IFNldDxhbnk+ID0gbmV3IFNldDxhbnk+KCk7XG4gICAgcHJpdmF0ZSBfZHJvcFBvcyA9IERyb3BQb3NpdGlvbi5BZnRlckRyb3BUYXJnZXQ7XG4gICAgcHJpdmF0ZSB2YWx1ZURhdGE6IE1hcDxzdHJpbmcsIElQaXZvdEFnZ3JlZ2F0b3JbXT47XG4gICAgcHJpdmF0ZSBfc3ViTWVudVBvc2l0aW9uU2V0dGluZ3M6IFBvc2l0aW9uU2V0dGluZ3MgPSB7XG4gICAgICAgIHZlcnRpY2FsU3RhcnRQb2ludDogVmVydGljYWxBbGlnbm1lbnQuQm90dG9tLFxuICAgICAgICBjbG9zZUFuaW1hdGlvbjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBwcml2YXRlIF9zdWJNZW51T3ZlcmxheVNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3MgPSB7XG4gICAgICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IHRydWUsXG4gICAgICAgIG1vZGFsOiBmYWxzZSxcbiAgICAgICAgcG9zaXRpb25TdHJhdGVneTogbmV3IEF1dG9Qb3NpdGlvblN0cmF0ZWd5KHRoaXMuX3N1Yk1lbnVQb3NpdGlvblNldHRpbmdzKSxcbiAgICAgICAgc2Nyb2xsU3RyYXRlZ3k6IG5ldyBBYnNvbHV0ZVNjcm9sbFN0cmF0ZWd5KClcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdlc2YnKSBwdWJsaWMgZXNmOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2ZpbHRlckFyZWFIaWRkZW4nLCB7IHN0YXRpYzogZmFsc2UgfSkgcHVibGljIGZpbHRlckFyZWE7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2ZpbHRlckljb24nKSBwdWJsaWMgZmlsdGVyc0J1dHRvbjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZHJvcGRvd25DaGlwcycpIHB1YmxpYyBkcm9wZG93bkNoaXBzO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdwaXZvdEZpbHRlckNvbnRhaW5lcicpIHB1YmxpYyBwaXZvdEZpbHRlckNvbnRhaW5lcjtcblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBAVmlld0NoaWxkcmVuKCdub3RpZnlDaGlwJylcbiAgICBwdWJsaWMgbm90aWZpY2F0aW9uQ2hpcHM6IFF1ZXJ5TGlzdDxJZ3hDaGlwQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKiBUaGUgdmlydHVhbGl6ZWQgcGFydCBvZiB0aGUgaGVhZGVyIHJvdyBjb250YWluaW5nIHRoZSB1bnBpbm5lZCBoZWFkZXIgZ3JvdXBzLlxuICAgICovXG4gICAgQFZpZXdDaGlsZHJlbignaGVhZGVyVmlydHVhbENvbnRhaW5lcicsIHsgcmVhZDogSWd4R3JpZEZvck9mRGlyZWN0aXZlIH0pXG4gICAgcHVibGljIGhlYWRlckNvbnRhaW5lcnM6IFF1ZXJ5TGlzdDxJZ3hHcmlkRm9yT2ZEaXJlY3RpdmU8SWd4R3JpZEhlYWRlckdyb3VwQ29tcG9uZW50Pj47XG5cbiAgICBwdWJsaWMgZ2V0IGhlYWRlckZvck9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJDb250YWluZXJzLmxhc3Q7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoSUdYX0dSSURfQkFTRSkgcHVibGljIGdyaWQ6IFBpdm90R3JpZFR5cGUsXG4gICAgICAgIHByb3RlY3RlZCByZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgICAgICBwcm90ZWN0ZWQgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJvdGVjdGVkIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHJlZiwgY2RyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICogRGVmYXVsdCBpcyBhIHNpbmdsZSBlbXB0eSBsZXZlbCBzaW5jZSBkZWZhdWx0IGRlcHRoIGlzIDFcbiAgICAqL1xuICAgIHB1YmxpYyBjb2x1bW5EaW1lbnNpb25zQnlMZXZlbDogYW55W10gPSBbW11dO1xuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIGdldCBpc0ZpbHRlcnNCdXR0b24oKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBjaGlwc1dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5maWx0ZXJBcmVhRGltZW5zaW9ucy5jbGVhcigpO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJBcmVhPy5jaGlwc0xpc3QgJiYgdGhpcy5maWx0ZXJBcmVhLmNoaXBzTGlzdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5waXZvdEZpbHRlckNvbnRhaW5lci5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmdzID0gcGFyc2VGbG9hdChzdHlsZXMucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChzdHlsZXMucGFkZGluZ1JpZ2h0KTtcbiAgICAgICAgICAgIGNoaXBzV2lkdGggKz0gY29udGFpbmVyUGFkZGluZ3MgKyAodGhpcy5maWx0ZXJzQnV0dG9uICYmIHRoaXMuZmlsdGVyQXJlYT8uY2hpcHNMaXN0Lmxlbmd0aCA+IDEgPyB0aGlzLmZpbHRlcnNCdXR0b24uZWwubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA6IDApO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJBcmVhLmNoaXBzTGlzdC5mb3JFYWNoKGNoaXAgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpbSA9IHRoaXMuZ3JpZC5maWx0ZXJEaW1lbnNpb25zLmZpbmQoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGNoaXAuaWQpO1xuICAgICAgICAgICAgICAgIGlmIChkaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gOCBweCBtYXJnaW4gYmV0d2VlbiBjaGlwc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2hpcFdpZHRoID0gY2hpcC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgODtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaXBzV2lkdGggKyBjdXJyZW50Q2hpcFdpZHRoIDwgdGhpcy5ncmlkLnBpdm90Um93V2lkdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckFyZWFEaW1lbnNpb25zLmFkZChkaW0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnMuYWRkKGRpbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hpcHNXaWR0aCArPSBjdXJyZW50Q2hpcFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyRHJvcGRvd25EaW1lbnNpb25zLnNpemUgPiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIGdldCB0b3RhbERlcHRoKCkge1xuICAgICAgICBjb25zdCBjb2x1bW5EaW1lbnNpb25zID0gdGhpcy5ncmlkLmNvbHVtbkRpbWVuc2lvbnM7XG4gICAgICAgIGlmIChjb2x1bW5EaW1lbnNpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvdGFsRGVwdGggPSBjb2x1bW5EaW1lbnNpb25zLm1hcCh4ID0+IFBpdm90VXRpbC5nZXREaW1lbnNpb25EZXB0aCh4KSArIDEpLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCk7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuaGFzTXVsdGlwbGVWYWx1ZXMpIHtcbiAgICAgICAgICAgIHRvdGFsRGVwdGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxEZXB0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIGdldCBtYXhDb250YWluZXJIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsRGVwdGggKiB0aGlzLmdyaWQucmVuZGVyZWRSb3dIZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBjYWxjSGVpZ2h0KGNvbDogQ29sdW1uVHlwZSwgaW5kZXg6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gIWNvbC5jb2x1bW5Hcm91cCAmJiBjb2wubGV2ZWwgPCB0aGlzLnRvdGFsRGVwdGggJiYgY29sLmxldmVsID09PSBpbmRleCA/ICh0aGlzLnRvdGFsRGVwdGggLSBjb2wubGV2ZWwpICogdGhpcy5ncmlkLnJvd0hlaWdodCA6IHRoaXMuZ3JpZC5yb3dIZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBpc0R1cGxpY2F0ZU9mRXhpc3RpbmdQYXJlbnQoY29sOiBDb2x1bW5UeXBlLCBsdmw6IG51bWJlcikge1xuICAgICAgICBjb25zdCBwYXJlbnRDb2xsZWN0aW9uID0gbHZsID4gMCA/IHRoaXMuY29sdW1uRGltZW5zaW9uc0J5TGV2ZWxbbHZsIC0gMV0gOiBbXTtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlID0gcGFyZW50Q29sbGVjdGlvbi5pbmRleE9mKGNvbCkgIT09IC0xO1xuXG4gICAgICAgIHJldHVybiBkdXBsaWNhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBpc011bHRpUm93KGNvbDogQ29sdW1uVHlwZSwgbHZsOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgaXNMZWFmID0gIWNvbC5jb2x1bW5Hcm91cDtcbiAgICAgICAgcmV0dXJuIGlzTGVhZiAmJiBsdmwgIT09IHRoaXMudG90YWxEZXB0aCAtIDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBwb3B1bGF0ZUNvbHVtbkRpbWVuc2lvbnNCeUxldmVsKCkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRvdGFsRGVwdGg7IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMudW5waW5uZWRDb2x1bW5Db2xsZWN0aW9uO1xuICAgICAgICAvLyBwb3B1bGF0ZSBjb2x1bW4gZGltZW5zaW9uIG1hdHJpeCByZWN1cnNpdmVseVxuICAgICAgICB0aGlzLnBvcHVsYXRlRGltZW5zaW9uUmVjdXJzaXZlbHkoY29scy5maWx0ZXIoeCA9PiB4LmxldmVsID09PSAwKSwgMCwgcmVzKTtcbiAgICAgICAgdGhpcy5jb2x1bW5EaW1lbnNpb25zQnlMZXZlbCA9IHJlcztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcG9wdWxhdGVEaW1lbnNpb25SZWN1cnNpdmVseShjdXJyZW50TGV2ZWxDb2x1bW5zOiBDb2x1bW5UeXBlW10sIGxldmVsID0gMCwgcmVzOiBhbnlbXSkge1xuICAgICAgICBjdXJyZW50TGV2ZWxDb2x1bW5zLmZvckVhY2goY29sID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNbbGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgcmVzW2xldmVsXS5wdXNoKGNvbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5jb2x1bW5Hcm91cCAmJiBjb2wuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aXNpYmxlQ29sdW1ucyA9IGNvbC5jaGlsZHJlbi50b0FycmF5KCkuZmlsdGVyKHggPT4gIXguaGlkZGVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZURpbWVuc2lvblJlY3Vyc2l2ZWx5KHZpc2libGVDb2x1bW5zLCBsZXZlbCArIDEsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZXZlbCA8IHRoaXMudG90YWxEZXB0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxldmVsICsgMTsgaSA8PSB0aGlzLnRvdGFsRGVwdGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1tpXS5wdXNoKGNvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy51bnBpbm5lZENvbHVtbkNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGVDb2x1bW5EaW1lbnNpb25zQnlMZXZlbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkRpbURyYWdTdGFydChldmVudCwgYXJlYSkge1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGZvciAobGV0IGNoaXAgb2YgdGhpcy5ub3RpZmljYXRpb25DaGlwcykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gY2hpcC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoYXJlYS5jaGlwc0xpc3QudG9BcnJheSgpLmluZGV4T2YoY2hpcCkgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uaXRlbSgwKS5pZCAhPT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgICAgIGNoaXAubmF0aXZlRWxlbWVudC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50RWxlbWVudC5zY3JvbGxUbyh7IGxlZnQ6IGNoaXAubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkRpbURyYWdFbmQoKSB7XG4gICAgICAgIGZvciAobGV0IGNoaXAgb2YgdGhpcy5ub3RpZmljYXRpb25DaGlwcykge1xuICAgICAgICAgICAgY2hpcC5uYXRpdmVFbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIGdldEFyZWFIZWlnaHQoYXJlYTogSWd4Q2hpcHNBcmVhQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IGNoaXBzID0gYXJlYS5jaGlwc0xpc3Q7XG4gICAgICAgIHJldHVybiBjaGlwcyAmJiBjaGlwcy5sZW5ndGggPiAwID8gY2hpcHMuZmlyc3QubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgcm93UmVtb3ZlZChldmVudDogSUJhc2VDaGlwRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ3JpZC5waXZvdENvbmZpZ3VyYXRpb24ucm93cy5maW5kKHggPT4geC5tZW1iZXJOYW1lID09PSBldmVudC5vd25lci5pZCk7XG4gICAgICAgIHRoaXMuZ3JpZC50b2dnbGVEaW1lbnNpb24ocm93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIGNvbHVtblJlbW92ZWQoZXZlbnQ6IElCYXNlQ2hpcEV2ZW50QXJncykge1xuICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdyaWQucGl2b3RDb25maWd1cmF0aW9uLmNvbHVtbnMuZmluZCh4ID0+IHgubWVtYmVyTmFtZSA9PT0gZXZlbnQub3duZXIuaWQpO1xuICAgICAgICB0aGlzLmdyaWQudG9nZ2xlRGltZW5zaW9uKGNvbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyB2YWx1ZVJlbW92ZWQoZXZlbnQ6IElCYXNlQ2hpcEV2ZW50QXJncykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ3JpZC5waXZvdENvbmZpZ3VyYXRpb24udmFsdWVzLmZpbmQoeCA9PiB4Lm1lbWJlciA9PT0gZXZlbnQub3duZXIuaWQgfHwgeC5kaXNwbGF5TmFtZSA9PT0gZXZlbnQub3duZXIuaWQpO1xuICAgICAgICB0aGlzLmdyaWQudG9nZ2xlVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgZmlsdGVyUmVtb3ZlZChldmVudDogSUJhc2VDaGlwRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZ3JpZC5waXZvdENvbmZpZ3VyYXRpb24uZmlsdGVycy5maW5kKHggPT4geC5tZW1iZXJOYW1lID09PSBldmVudC5vd25lci5pZCk7XG4gICAgICAgIHRoaXMuZ3JpZC50b2dnbGVEaW1lbnNpb24oZmlsdGVyKTtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyRHJvcGRvd25EaW1lbnNpb25zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm9uRmlsdGVyc0FyZWFEcm9wZG93bkNsaWNrKHsgdGFyZ2V0OiB0aGlzLmZpbHRlcnNCdXR0b24uZWwubmF0aXZlRWxlbWVudCB9LCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLmhpZGVFU0YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBvbkZpbHRlcnNTZWxlY3Rpb25DaGFuZ2VkKGV2ZW50PzogSUJhc2VDaGlwRXZlbnRBcmdzKSB7XG4gICAgICAgIHRoaXMuZHJvcGRvd25DaGlwcy5jaGlwc0xpc3QuZm9yRWFjaChjaGlwID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlwLmlkICE9PSBldmVudC5vd25lci5pZCkge1xuICAgICAgICAgICAgICAgIGNoaXAuc2VsZWN0ZWQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkZpbHRlcnNBcmVhRHJvcGRvd25DbGljayh7IHRhcmdldDogdGhpcy5maWx0ZXJzQnV0dG9uLmVsLm5hdGl2ZUVsZW1lbnQgfSwgdGhpcy5ncmlkLmZpbHRlckRpbWVuc2lvbnMuZmluZChkaW0gPT4gZGltLm1lbWJlck5hbWUgPT09IGV2ZW50Lm93bmVyLmlkKSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25GaWx0ZXJpbmdJY29uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkZpbHRlcmluZ0ljb25DbGljayhldmVudCwgZGltZW5zaW9uKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgZGltID0gZGltZW5zaW9uO1xuICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdyaWQuZGltZW5zaW9uRGF0YUNvbHVtbnMuZmluZCh4ID0+IHguZmllbGQgPT09IGRpbS5tZW1iZXJOYW1lIHx8IHguZmllbGQgPT09IGRpbS5tZW1iZXIpO1xuICAgICAgICB0aGlzLmdyaWQuZmlsdGVyaW5nU2VydmljZS50b2dnbGVGaWx0ZXJEcm9wZG93bihldmVudC50YXJnZXQsIGNvbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvblN1bW1hcnlDbGljayhldmVudEFyZ3MsIHZhbHVlOiBJUGl2b3RWYWx1ZSwgZHJvcGRvd246IElneERyb3BEb3duQ29tcG9uZW50LCBjaGlwOiBJZ3hDaGlwQ29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuX3N1Yk1lbnVPdmVybGF5U2V0dGluZ3MudGFyZ2V0ID0gZXZlbnRBcmdzLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHRoaXMudXBkYXRlRHJvcERvd24odmFsdWUsIGRyb3Bkb3duLCBjaGlwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvbkZpbHRlcnNBcmVhRHJvcGRvd25DbGljayhldmVudCwgZGltZW5zaW9uPywgc2hvdWxkUmVhdHRhY2ggPSB0cnVlKSB7XG4gICAgICAgIGxldCBkaW0gPSBkaW1lbnNpb24gfHwgdGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdyaWQuZGltZW5zaW9uRGF0YUNvbHVtbnMuZmluZCh4ID0+IHguZmllbGQgPT09IGRpbS5tZW1iZXJOYW1lIHx8IHguZmllbGQgPT09IGRpbS5tZW1iZXIpO1xuICAgICAgICBpZiAoc2hvdWxkUmVhdHRhY2gpIHtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd25DaGlwcy5jaGlwc0xpc3QuZm9yRWFjaChjaGlwID0+IHtcbiAgICAgICAgICAgICAgICBjaGlwLnNlbGVjdGVkID0gZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bkNoaXBzLmNoaXBzTGlzdC5maXJzdC5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UudG9nZ2xlRmlsdGVyc0VTRih0aGlzLmVzZiwgZXZlbnQudGFyZ2V0LCBjb2wsIHNob3VsZFJlYXR0YWNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uQWdncmVnYXRpb25DaGFuZ2UoZXZlbnQ6IElTZWxlY3Rpb25FdmVudEFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQoZXZlbnQubmV3U2VsZWN0aW9uLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5hZ2dyZWdhdGUgPSBldmVudC5uZXdTZWxlY3Rpb24udmFsdWU7XG4gICAgICAgICAgICB0aGlzLmdyaWQucGlwZVRyaWdnZXIrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgaXNTZWxlY3RlZCh2YWw6IElQaXZvdEFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuYWdncmVnYXRlLmtleSA9PT0gdmFsLmtleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uQ2hpcFNvcnQoX2V2ZW50LCBkaW1lbnNpb246IElQaXZvdERpbWVuc2lvbikge1xuICAgICAgICBjb25zdCBzdGFydERpcmVjdGlvbiA9IGRpbWVuc2lvbi5zb3J0RGlyZWN0aW9uIHx8IFNvcnRpbmdEaXJlY3Rpb24uTm9uZTtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gc3RhcnREaXJlY3Rpb24gKyAxID4gU29ydGluZ0RpcmVjdGlvbi5EZXNjID9cbiAgICAgICAgICAgIFNvcnRpbmdEaXJlY3Rpb24uTm9uZSA6IHN0YXJ0RGlyZWN0aW9uICsgMTtcbiAgICAgICAgdGhpcy5ncmlkLnNvcnREaW1lbnNpb24oZGltZW5zaW9uLCBkaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25EaW1EcmFnT3ZlcihldmVudCwgZGltZW5zaW9uPzogUGl2b3REaW1lbnNpb25UeXBlKSB7XG4gICAgICAgIGlmICghZXZlbnQuZHJhZ0NoaXAgfHwgIWV2ZW50LmRyYWdDaGlwLmRhdGE/LnBpdm90QXJlYSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB0eXBlTWlzbWF0Y2ggPSBkaW1lbnNpb24gIT09IHVuZGVmaW5lZCA/IHRoaXMuZ3JpZC5waXZvdENvbmZpZ3VyYXRpb24udmFsdWVzLmZpbmQoeCA9PiB4Lm1lbWJlciA9PT0gZXZlbnQuZHJhZ0NoaXAuaWRcbiAgICAgICAgICAgIHx8IHguZGlzcGxheU5hbWUgPT09IGV2ZW50LmRyYWdDaGlwLmlkKSA6XG4gICAgICAgICAgICAhdGhpcy5ncmlkLnBpdm90Q29uZmlndXJhdGlvbi52YWx1ZXMuZmluZCh4ID0+IHgubWVtYmVyID09PSBldmVudC5kcmFnQ2hpcC5pZCB8fCB4LmRpc3BsYXlOYW1lID09PSBldmVudC5kcmFnQ2hpcC5pZCk7XG4gICAgICAgIGlmICh0eXBlTWlzbWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIGNhbm5vdCBkcmFnIGJldHdlZW4gZGltZW5zaW9ucyBhbmQgdmFsdWVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBhcmUgaW4gdGhlIGxlZnQgaGFsZiBvZiB0aGUgY2hpcCwgZHJvcCBvbiB0aGUgbGVmdFxuICAgICAgICAvLyBlbHNlIGRyb3Agb24gdGhlIHJpZ2h0IG9mIHRoZSBjaGlwXG4gICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBldmVudC5vd25lci5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBwb3MgPSBjbGllbnRSZWN0LndpZHRoIC8gMjtcblxuICAgICAgICB0aGlzLl9kcm9wUG9zID0gZXZlbnQub3JpZ2luYWxFdmVudC5vZmZzZXRYID4gcG9zID8gRHJvcFBvc2l0aW9uLkFmdGVyRHJvcFRhcmdldCA6IERyb3BQb3NpdGlvbi5CZWZvcmVEcm9wVGFyZ2V0O1xuICAgICAgICBpZiAodGhpcy5fZHJvcFBvcyA9PT0gRHJvcFBvc2l0aW9uLkFmdGVyRHJvcFRhcmdldCkge1xuICAgICAgICAgICAgZXZlbnQub3duZXIubmF0aXZlRWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGV2ZW50Lm93bmVyLm5hdGl2ZUVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50Lm93bmVyLm5hdGl2ZUVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGV2ZW50Lm93bmVyLm5hdGl2ZUVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZy5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uRGltRHJhZ0xlYXZlKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50Lm93bmVyLm5hdGl2ZUVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGV2ZW50Lm93bmVyLm5hdGl2ZUVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5fZHJvcFBvcyA9IERyb3BQb3NpdGlvbi5BZnRlckRyb3BUYXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkFyZWFEcmFnTGVhdmUoZXZlbnQsIGFyZWEpIHtcbiAgICAgICAgY29uc3QgZGF0YUNoaXBzID0gYXJlYS5jaGlwc0xpc3QudG9BcnJheSgpLmZpbHRlcih4ID0+IHRoaXMubm90aWZpY2F0aW9uQ2hpcHMudG9BcnJheSgpLmluZGV4T2YoeCkgPT09IC0xKTtcbiAgICAgICAgZGF0YUNoaXBzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5uYXRpdmVFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5uYXRpdmVFbGVtZW50Lm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubmF0aXZlRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uVmFsdWVEcm9wKGV2ZW50LCBhcmVhKSB7XG4gICAgICAgIGlmICghKGV2ZW50LmRyYWdDaGlwICYmIGV2ZW50LmRyYWdDaGlwLmRhdGE/LnBpdm90QXJlYSkgJiYgIShldmVudC5kcmFnRGF0YT8uY2hpcCAmJiAhIWV2ZW50LmRyYWdEYXRhLmNoaXAuZGF0YS5waXZvdEFyZWEpKSByZXR1cm47XG4gICAgICAgIC8vdmFsdWVzIGNhbiBvbmx5IGJlIHJlb3JkZXJlZFxuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmdyaWQucGl2b3RDb25maWd1cmF0aW9uLnZhbHVlcztcbiAgICAgICAgY29uc3QgZHJhZ0lkID0gZXZlbnQuZHJhZ0NoaXA/LmlkIHx8IGV2ZW50LmRyYWdEYXRhPy5jaGlwLmlkO1xuICAgICAgICBjb25zdCBjaGlwc0FycmF5ID0gYXJlYS5jaGlwc0xpc3QudG9BcnJheSgpO1xuICAgICAgICBsZXQgY2hpcEluZGV4ID0gY2hpcHNBcnJheS5pbmRleE9mKGV2ZW50Lm93bmVyKSAhPT0gLTEgPyBjaGlwc0FycmF5LmluZGV4T2YoZXZlbnQub3duZXIpIDogY2hpcHNBcnJheS5sZW5ndGg7XG4gICAgICAgIGNoaXBJbmRleCA9IHRoaXMuX2Ryb3BQb3MgPT09IERyb3BQb3NpdGlvbi5BZnRlckRyb3BUYXJnZXQgPyBjaGlwSW5kZXggKyAxIDogY2hpcEluZGV4O1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlcy5maW5kKHggPT4geC5tZW1iZXIgPT09IGRyYWdJZCB8fCB4LmRpc3BsYXlOYW1lID09PSBkcmFnSWQpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRyYWdDaGlwSW5kZXggPSBjaGlwc0FycmF5LmluZGV4T2YoZXZlbnQuZHJhZ0NoaXAgfHwgZXZlbnQuZHJhZ0RhdGEuY2hpcCk7XG4gICAgICAgICAgICB0aGlzLmdyaWQubW92ZVZhbHVlKHZhbHVlLCBkcmFnQ2hpcEluZGV4ID49IGNoaXBJbmRleCA/IGNoaXBJbmRleCA6IGNoaXBJbmRleCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkRpbURyb3AoZXZlbnQsIGFyZWEsIGRpbWVuc2lvblR5cGU6IFBpdm90RGltZW5zaW9uVHlwZSkge1xuICAgICAgICBpZiAoIShldmVudC5kcmFnQ2hpcCAmJiBldmVudC5kcmFnQ2hpcC5kYXRhPy5waXZvdEFyZWEpICYmICEoZXZlbnQuZHJhZ0RhdGE/LmNoaXAgJiYgISFldmVudC5kcmFnRGF0YS5jaGlwLmRhdGEucGl2b3RBcmVhKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBkcmFnSWQgPSBldmVudC5kcmFnQ2hpcD8uaWQgfHwgZXZlbnQuZHJhZ0RhdGE/LmNoaXAuaWQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREaW0gPSB0aGlzLmdyaWQuZ2V0RGltZW5zaW9uc0J5VHlwZShkaW1lbnNpb25UeXBlKTtcbiAgICAgICAgY29uc3QgY2hpcHNBcnJheSA9IGFyZWEuY2hpcHNMaXN0LnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3QgY2hpcCA9IGNoaXBzQXJyYXkuZmluZCh4ID0+IHguaWQgPT09IGRyYWdJZCk7XG4gICAgICAgIGNvbnN0IGlzTmV3Q2hpcCA9IGNoaXAgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaXNSZW9yZGVyID0gZXZlbnQub3duZXIuaWQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgLy9jb25zdCBjaGlwSW5kZXggPSBjaGlwc0FycmF5LmluZGV4T2YoZXZlbnQub3duZXIpICE9PSAtMSA/IGNoaXBzQXJyYXkuaW5kZXhPZihldmVudC5vd25lcikgOiBjaGlwc0FycmF5Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgY2hpcEluZGV4ID0gY3VycmVudERpbS5maW5kSW5kZXgoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGV2ZW50Lm93bmVyLmlkKSAhPT0gLTEgP1xuICAgICAgICAgICAgY3VycmVudERpbS5maW5kSW5kZXgoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGV2ZW50Lm93bmVyLmlkKSA6IGN1cnJlbnREaW0ubGVuZ3RoO1xuICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuX2Ryb3BQb3MgPT09IERyb3BQb3NpdGlvbi5BZnRlckRyb3BUYXJnZXQgPyBjaGlwSW5kZXggKyAxIDogY2hpcEluZGV4O1xuICAgICAgICBpZiAoaXNOZXdDaGlwKSB7XG4gICAgICAgICAgICAvLyBjaGlwIG1vdmVkIGZyb20gYW4gZXh0ZXJuYWwgY29sbGVjdGlvblxuICAgICAgICAgICAgY29uc3QgZGltID0gdGhpcy5ncmlkLmFsbERpbWVuc2lvbnMuZmluZCh4ID0+IHggJiYgeC5tZW1iZXJOYW1lID09PSBkcmFnSWQpO1xuICAgICAgICAgICAgaWYgKCFkaW0pIHtcbiAgICAgICAgICAgICAgICAvLyB5b3UgaGF2ZSBkcmFnZ2VkIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGRpbWVuc2lvblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ3JpZC5tb3ZlRGltZW5zaW9uKGRpbSwgZGltZW5zaW9uVHlwZSwgdGFyZ2V0SW5kZXgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVvcmRlcikge1xuICAgICAgICAgICAgLy8gY2hpcCBmcm9tIHNhbWUgY29sbGVjdGlvbiwgcmVvcmRlcmVkLlxuICAgICAgICAgICAgY29uc3QgbmV3RGltID0gY3VycmVudERpbS5maW5kKHggPT4geC5tZW1iZXJOYW1lID09PSBkcmFnSWQpO1xuICAgICAgICAgICAgY29uc3QgZHJhZ0NoaXBJbmRleCA9IGN1cnJlbnREaW0uZmluZEluZGV4KHggPT4geC5tZW1iZXJOYW1lID09PSBkcmFnSWQpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLm1vdmVEaW1lbnNpb24obmV3RGltLCBkaW1lbnNpb25UeXBlLCBkcmFnQ2hpcEluZGV4ID4gY2hpcEluZGV4ID8gdGFyZ2V0SW5kZXggOiB0YXJnZXRJbmRleCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZC5waXBlVHJpZ2dlcisrO1xuICAgICAgICB0aGlzLmdyaWQuZGltZW5zaW9uc0NoYW5nZS5lbWl0KHsgZGltZW5zaW9uczogY3VycmVudERpbSwgZGltZW5zaW9uQ29sbGVjdGlvblR5cGU6IGRpbWVuc2lvblR5cGUgfSk7XG4gICAgICAgIC8vIGNsZWFuIHN0YXRlc1xuICAgICAgICB0aGlzLm9uRGltRHJhZ0VuZCgpO1xuICAgICAgICB0aGlzLm9uQXJlYURyYWdMZWF2ZShldmVudCwgYXJlYSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHVwZGF0ZURyb3BEb3duKHZhbHVlOiBJUGl2b3RWYWx1ZSwgZHJvcGRvd246IElneERyb3BEb3duQ29tcG9uZW50LCBjaGlwOiBJZ3hDaGlwQ29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZHJvcGRvd24ud2lkdGggPSBjaGlwLm5hdGl2ZUVsZW1lbnQuY2xpZW50V2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZUxpc3QgPSBQaXZvdFV0aWwuZ2V0QWdncmVnYXRlTGlzdCh2YWx1ZSwgdGhpcy5ncmlkKTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICBkcm9wZG93bi5vcGVuKHRoaXMuX3N1Yk1lbnVPdmVybGF5U2V0dGluZ3MpO1xuICAgIH1cbn1cbiIsIjxkaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkLXRoZWFkX193cmFwcGVyIGlneC1ncmlkLXRoZWFkX193cmFwcGVyLS1waXZvdFwiIHJvbGU9XCJyb3dcIiBbc3R5bGUud2lkdGgucHhdPVwid2lkdGhcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190clwiIHJvbGU9XCJyb3dcIiBbc3R5bGUud2lkdGgucHhdPVwid2lkdGhcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J2lneC1ncmlkX190ci1waXZvdC0tZmlsdGVyLWNvbnRhaW5lcic+XG4gICAgICAgICAgICAgICAgPGRpdiAjcGl2b3RGaWx0ZXJDb250YWluZXIgKm5nSWY9XCJncmlkLnNob3dQaXZvdENvbmZpZ3VyYXRpb25VSVwiXG4gICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdCBpZ3gtZ3JpZF9fdHItcGl2b3QtLWZpbHRlclwiIFtzdHlsZS5taW4td2lkdGgucHhdPVwiZ3JpZC5waXZvdFJvd1dpZHRocyAtIDFcIlxuICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLm1heC13aWR0aC5weF09XCJncmlkLnBpdm90Um93V2lkdGhzIC0gMVwiIChpZ3hEcmFnTGVhdmUpPVwib25BcmVhRHJhZ0xlYXZlKCRldmVudCwgZmlsdGVyQXJlYSlcIlxuICAgICAgICAgICAgICAgICAgICAgaWd4RHJvcCAoZHJvcHBlZCk9XCJvbkRpbURyb3AoJGV2ZW50LCBmaWx0ZXJBcmVhLCAyKVwiIChwb2ludGVyZG93bik9XCIkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuICAgICAgICAgICAgICAgICAgICA8IS0tIEZpbHRlciBhcmVhIC0tPlxuICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXBzLWFyZWEgI2ZpbHRlckFyZWEgZHJvcHBhYmxlPSd0cnVlJz5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9J2VtcHR5JyBpZ3hEcm9wIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIGZpbHRlckFyZWEsIDIpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJncmlkLmZpbHRlckRpbWVuc2lvbnMubGVuZ3RoID09PSAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9J2lneC1ncmlkX19waXZvdC1lbXB0eS1jaGlwLWFyZWEnPnt7Z3JpZC5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcGl2b3RfZW1wdHlfZmlsdGVyX2Ryb3BfYXJlYX19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgZmlsdGVyIG9mIHRoaXMuZmlsdGVyQXJlYURpbWVuc2lvbnM7IGxldCBsYXN0ID0gbGFzdDtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIFtzdHlsZS52aXNpYmlsaXR5XT0nXCJoaWRkZW5cIicgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtLWNoaXBfZHJvcF9pbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2dldEFyZWFIZWlnaHQoZmlsdGVyQXJlYSknPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXAgW2lkXT1cImZpbHRlci5tZW1iZXJOYW1lXCIgW2RyYWdnYWJsZV09XCJ0cnVlXCIgW2Rpc3BsYXlEZW5zaXR5XT1cImdyaWQuZGlzcGxheURlbnNpdHlcIiBbZGF0YV09XCJ7IHBpdm90QXJlYTogJ2ZpbHRlcicgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZW1vdmFibGVdPVwidHJ1ZVwiIChyZW1vdmUpPVwiZmlsdGVyUmVtb3ZlZCgkZXZlbnQpXCIgKGRyYWdPdmVyKT1cIm9uRGltRHJhZ092ZXIoJGV2ZW50LCAyKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkcmFnTGVhdmUpPVwib25EaW1EcmFnTGVhdmUoJGV2ZW50KVwiIChkcmFnRHJvcCk9XCJvbkRpbURyb3AoJGV2ZW50LCBmaWx0ZXJBcmVhLCAyKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtb3ZlU3RhcnQpPSdvbkRpbURyYWdTdGFydCgkZXZlbnQsIGZpbHRlckFyZWEpJyAobW92ZUVuZCk9J29uRGltRHJhZ0VuZCgpJz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uIGlneFByZWZpeCAocG9pbnRlcmRvd24pPSdvbkZpbHRlcmluZ0ljb25Qb2ludGVyRG93bigkZXZlbnQpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT0nb25GaWx0ZXJpbmdJY29uQ2xpY2soJGV2ZW50LCBmaWx0ZXIpJz5maWx0ZXJfbGlzdDwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7ZmlsdGVyLm1lbWJlck5hbWV9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj0nbGFzdCc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gW3N0eWxlLnZpc2liaWxpdHldPSdcImhpZGRlblwiJyBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC0tY2hpcF9kcm9wX2luZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2dldEFyZWFIZWlnaHQoZmlsdGVyQXJlYSknPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIGlneERyb3AgKGRyYWdEcm9wKT1cIm9uRGltRHJvcCgkZXZlbnQsIGZpbHRlckFyZWEsIDIpXCIgI25vdGlmeUNoaXAgW2hpZGRlbl09J3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc3BsYXlEZW5zaXR5XT1cImdyaWQuZGlzcGxheURlbnNpdHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2dyaWQucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Bpdm90X2ZpbHRlcl9kcm9wX2NoaXB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcHMtYXJlYT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19waXZvdC1maWx0ZXItdG9nZ2xlXCIgKm5nSWY9XCJpc0ZpbHRlcnNCdXR0b24gJiYgZ3JpZC5maWx0ZXJEaW1lbnNpb25zLmxlbmd0aCAhPT0gMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uICNmaWx0ZXJJY29uIChwb2ludGVyZG93bik9J29uRmlsdGVyaW5nSWNvblBvaW50ZXJEb3duKCRldmVudCknIChjbGljayk9J29uRmlsdGVyc0FyZWFEcm9wZG93bkNsaWNrKCRldmVudCknPmZpbHRlcl9saXN0PC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtYmFkZ2UgdmFsdWU9XCJ7e3RoaXMuZmlsdGVyRHJvcGRvd25EaW1lbnNpb25zLnNpemV9fVwiPjwvaWd4LWJhZGdlPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdpZ3gtZ3JpZF9fdHItcGl2b3QtLWRyb3Atcm93LWFyZWEnIChpZ3hEcmFnTGVhdmUpPVwib25BcmVhRHJhZ0xlYXZlKCRldmVudCwgcm93QXJlYSlcIiBpZ3hEcm9wXG4gICAgICAgICAgICAgICAgICAgICAoZHJvcHBlZCk9XCJvbkRpbURyb3AoJGV2ZW50LCByb3dBcmVhLCAwKVwiPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICA8ZGl2ICNwaXZvdENvbHVtbkNvbnRhaW5lciAqbmdJZj1cImdyaWQuc2hvd1Bpdm90Q29uZmlndXJhdGlvblVJXCIgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3RcIlxuICAgICAgICAgICAgICAgICAgICAgKGRyb3BwZWQpPVwib25EaW1Ecm9wKCRldmVudCwgY29sQXJlYSwgMSlcIiBpZ3hEcm9wIChpZ3hEcmFnTGVhdmUpPVwib25BcmVhRHJhZ0xlYXZlKCRldmVudCwgY29sQXJlYSlcIj5cbiAgICAgICAgICAgICAgICAgICAgPCEtLSBDb2x1bW5zIGFyZWEgLS0+XG4gICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcHMtYXJlYSAjY29sQXJlYSBkcm9wcGFibGU9J3RydWUnPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0nZW1wdHknIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIGNvbEFyZWEsIDEpXCIgaWd4RHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJncmlkLmNvbHVtbkRpbWVuc2lvbnMubGVuZ3RoID09PSAwXCIgY2xhc3M9J2lneC1ncmlkX19waXZvdC1lbXB0eS1jaGlwLWFyZWEnPlxuICAgICAgICAgICAgICAgICAgICAgICAge3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF9lbXB0eV9jb2x1bW5fZHJvcF9hcmVhfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBjb2wgb2YgZ3JpZC5jb2x1bW5EaW1lbnNpb25zOyBsZXQgbGFzdCA9IGxhc3Q7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBbc3R5bGUudmlzaWJpbGl0eV09J1wiaGlkZGVuXCInIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90LS1jaGlwX2Ryb3BfaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPSdnZXRBcmVhSGVpZ2h0KGNvbEFyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIFtkcmFnZ2FibGVdPVwidHJ1ZVwiIFtpZF09XCJjb2wubWVtYmVyTmFtZVwiIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCIgW2RhdGFdPVwieyBwaXZvdEFyZWE6ICdjb2x1bW4nIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcmVtb3ZhYmxlXT1cInRydWVcIiAocmVtb3ZlKT1cImNvbHVtblJlbW92ZWQoJGV2ZW50KVwiIChkcmFnT3Zlcik9XCJvbkRpbURyYWdPdmVyKCRldmVudCwgMSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZHJhZ0xlYXZlKT1cIm9uRGltRHJhZ0xlYXZlKCRldmVudClcIiAoZHJhZ0Ryb3ApPVwib25EaW1Ecm9wKCRldmVudCwgY29sQXJlYSwgMSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobW92ZVN0YXJ0KT0nb25EaW1EcmFnU3RhcnQoJGV2ZW50LCBjb2xBcmVhKScgKG1vdmVFbmQpPSdvbkRpbURyYWdFbmQoKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cIm9uQ2hpcFNvcnQoJGV2ZW50LCBjb2wpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXg+dmlld19jb2x1bW48L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb24gaWd4UHJlZml4IChwb2ludGVyZG93bik9J29uRmlsdGVyaW5nSWNvblBvaW50ZXJEb3duKCRldmVudCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPSdvbkZpbHRlcmluZ0ljb25DbGljaygkZXZlbnQsIGNvbCknPmZpbHRlcl9saXN0PC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3tjb2wubWVtYmVyTmFtZX19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiAqbmdJZj1cImNvbC5zb3J0RGlyZWN0aW9uXCIgaWd4U3VmZml4PiB7eyBjb2wuc29ydERpcmVjdGlvbiA8IDIgPyAnYXJyb3dfdXB3YXJkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnYXJyb3dfZG93bndhcmQnIH19PC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9J2xhc3QnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIFtzdHlsZS52aXNpYmlsaXR5XT0nXCJoaWRkZW5cIicgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtLWNoaXBfZHJvcF9pbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPSdnZXRBcmVhSGVpZ2h0KGNvbEFyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCBpZ3hEcm9wIChkcmFnRHJvcCk9XCJvbkRpbURyb3AoJGV2ZW50LCBjb2xBcmVhLCAxKVwiICNub3RpZnlDaGlwIFtoaWRkZW5dPSd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF9jb2x1bW5fZHJvcF9jaGlwfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXBzLWFyZWE+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2ICNwaXZvdFZhbHVlQ29udGFpbmVyICpuZ0lmPVwiZ3JpZC5zaG93UGl2b3RDb25maWd1cmF0aW9uVUlcIiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdFwiXG4gICAgICAgICAgICAgICAgICAgICAocG9pbnRlcmRvd24pPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIiAoZHJvcHBlZCk9XCJvblZhbHVlRHJvcCgkZXZlbnQsIHZhbHVlQXJlYSlcIiBpZ3hEcm9wXG4gICAgICAgICAgICAgICAgICAgICAoaWd4RHJhZ0xlYXZlKT1cIm9uQXJlYURyYWdMZWF2ZSgkZXZlbnQsIHZhbHVlQXJlYSlcIj5cbiAgICAgICAgICAgICAgICAgICAgPCEtLSBWYWx1ZSBhcmVhIC0tPlxuICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXBzLWFyZWEgI3ZhbHVlQXJlYSBkcm9wcGFibGU9J3RydWUnPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0nZW1wdHknIChkcm9wcGVkKT1cIm9uVmFsdWVEcm9wKCRldmVudCwgdmFsdWVBcmVhKVwiIGlneERyb3AgKm5nSWY9XCJncmlkLnZhbHVlcy5sZW5ndGggPT09IDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9J2lneC1ncmlkX19waXZvdC1lbXB0eS1jaGlwLWFyZWEnPnt7Z3JpZC5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcGl2b3RfZW1wdHlfdmFsdWVfZHJvcF9hcmVhfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHZhbHVlIG9mIGdyaWQudmFsdWVzOyBsZXQgbGFzdCA9IGxhc3Q7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBbc3R5bGUudmlzaWJpbGl0eV09J1wiaGlkZGVuXCInIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90LS1jaGlwX2Ryb3BfaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPSdnZXRBcmVhSGVpZ2h0KHZhbHVlQXJlYSknPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXAgI2N1cnJDaGlwIFtkcmFnZ2FibGVdPVwidHJ1ZVwiIFtpZF09XCJ2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5tZW1iZXJcIiBbZGF0YV09XCJ7IHBpdm90QXJlYTogJ3ZhbHVlJyB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc3BsYXlEZW5zaXR5XT1cImdyaWQuZGlzcGxheURlbnNpdHlcIiBbcmVtb3ZhYmxlXT1cInRydWVcIiAocmVtb3ZlKT1cInZhbHVlUmVtb3ZlZCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRyYWdMZWF2ZSk9XCJvbkRpbURyYWdMZWF2ZSgkZXZlbnQpXCIgKGRyYWdPdmVyKT1cIm9uRGltRHJhZ092ZXIoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkcmFnRHJvcCk9XCJvblZhbHVlRHJvcCgkZXZlbnQsIHZhbHVlQXJlYSlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC10b2dnbGUtaWNvbnNcIiBpZ3hQcmVmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPSdvblN1bW1hcnlDbGljaygkZXZlbnQsIHZhbHVlLCBkcm9wZG93biwgY3VyckNoaXApJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwb2ludGVyZG93bik9JyRldmVudC5zdG9wUHJvcGFnYXRpb24oKScgW2lneERyb3BEb3duSXRlbU5hdmlnYXRpb25dPVwiZHJvcGRvd25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbj5mdW5jdGlvbnM8L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uPmFycm93X2Ryb3BfZG93bjwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZ3JpZC52YWx1ZUNoaXBUZW1wbGF0ZSA/IGdyaWQudmFsdWVDaGlwVGVtcGxhdGUgOiB2YWx1ZUNoaXBEZWZhdWx0VGVtcGxhdGU7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiB2YWx1ZSB9XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPSdsYXN0Jz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBbc3R5bGUudmlzaWJpbGl0eV09J1wiaGlkZGVuXCInIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90LS1jaGlwX2Ryb3BfaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0nZ2V0QXJlYUhlaWdodCh2YWx1ZUFyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCBpZ3hEcm9wIChkcmFnRHJvcCk9XCJvblZhbHVlRHJvcCgkZXZlbnQsIHZhbHVlQXJlYSlcIiAjbm90aWZ5VmFsdWVDaGlwIFtoaWRkZW5dPSd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF92YWx1ZV9kcm9wX2NoaXB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcHMtYXJlYT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IHJvbGU9XCJyb3dncm91cFwiIGNsYXNzPVwiaWd4LWdyaWQtdGhlYWRfX3dyYXBwZXJcIiBbc3R5bGUud2lkdGgucHhdPVwid2lkdGhcIlxuICAgICAgICAgW2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50XT1cImFjdGl2ZURlc2NlbmRhbnRcIiBbY2xhc3MuaWd4LWdyaWRfX3RyLS1tcmxdPVwiaGFzTVJMXCI+XG5cbiAgICAgICAgPCEtLSBDb2x1bW4gaGVhZGVycyBhcmVhIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3RyXCIgcm9sZT1cInJvd1wiIFtzdHlsZS53aWR0aC5weF09XCJ3aWR0aFwiPlxuICAgICAgICAgICAgPGRpdiAjcGl2b3RDb250YWluZXIgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QgaWd4LWdyaWRfX3RyLXBpdm90LS1yb3ctYXJlYVwiXG4gICAgICAgICAgICAgICAgIFtzdHlsZS53aWR0aC5weF09XCJncmlkLnBpdm90Um93V2lkdGhzIC0gMVwiIChpZ3hEcmFnTGVhdmUpPVwib25BcmVhRHJhZ0xlYXZlKCRldmVudCwgcm93QXJlYSlcIiBpZ3hEcm9wXG4gICAgICAgICAgICAgICAgIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIHJvd0FyZWEsIDApXCIgKHBvaW50ZXJkb3duKT1cIiRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG4gICAgICAgICAgICAgICAgPCEtLSBSb3cgYXJlYSAtLT5cbiAgICAgICAgICAgICAgICA8aWd4LWNoaXBzLWFyZWEgI3Jvd0FyZWEgZHJvcHBhYmxlPSd0cnVlJz5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImdyaWQuc2hvd1Bpdm90Q29uZmlndXJhdGlvblVJXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSdlbXB0eScgaWd4RHJvcCAoZHJvcHBlZCk9XCJvbkRpbURyb3AoJGV2ZW50LCByb3dBcmVhLCAwKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImdyaWQucm93RGltZW5zaW9ucy5sZW5ndGggPT09IDAgJiYgZ3JpZC5zaG93UGl2b3RDb25maWd1cmF0aW9uVUlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9J2lneC1ncmlkX19waXZvdC1lbXB0eS1jaGlwLWFyZWEnPnt7Z3JpZC5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcGl2b3RfZW1wdHlfcm93X2Ryb3BfYXJlYX19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCByb3cgb2YgZ3JpZC5yb3dEaW1lbnNpb25zOyBsZXQgbGFzdCA9IGxhc3Q7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBbc3R5bGUudmlzaWJpbGl0eV09J1wiaGlkZGVuXCInIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90LS1jaGlwX2Ryb3BfaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPSdnZXRBcmVhSGVpZ2h0KHJvd0FyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIFtkcmFnZ2FibGVdPVwidHJ1ZVwiIFtpZF09XCJyb3cubWVtYmVyTmFtZVwiIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCIgW2RhdGFdPVwieyBwaXZvdEFyZWE6ICdyb3cnIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcmVtb3ZhYmxlXT1cInRydWVcIiAocmVtb3ZlKT1cInJvd1JlbW92ZWQoJGV2ZW50KVwiIChkcmFnTGVhdmUpPVwib25EaW1EcmFnTGVhdmUoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkcmFnRHJvcCk9XCJvbkRpbURyb3AoJGV2ZW50LCByb3dBcmVhLCAwKVwiIChkcmFnT3Zlcik9XCJvbkRpbURyYWdPdmVyKCRldmVudCwgMClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobW92ZVN0YXJ0KT0nb25EaW1EcmFnU3RhcnQoJGV2ZW50LCByb3dBcmVhKScgKG1vdmVFbmQpPSdvbkRpbURyYWdFbmQoKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cIm9uQ2hpcFNvcnQoJGV2ZW50LCByb3cpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXg+dGFibGVfcm93czwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXggKHBvaW50ZXJkb3duKT0nb25GaWx0ZXJpbmdJY29uUG9pbnRlckRvd24oJGV2ZW50KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9J29uRmlsdGVyaW5nSWNvbkNsaWNrKCRldmVudCwgcm93KSc+ZmlsdGVyX2xpc3Q8L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyByb3cubWVtYmVyTmFtZX19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiAqbmdJZj1cInJvdy5zb3J0RGlyZWN0aW9uXCIgaWd4U3VmZml4PiB7eyByb3cuc29ydERpcmVjdGlvbiA8IDIgPyAnYXJyb3dfdXB3YXJkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnYXJyb3dfZG93bndhcmQnIH19PC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9J2xhc3QnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIFtzdHlsZS52aXNpYmlsaXR5XT0nXCJoaWRkZW5cIicgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtLWNoaXBfZHJvcF9pbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPSdnZXRBcmVhSGVpZ2h0KHJvd0FyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCBpZ3hEcm9wIChkcmFnRHJvcCk9XCJvbkRpbURyb3AoJGV2ZW50LCByb3dBcmVhLCAwKVwiICNub3RpZnlDaGlwIFtoaWRkZW5dPSd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF9yb3dfZHJvcF9jaGlwfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvaWd4LWNoaXBzLWFyZWE+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPCEtLSBQaW5uZWQgY29sdW1ucyBjb2xsZWN0aW9uIGZyb20gdGhlIHN0YXJ0IC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInBpbm5lZENvbHVtbkNvbGxlY3Rpb24ubGVuZ3RoICYmIGdyaWQuaXNQaW5uaW5nVG9TdGFydFwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBwaW5uZWRDb2x1bW5Db2xsZWN0aW9uIHwgaWd4VG9wTGV2ZWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlneC1ncmlkLWhlYWRlci1ncm91cCBbbmdDbGFzc109XCJjb2x1bW4uaGVhZGVyR3JvdXBDbGFzc2VzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdTdHlsZV09XCJjb2x1bW4uaGVhZGVyR3JvdXBTdHlsZXMgfCBpZ3hIZWFkZXJHcm91cFN0eWxlOmNvbHVtbjpncmlkLnBpcGVUcmlnZ2VyXCIgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5taW4td2lkdGhdPVwiY29sdW1uLmNhbGNXaWR0aCB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5mbGV4LWJhc2lzXT1cImNvbHVtbi5jYWxjV2lkdGggfCBpZ3hIZWFkZXJHcm91cFdpZHRoOmdyaWQuZGVmYXVsdEhlYWRlckdyb3VwTWluV2lkdGg6aGFzTVJMXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocG9pbnRlcmRvd24pPVwiZ3JpZC5uYXZpZ2F0aW9uLmZvY3VzT3V0Um93SGVhZGVyKCRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgPC9pZ3gtZ3JpZC1oZWFkZXItZ3JvdXA+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZC10aGVhZC0tdmlydHVhbGl6YXRpb25XcmFwcGVyXCIgW3N0eWxlLm1heC1oZWlnaHQucHhdPSdtYXhDb250YWluZXJIZWlnaHQnPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZC10aGVhZF9fZ3JvdXAgaWd4LWdyaWQtdGhlYWQtLXZpcnR1YWxpemF0aW9uQ29udGFpbmVyXCIgW3N0eWxlLmhlaWdodC5weF09J3RvdGFsRGVwdGggPiAxID8gZ3JpZC5yb3dIZWlnaHQgOiB1bmRlZmluZWQnICpuZ0Zvcj0nbGV0IGRpbUxldmVsQ29sdW1ucyBvZiBjb2x1bW5EaW1lbnNpb25zQnlMZXZlbDsgbGV0IGkgPSBpbmRleCcgW3N0eWxlLndpZHRoLnB4XT0nZ3JpZC51bnBpbm5lZFdpZHRoJz5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGlneEdyaWRGb3IgI2hlYWRlclZpcnR1YWxDb250YWluZXIgbGV0LWNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2lneEdyaWRGb3JPZl09XCJkaW1MZXZlbENvbHVtbnNcIiBbaWd4R3JpZEZvck9mVW5pcXVlU2l6ZUNhY2hlXSA9ICd0cnVlJyBbaWd4Rm9yU2Nyb2xsQ29udGFpbmVyXT1cImdyaWQucGFyZW50VmlydERpclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09XCJncmlkLnVucGlubmVkV2lkdGhcIiBbaWd4Rm9yVHJhY2tCeV09XCJncmlkLnRyYWNrQ29sdW1uQ2hhbmdlc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWd4Rm9yU2l6ZVByb3BOYW1lXT1cIidjYWxjUGl4ZWxXaWR0aCdcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWdyaWQtaGVhZGVyLWdyb3VwIFtuZ0NsYXNzXT1cImNvbHVtbi5oZWFkZXJHcm91cENsYXNzZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0ndG90YWxEZXB0aCA+IDEgPyBjYWxjSGVpZ2h0KGNvbHVtbiwgaSkgOiB1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cImNvbHVtbi5oZWFkZXJHcm91cFN0eWxlcyB8aWd4SGVhZGVyR3JvdXBTdHlsZTpjb2x1bW46Z3JpZC5waXBlVHJpZ2dlclwiIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLm1pbi13aWR0aF09XCJjb2x1bW4uY2FsY1dpZHRoIHwgaWd4SGVhZGVyR3JvdXBXaWR0aDpncmlkLmRlZmF1bHRIZWFkZXJHcm91cE1pbldpZHRoOmhhc01STFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5mbGV4LWJhc2lzXT1cImNvbHVtbi5jYWxjV2lkdGggfCBpZ3hIZWFkZXJHcm91cFdpZHRoOmdyaWQuZGVmYXVsdEhlYWRlckdyb3VwTWluV2lkdGg6aGFzTVJMXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmlneC1ncmlkX190ci1waXZvdC0tY29sdW1uRGltZW5zaW9uTGVhZl0gPSAnaXNEdXBsaWNhdGVPZkV4aXN0aW5nUGFyZW50KGNvbHVtbiwgaSknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy5pZ3gtZ3JpZF9fdHItcGl2b3QtLWNvbHVtbk11bHRpUm93U3Bhbl0gPSAnaXNNdWx0aVJvdyhjb2x1bW4sIGkpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtZ3JpZC1oZWFkZXItZ3JvdXA+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPCEtLSBQaW5uZWQgY29sdW1ucyBjb2xsZWN0aW9uIGF0IHRoZSBlbmQgLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwicGlubmVkQ29sdW1uQ29sbGVjdGlvbi5sZW5ndGggJiYgIWdyaWQuaXNQaW5uaW5nVG9TdGFydFwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBwaW5uZWRDb2x1bW5Db2xsZWN0aW9uIHwgaWd4VG9wTGV2ZWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlneC1ncmlkLWhlYWRlci1ncm91cCBbbmdDbGFzc109XCJjb2x1bW4uaGVhZGVyR3JvdXBDbGFzc2VzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdTdHlsZV09XCJjb2x1bW4uaGVhZGVyR3JvdXBTdHlsZXMgfGlneEhlYWRlckdyb3VwU3R5bGU6Y29sdW1uOmdyaWQucGlwZVRyaWdnZXJcIiBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLm1pbi13aWR0aF09XCJjb2x1bW4uY2FsY1dpZHRoIHwgaWd4SGVhZGVyR3JvdXBXaWR0aDpncmlkLmRlZmF1bHRIZWFkZXJHcm91cE1pbldpZHRoOmhhc01STFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmZsZXgtYmFzaXNdPVwiY29sdW1uLmNhbGNXaWR0aCB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5sZWZ0XT1cImNvbHVtbi5yaWdodFBpbm5lZE9mZnNldFwiIChwb2ludGVyZG93bik9XCJncmlkLm5hdmlnYXRpb24uZm9jdXNPdXRSb3dIZWFkZXIoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgICAgICA8L2lneC1ncmlkLWhlYWRlci1ncm91cD5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPCEtLSBIZWFkZXIgdGh1bWIgYXJlYSAtLT5cbjxkaXYgY2xhc3M9XCJpZ3gtZ3JpZC10aGVhZF9fdGh1bWJcIiBbaGlkZGVuXT1cIiFncmlkLmhhc1ZlcnRpY2FsU2Nyb2xsKClcIiBbc3R5bGUud2lkdGgucHhdPVwiZ3JpZC5zY3JvbGxTaXplXCI+XG48L2Rpdj5cblxuPGlneC1kcm9wLWRvd24gI2Ryb3Bkb3duIChzZWxlY3Rpb25DaGFuZ2luZyk9J29uQWdncmVnYXRpb25DaGFuZ2UoJGV2ZW50KSc+XG4gICAgPGlneC1kcm9wLWRvd24taXRlbSAqbmdGb3I9XCJsZXQgaXRlbSBvZiBhZ2dyZWdhdGVMaXN0XCIgW3NlbGVjdGVkXT0naXNTZWxlY3RlZChpdGVtKScgW3ZhbHVlXT0naXRlbSc+XG4gICAgICAgIHt7IGl0ZW0ubGFiZWwgfX1cbiAgICA8L2lneC1kcm9wLWRvd24taXRlbT5cbjwvaWd4LWRyb3AtZG93bj5cblxuPGRpdiBbaGlkZGVuXT0ndHJ1ZSc+XG4gICAgPGlneC1ncmlkLWV4Y2VsLXN0eWxlLWZpbHRlcmluZyBbbWF4SGVpZ2h0XT0nZ3JpZC5leGNlbFN0eWxlRmlsdGVyTWF4SGVpZ2h0JyBbbWluSGVpZ2h0XT0nZ3JpZC5leGNlbFN0eWxlRmlsdGVyTWluSGVpZ2h0JyAjZXNmPlxuICAgICAgICA8ZGl2IGlneEV4Y2VsU3R5bGVDb2x1bW5PcGVyYXRpb25zPlxuICAgICAgICAgICAgPGlneC1jaGlwcy1hcmVhICNkcm9wZG93bkNoaXBzPlxuICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCAqbmdGb3I9XCJsZXQgZmlsdGVyIG9mIHRoaXMuZmlsdGVyRHJvcGRvd25EaW1lbnNpb25zXCIgW2lkXT1cImZpbHRlci5tZW1iZXJOYW1lXCJcbiAgICAgICAgICAgICAgICBbZGlzcGxheURlbnNpdHldPVwiZ3JpZC5kaXNwbGF5RGVuc2l0eVwiIFtyZW1vdmFibGVdPVwidHJ1ZVwiIChyZW1vdmUpPVwiZmlsdGVyUmVtb3ZlZCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAoY2hpcENsaWNrKT0nb25GaWx0ZXJzU2VsZWN0aW9uQ2hhbmdlZCgkZXZlbnQpJyBbc2VsZWN0YWJsZV09J3RydWUnIFtzZWxlY3RlZF09J2ZpbHRlciA9PT0gdGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnMudmFsdWVzKCkubmV4dCgpLnZhbHVlJz5cbiAgICAgICAgICAgICAgICB7e2ZpbHRlci5tZW1iZXJOYW1lfX1cbiAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgIDwvaWd4LWNoaXBzLWFyZWE+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aWd4LWV4Y2VsLXN0eWxlLWZpbHRlci1vcGVyYXRpb25zPlxuICAgICAgICAgICAgPGlneC1leGNlbC1zdHlsZS1zZWFyY2g+PC9pZ3gtZXhjZWwtc3R5bGUtc2VhcmNoPlxuICAgICAgICA8L2lneC1leGNlbC1zdHlsZS1maWx0ZXItb3BlcmF0aW9ucz5cbiAgICA8L2lneC1ncmlkLWV4Y2VsLXN0eWxlLWZpbHRlcmluZz5cbjwvZGl2PlxuXG48ZGl2IHN0eWxlPVwidmlzaWJpbGl0eTogaGlkZGVuOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMDAwcHhcIj5cbiAgICA8aWd4LWNoaXBzLWFyZWEgI2ZpbHRlckFyZWFIaWRkZW4gZHJvcHBhYmxlPSd0cnVlJz5cbiAgICAgICAgPGlneC1jaGlwICpuZ0Zvcj1cImxldCBmaWx0ZXIgb2YgZ3JpZC5maWx0ZXJEaW1lbnNpb25zXCIgW2lkXT1cImZpbHRlci5tZW1iZXJOYW1lXCIgW2RyYWdnYWJsZV09XCJ0cnVlXCJcbiAgICAgICAgICAgIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCIgW3JlbW92YWJsZV09XCJ0cnVlXCIgKHJlbW92ZSk9XCJmaWx0ZXJSZW1vdmVkKCRldmVudClcIj5cbiAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXg+ZmlsdGVyX2xpc3Q8L2lneC1pY29uPlxuICAgICAgICAgICAge3tmaWx0ZXIubWVtYmVyTmFtZX19XG4gICAgICAgIDwvaWd4LWNoaXA+XG4gICAgPC9pZ3gtY2hpcHMtYXJlYT5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgI3ZhbHVlQ2hpcERlZmF1bHRUZW1wbGF0ZSBsZXQtdmFsdWU+XG4gICAge3t2YWx1ZS5hZ2dyZWdhdGUua2V5fX0oe3t2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5tZW1iZXJ9fSlcbjwvbmctdGVtcGxhdGU+XG4iXX0=