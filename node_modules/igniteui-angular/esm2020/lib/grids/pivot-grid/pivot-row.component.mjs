import { ChangeDetectionStrategy, Component, forwardRef, HostBinding, Inject, Input } from '@angular/core';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { IgxRowDirective } from '../row.directive';
import { PivotUtil } from './pivot-util';
import * as i0 from "@angular/core";
import * as i1 from "../selection/selection.service";
import * as i2 from "../cell.component";
import * as i3 from "@angular/common";
import * as i4 from "../../directives/for-of/for_of.directive";
import * as i5 from "../../checkbox/checkbox.component";
import * as i6 from "../common/pipes";
import * as i7 from "./pivot-grid.pipes";
const MINIMUM_COLUMN_WIDTH = 200;
export class IgxPivotRowComponent extends IgxRowDirective {
    constructor(grid, selectionService, element, cdr, resolver, viewRef) {
        super(grid, selectionService, element, cdr);
        this.grid = grid;
        this.selectionService = selectionService;
        this.element = element;
        this.cdr = cdr;
        this.resolver = resolver;
        this.viewRef = viewRef;
        /**
         * @hidden
         * @internal
         */
        this.disabled = false;
    }
    /**
     * @hidden
     */
    get selected() {
        let isSelected = false;
        for (let rowDim of this.data.dimensions) {
            const key = PivotUtil.getRecordKey(this.data, rowDim);
            if (this.selectionService.isPivotRowSelected(key)) {
                isSelected = true;
            }
        }
        return isSelected;
    }
    /**
     * @hidden
     * @internal
     */
    get viewIndex() {
        return this.index;
    }
    /**
     * @hidden
     * @internal
     */
    get addRowUI() {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    get inEditMode() {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    set pinned(_value) {
    }
    get pinned() {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    delete() {
    }
    /**
     * @hidden
     * @internal
     */
    beginAddRow() {
    }
    /**
     * @hidden
     * @internal
     */
    update(_value) {
    }
    /**
     * @hidden
     * @internal
     */
    pin() {
        return false;
    }
    /**
    * @hidden
    * @internal
    */
    unpin() {
        return false;
    }
    /**
    *  The pivot record data passed to the row component.
    *
    * ```typescript
    * // get the pivot row data for the first selected row
    * let selectedRowData = this.grid.selectedRows[0].data;
    * ```
    */
    get data() {
        return this._data;
    }
    set data(v) {
        this._data = v;
    }
    /**
     * @hidden
     * @internal
     */
    get pivotAggregationData() {
        const aggregations = this.data.aggregationValues;
        const obj = {};
        aggregations.forEach((value, key) => {
            obj[key] = value;
        });
        return obj;
    }
    getCellClass(col) {
        const values = this.grid.values;
        if (values.length === 1) {
            return values[0].styles;
        }
        const colName = col.field.split(this.grid.pivotKeys.columnDimensionSeparator);
        const measureName = colName[colName.length - 1];
        return values.find(v => v.member === measureName)?.styles;
    }
    isCellActive(visibleColumnIndex) {
        const nav = this.grid.navigation;
        const node = nav.activeNode;
        return node && Object.keys(node).length !== 0 ?
            !nav.isRowHeaderActive &&
                super.isCellActive(visibleColumnIndex) :
            false;
    }
    getColumnData(col) {
        const path = col.field.split(this.grid.pivotKeys.columnDimensionSeparator);
        const keyValueMap = new Map();
        const colDimensions = PivotUtil.flatten(this.grid.columnDimensions);
        for (const dim of colDimensions) {
            keyValueMap.set(dim.memberName, path.shift());
        }
        let pivotValue;
        if (this.grid.hasMultipleValues) {
            pivotValue = this.grid.values.find(x => x.member === path.shift());
        }
        else {
            pivotValue = this.grid.values ? this.grid.values[0] : undefined;
        }
        return {
            field: col.field,
            dimensions: this.grid.columnDimensions,
            dimensionValues: keyValueMap,
            value: pivotValue
        };
    }
}
IgxPivotRowComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: IgxPivotRowComponent, deps: [{ token: IGX_GRID_BASE }, { token: i1.IgxGridSelectionService }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.ComponentFactoryResolver }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component });
IgxPivotRowComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.0", type: IgxPivotRowComponent, selector: "igx-pivot-row", inputs: { selected: "selected", data: "data" }, host: { properties: { "attr.aria-selected": "this.selected" } }, providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxPivotRowComponent) }], usesInheritance: true, ngImport: i0, template: "<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\"\n    [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"'\n    [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth'\n    [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-grid-cell #cell class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"key | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.gridAPI.crudService.cell:grid.gridAPI.crudService.row\"\n\n        [class.igx-grid__td--number]=\"col.dataType === 'number' || col.dataType === 'percent' || col.dataType === 'currency'\"\n        [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n        [ngClass]=\"this.getCellClass(col) | igxPivotCellStyleClasses:data[col.field]:data:getColumnData(col):viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:pivotAggregationData[col.field]:pivotAggregationData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && this.grid.crudService.targetInEdit(index, col.index)\" [column]=\"col\"\n        [formatter]=\"col.formatter\" [intRow]=\"this\" [active]=\"isCellActive(col.visibleIndex)\"\n        [style.min-height.px]=\"cellHeight\" [rowData]=\"data\" [columnData]='getColumnData(col)'\n        [style.min-width]=\"col.width\" [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\" [width]=\"col.getCellWidth()\" [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"pivotAggregationData[col.field] | dataMapper:col.field:grid.pipeTrigger:pivotAggregationData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\" [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\" [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox [tabindex]=\"-1\" [readonly]=\"true\" [checked]=\"selected\" [disableRipple]=\"true\" [disabled]=\"deleted\"\n            [disableTransitions]=\"grid.disableTransitions\" [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n", dependencies: [{ kind: "component", type: i2.IgxGridCellComponent, selector: "igx-grid-cell", inputs: ["column", "intRow", "row", "rowData", "columnData", "cellTemplate", "cellValidationErrorTemplate", "pinnedIndicator", "value", "formatter", "visibleColumnIndex", "cellSelectionMode", "lastSearchInfo", "lastPinned", "firstPinned", "editMode", "width", "active", "displayPinnedChip"] }, { kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i4.IgxGridForOfDirective, selector: "[igxGridFor][igxGridForOf]", inputs: ["igxGridForOf", "igxGridForOfUniqueSizeCache", "igxGridForOfVariableSizes"], outputs: ["dataChanging"] }, { kind: "component", type: i5.IgxCheckboxComponent, selector: "igx-checkbox", inputs: ["id", "labelId", "value", "name", "tabindex", "labelPosition", "disableRipple", "required", "aria-labelledby", "aria-label", "indeterminate", "checked", "disabled", "readonly", "disableTransitions"], outputs: ["change"] }, { kind: "pipe", type: i6.IgxGridNotGroupedPipe, name: "igxNotGrouped" }, { kind: "pipe", type: i6.IgxGridCellStylesPipe, name: "igxCellStyles" }, { kind: "pipe", type: i6.IgxGridDataMapperPipe, name: "dataMapper" }, { kind: "pipe", type: i6.IgxGridTransactionStatePipe, name: "transactionState" }, { kind: "pipe", type: i7.IgxPivotGridCellStyleClassesPipe, name: "igxPivotCellStyleClasses" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: IgxPivotRowComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-pivot-row', providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxPivotRowComponent) }], template: "<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\"\n    [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"'\n    [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth'\n    [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-grid-cell #cell class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"key | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.gridAPI.crudService.cell:grid.gridAPI.crudService.row\"\n\n        [class.igx-grid__td--number]=\"col.dataType === 'number' || col.dataType === 'percent' || col.dataType === 'currency'\"\n        [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n        [ngClass]=\"this.getCellClass(col) | igxPivotCellStyleClasses:data[col.field]:data:getColumnData(col):viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:pivotAggregationData[col.field]:pivotAggregationData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && this.grid.crudService.targetInEdit(index, col.index)\" [column]=\"col\"\n        [formatter]=\"col.formatter\" [intRow]=\"this\" [active]=\"isCellActive(col.visibleIndex)\"\n        [style.min-height.px]=\"cellHeight\" [rowData]=\"data\" [columnData]='getColumnData(col)'\n        [style.min-width]=\"col.width\" [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\" [width]=\"col.getCellWidth()\" [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"pivotAggregationData[col.field] | dataMapper:col.field:grid.pipeTrigger:pivotAggregationData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\" [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\" [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox [tabindex]=\"-1\" [readonly]=\"true\" [checked]=\"selected\" [disableRipple]=\"true\" [disabled]=\"deleted\"\n            [disableTransitions]=\"grid.disableTransitions\" [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }, { type: i1.IgxGridSelectionService }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.ComponentFactoryResolver }, { type: i0.ViewContainerRef }]; }, propDecorators: { selected: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.aria-selected']
            }], data: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3Qtcm93LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LXJvdy5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvcGl2b3QtZ3JpZC9waXZvdC1yb3cuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILHVCQUF1QixFQUV2QixTQUFTLEVBR1QsVUFBVSxFQUNWLFdBQVcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUM3QixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsYUFBYSxFQUFpQixNQUFNLDBCQUEwQixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUduRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7Ozs7Ozs7QUFHekMsTUFBTSxvQkFBb0IsR0FBRyxHQUFHLENBQUM7QUFPakMsTUFBTSxPQUFPLG9CQUFxQixTQUFRLGVBQWU7SUFpQnJELFlBQ2tDLElBQW1CLEVBQzFDLGdCQUF5QyxFQUN6QyxPQUFnQyxFQUNoQyxHQUFzQixFQUNuQixRQUFrQyxFQUNsQyxPQUF5QjtRQUVuQyxLQUFLLENBQUMsSUFBSSxFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQztRQVBkLFNBQUksR0FBSixJQUFJLENBQWU7UUFDMUMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUF5QjtRQUN6QyxZQUFPLEdBQVAsT0FBTyxDQUF5QjtRQUNoQyxRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQUNuQixhQUFRLEdBQVIsUUFBUSxDQUEwQjtRQUNsQyxZQUFPLEdBQVAsT0FBTyxDQUFrQjtRQWF2Qzs7O1dB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LENBQUMsS0FBSztZQUNoQixVQUFVLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0I7WUFDdEMsZUFBZSxFQUFFLFdBQVc7WUFDNUIsS0FBSyxFQUFFLFVBQVU7U0FDcEIsQ0FBQztJQUNOLENBQUM7O2lIQTlLUSxvQkFBb0Isa0JBa0JqQixhQUFhO3FHQWxCaEIsb0JBQW9CLHlKQUZsQixDQUFDLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsQ0FBQyxpREN0QmxHLDYyRUErQkE7MkZEUGEsb0JBQW9CO2tCQU5oQyxTQUFTO3NDQUNXLHVCQUF1QixDQUFDLE1BQU0sWUFDckMsZUFBZSxhQUVkLENBQUMsRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLHFCQUFxQixDQUFDLEVBQUUsQ0FBQzs7MEJBb0J6RixNQUFNOzJCQUFDLGFBQWE7aU5BWmQsUUFBUTtzQkFGbEIsS0FBSzs7c0JBQ0wsV0FBVzt1QkFBQyxvQkFBb0I7Z0JBOEd0QixJQUFJO3NCQURkLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgRWxlbWVudFJlZixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEhvc3RCaW5kaW5nLCBJbmplY3QsIElucHV0LCBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4Q29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi4vY29sdW1ucy9jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7IElHWF9HUklEX0JBU0UsIFBpdm90R3JpZFR5cGUgfSBmcm9tICcuLi9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSWd4Um93RGlyZWN0aXZlIH0gZnJvbSAnLi4vcm93LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hHcmlkU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4uL3NlbGVjdGlvbi9zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJUGl2b3RHcmlkQ29sdW1uLCBJUGl2b3RHcmlkUmVjb3JkIH0gZnJvbSAnLi9waXZvdC1ncmlkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQaXZvdFV0aWwgfSBmcm9tICcuL3Bpdm90LXV0aWwnO1xuXG5cbmNvbnN0IE1JTklNVU1fQ09MVU1OX1dJRFRIID0gMjAwO1xuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgc2VsZWN0b3I6ICdpZ3gtcGl2b3Qtcm93JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vcGl2b3Qtcm93LmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IElneFJvd0RpcmVjdGl2ZSwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSWd4UGl2b3RSb3dDb21wb25lbnQpIH1dXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90Um93Q29tcG9uZW50IGV4dGVuZHMgSWd4Um93RGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1zZWxlY3RlZCcpXG4gICAgcHVibGljIGdldCBzZWxlY3RlZCgpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcm93RGltIG9mIHRoaXMuZGF0YS5kaW1lbnNpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBQaXZvdFV0aWwuZ2V0UmVjb3JkS2V5KHRoaXMuZGF0YSwgcm93RGltKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblNlcnZpY2UuaXNQaXZvdFJvd1NlbGVjdGVkKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTZWxlY3RlZDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChJR1hfR1JJRF9CQVNFKSBwdWJsaWMgZ3JpZDogUGl2b3RHcmlkVHlwZSxcbiAgICAgICAgcHVibGljIHNlbGVjdGlvblNlcnZpY2U6IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgIHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcm90ZWN0ZWQgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgcHJvdGVjdGVkIHZpZXdSZWY6IFZpZXdDb250YWluZXJSZWZcbiAgICApIHtcbiAgICAgICAgc3VwZXIoZ3JpZCwgc2VsZWN0aW9uU2VydmljZSwgZWxlbWVudCwgY2RyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCB2aWV3SW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYWRkUm93VUkoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGluRWRpdE1vZGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHNldCBwaW5uZWQoX3ZhbHVlOiBib29sZWFuKSB7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBwaW5uZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGRlbGV0ZSgpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGJlZ2luQWRkUm93KCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgdXBkYXRlKF92YWx1ZTogYW55KSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBwaW4oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIHVucGluKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiAgVGhlIHBpdm90IHJlY29yZCBkYXRhIHBhc3NlZCB0byB0aGUgcm93IGNvbXBvbmVudC5cbiAgICAqXG4gICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgKiAvLyBnZXQgdGhlIHBpdm90IHJvdyBkYXRhIGZvciB0aGUgZmlyc3Qgc2VsZWN0ZWQgcm93XG4gICAgKiBsZXQgc2VsZWN0ZWRSb3dEYXRhID0gdGhpcy5ncmlkLnNlbGVjdGVkUm93c1swXS5kYXRhO1xuICAgICogYGBgXG4gICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZGF0YSgpOiBJUGl2b3RHcmlkUmVjb3JkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBkYXRhKHY6IElQaXZvdEdyaWRSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcGl2b3RBZ2dyZWdhdGlvbkRhdGEoKSB7XG4gICAgICAgIGNvbnN0IGFnZ3JlZ2F0aW9ucyA9IHRoaXMuZGF0YS5hZ2dyZWdhdGlvblZhbHVlcztcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGFnZ3JlZ2F0aW9ucy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q2VsbENsYXNzKGNvbDogSWd4Q29sdW1uQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuZ3JpZC52YWx1ZXM7XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzWzBdLnN0eWxlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xOYW1lID0gY29sLmZpZWxkLnNwbGl0KHRoaXMuZ3JpZC5waXZvdEtleXMuY29sdW1uRGltZW5zaW9uU2VwYXJhdG9yKTtcbiAgICAgICAgY29uc3QgbWVhc3VyZU5hbWUgPSBjb2xOYW1lW2NvbE5hbWUubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB2YWx1ZXMuZmluZCh2ID0+IHYubWVtYmVyID09PSBtZWFzdXJlTmFtZSk/LnN0eWxlcztcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNDZWxsQWN0aXZlKHZpc2libGVDb2x1bW5JbmRleCkge1xuICAgICAgICBjb25zdCBuYXYgPSB0aGlzLmdyaWQubmF2aWdhdGlvblxuICAgICAgICBjb25zdCBub2RlID0gbmF2LmFjdGl2ZU5vZGU7XG4gICAgICAgIHJldHVybiBub2RlICYmIE9iamVjdC5rZXlzKG5vZGUpLmxlbmd0aCAhPT0gMCA/XG4gICAgICAgICAgICAhbmF2LmlzUm93SGVhZGVyQWN0aXZlICYmXG4gICAgICAgICAgICBzdXBlci5pc0NlbGxBY3RpdmUodmlzaWJsZUNvbHVtbkluZGV4KSA6XG4gICAgICAgICAgICBmYWxzZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q29sdW1uRGF0YShjb2w6IElneENvbHVtbkNvbXBvbmVudCkgOiBJUGl2b3RHcmlkQ29sdW1uIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGNvbC5maWVsZC5zcGxpdCh0aGlzLmdyaWQucGl2b3RLZXlzLmNvbHVtbkRpbWVuc2lvblNlcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IGtleVZhbHVlTWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICAgICAgY29uc3QgY29sRGltZW5zaW9ucyA9IFBpdm90VXRpbC5mbGF0dGVuKHRoaXMuZ3JpZC5jb2x1bW5EaW1lbnNpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBkaW0gb2YgY29sRGltZW5zaW9ucykge1xuICAgICAgICAgICAga2V5VmFsdWVNYXAuc2V0KGRpbS5tZW1iZXJOYW1lLCBwYXRoLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwaXZvdFZhbHVlO1xuICAgICAgICBpZiAodGhpcy5ncmlkLmhhc011bHRpcGxlVmFsdWVzKSB7XG4gICAgICAgICAgICBwaXZvdFZhbHVlID0gdGhpcy5ncmlkLnZhbHVlcy5maW5kKHggPT4geC5tZW1iZXIgPT09IHBhdGguc2hpZnQoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwaXZvdFZhbHVlID0gdGhpcy5ncmlkLnZhbHVlcyA/IHRoaXMuZ3JpZC52YWx1ZXNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkOiBjb2wuZmllbGQsXG4gICAgICAgICAgICBkaW1lbnNpb25zOiB0aGlzLmdyaWQuY29sdW1uRGltZW5zaW9ucyxcbiAgICAgICAgICAgIGRpbWVuc2lvblZhbHVlczoga2V5VmFsdWVNYXAsXG4gICAgICAgICAgICB2YWx1ZTogcGl2b3RWYWx1ZVxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsIjxuZy10ZW1wbGF0ZSBpZ3hHcmlkRm9yIGxldC1jb2wgW2lneEdyaWRGb3JPZl09XCJ1bnBpbm5lZENvbHVtbnMgfCBpZ3hOb3RHcm91cGVkXCJcbiAgICBbaWd4Rm9yU2Nyb2xsQ29udGFpbmVyXT1cImdyaWQucGFyZW50VmlydERpclwiIGxldC1jb2xJbmRleD1cImluZGV4XCIgW2lneEZvclNpemVQcm9wTmFtZV09J1wiY2FsY1BpeGVsV2lkdGhcIidcbiAgICBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCIgW2lneEZvckNvbnRhaW5lclNpemVdPSdncmlkLnVucGlubmVkV2lkdGgnXG4gICAgW2lneEZvclRyYWNrQnldPSdncmlkLnRyYWNrQ29sdW1uQ2hhbmdlcycgI2lneERpclJlZj5cbiAgICA8aWd4LWdyaWQtY2VsbCAjY2VsbCBjbGFzcz1cImlneC1ncmlkX190ZCBpZ3gtZ3JpZF9fdGQtLWZ3XCJcbiAgICAgICAgW2NsYXNzLmlneC1ncmlkX190ZC0tZWRpdGVkXT1cImtleSB8IHRyYW5zYWN0aW9uU3RhdGU6Y29sLmZpZWxkOmdyaWQucm93RWRpdGFibGU6Z3JpZC50cmFuc2FjdGlvbnM6Z3JpZC5waXBlVHJpZ2dlcjpncmlkLmdyaWRBUEkuY3J1ZFNlcnZpY2UuY2VsbDpncmlkLmdyaWRBUEkuY3J1ZFNlcnZpY2Uucm93XCJcblxuICAgICAgICBbY2xhc3MuaWd4LWdyaWRfX3RkLS1udW1iZXJdPVwiY29sLmRhdGFUeXBlID09PSAnbnVtYmVyJyB8fCBjb2wuZGF0YVR5cGUgPT09ICdwZXJjZW50JyB8fCBjb2wuZGF0YVR5cGUgPT09ICdjdXJyZW5jeSdcIlxuICAgICAgICBbY2xhc3MuaWd4LWdyaWRfX3RkLS1ib29sXT1cImNvbC5kYXRhVHlwZSA9PT0gJ2Jvb2xlYW4nXCJcbiAgICAgICAgW25nQ2xhc3NdPVwidGhpcy5nZXRDZWxsQ2xhc3MoY29sKSB8IGlneFBpdm90Q2VsbFN0eWxlQ2xhc3NlczpkYXRhW2NvbC5maWVsZF06ZGF0YTpnZXRDb2x1bW5EYXRhKGNvbCk6dmlld0luZGV4OmdyaWQucGlwZVRyaWdnZXJcIlxuICAgICAgICBbbmdTdHlsZV09XCJjb2wuY2VsbFN0eWxlcyB8IGlneENlbGxTdHlsZXM6cGl2b3RBZ2dyZWdhdGlvbkRhdGFbY29sLmZpZWxkXTpwaXZvdEFnZ3JlZ2F0aW9uRGF0YTpjb2wuZmllbGQ6dmlld0luZGV4OmdyaWQucGlwZVRyaWdnZXJcIlxuICAgICAgICBbZWRpdE1vZGVdPVwiY29sLmVkaXRhYmxlICYmIHRoaXMuZ3JpZC5jcnVkU2VydmljZS50YXJnZXRJbkVkaXQoaW5kZXgsIGNvbC5pbmRleClcIiBbY29sdW1uXT1cImNvbFwiXG4gICAgICAgIFtmb3JtYXR0ZXJdPVwiY29sLmZvcm1hdHRlclwiIFtpbnRSb3ddPVwidGhpc1wiIFthY3RpdmVdPVwiaXNDZWxsQWN0aXZlKGNvbC52aXNpYmxlSW5kZXgpXCJcbiAgICAgICAgW3N0eWxlLm1pbi1oZWlnaHQucHhdPVwiY2VsbEhlaWdodFwiIFtyb3dEYXRhXT1cImRhdGFcIiBbY29sdW1uRGF0YV09J2dldENvbHVtbkRhdGEoY29sKSdcbiAgICAgICAgW3N0eWxlLm1pbi13aWR0aF09XCJjb2wud2lkdGhcIiBbc3R5bGUubWF4LXdpZHRoXT1cImNvbC53aWR0aFwiXG4gICAgICAgIFtzdHlsZS5mbGV4LWJhc2lzXT1cImNvbC53aWR0aFwiIFt3aWR0aF09XCJjb2wuZ2V0Q2VsbFdpZHRoKClcIiBbdmlzaWJsZUNvbHVtbkluZGV4XT1cImNvbC52aXNpYmxlSW5kZXhcIlxuICAgICAgICBbdmFsdWVdPVwicGl2b3RBZ2dyZWdhdGlvbkRhdGFbY29sLmZpZWxkXSB8IGRhdGFNYXBwZXI6Y29sLmZpZWxkOmdyaWQucGlwZVRyaWdnZXI6cGl2b3RBZ2dyZWdhdGlvbkRhdGFbY29sLmZpZWxkXTpjb2wuaGFzTmVzdGVkUGF0aFwiXG4gICAgICAgIFtjZWxsVGVtcGxhdGVdPVwiY29sLmJvZHlUZW1wbGF0ZVwiIFtsYXN0U2VhcmNoSW5mb109XCJncmlkLmxhc3RTZWFyY2hJbmZvXCJcbiAgICAgICAgW2NlbGxTZWxlY3Rpb25Nb2RlXT1cImdyaWQuY2VsbFNlbGVjdGlvblwiIFtkaXNwbGF5UGlubmVkQ2hpcF09XCJzaG91bGREaXNwbGF5UGlubmVkQ2hpcChjb2wudmlzaWJsZUluZGV4KVwiXG4gICAgICAgIChwb2ludGVyZG93bik9XCJncmlkLm5hdmlnYXRpb24uZm9jdXNPdXRSb3dIZWFkZXIoJGV2ZW50KVwiPlxuICAgIDwvaWd4LWdyaWQtY2VsbD5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjcm93U2VsZWN0b3JCYXNlVGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19jYngtcGFkZGluZ1wiPlxuICAgICAgICA8aWd4LWNoZWNrYm94IFt0YWJpbmRleF09XCItMVwiIFtyZWFkb25seV09XCJ0cnVlXCIgW2NoZWNrZWRdPVwic2VsZWN0ZWRcIiBbZGlzYWJsZVJpcHBsZV09XCJ0cnVlXCIgW2Rpc2FibGVkXT1cImRlbGV0ZWRcIlxuICAgICAgICAgICAgW2Rpc2FibGVUcmFuc2l0aW9uc109XCJncmlkLmRpc2FibGVUcmFuc2l0aW9uc1wiIFthcmlhLWxhYmVsXT1cInJvd0NoZWNrYm94QXJpYUxhYmVsXCI+XG4gICAgICAgIDwvaWd4LWNoZWNrYm94PlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuIl19