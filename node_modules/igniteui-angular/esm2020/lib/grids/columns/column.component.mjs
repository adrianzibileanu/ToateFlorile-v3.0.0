import { __decorate } from "tslib";
import { Subject } from 'rxjs';
import { ChangeDetectionStrategy, Component, ContentChild, ContentChildren, Input, Output, EventEmitter, Inject, Optional, Self, } from '@angular/core';
import { notifyChanges } from '../watch-changes';
import { WatchColumnChanges } from '../watch-changes';
import { GridColumnDataType } from '../../data-operations/data-util';
import { IgxBooleanFilteringOperand, IgxNumberFilteringOperand, IgxDateFilteringOperand, IgxStringFilteringOperand, IgxDateTimeFilteringOperand, IgxTimeFilteringOperand } from '../../data-operations/filtering-condition';
import { DefaultSortingStrategy } from '../../data-operations/sorting-strategy';
import { DisplayDensity } from '../../core/displayDensity';
import { IgxRowDirective } from '../row.directive';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { IgxSummaryOperand, IgxNumberSummaryOperand, IgxDateSummaryOperand, IgxTimeSummaryOperand } from '../summaries/grid-summary';
import { IgxCellTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellEditorTemplateDirective, IgxCollapsibleIndicatorTemplateDirective, IgxFilterCellTemplateDirective, IgxSummaryTemplateDirective, IgxCellValidationErrorDirective } from './templates.directive';
import { DropPosition } from '../moving/moving.service';
import { isConstructor } from '../../core/utils';
import { IgxGridCell } from '../grid-public-cell';
import { NG_VALIDATORS } from '@angular/forms';
import * as i0 from "@angular/core";
import * as i1 from "../../core/utils";
const DEFAULT_DATE_FORMAT = 'mediumDate';
const DEFAULT_TIME_FORMAT = 'mediumTime';
const DEFAULT_DATE_TIME_FORMAT = 'medium';
const DEFAULT_DIGITS_INFO = '1.0-3';
/**
 * **Ignite UI for Angular Column** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid#columns-configuration)
 *
 * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
 * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
 * the column using `ng-template` which will be used for all cells within the column.
 */
export class IgxColumnComponent {
    constructor(grid, _validators, cdr, platform) {
        this.grid = grid;
        this._validators = _validators;
        this.cdr = cdr;
        this.platform = platform;
        /**
         * @hidden @internal
         */
        this.validators = [];
        /**
         * Sets/gets the `header` value.
         * ```typescript
         * let columnHeader = this.column.header;
         * ```
         * ```html
         * <igx-column [header] = "'ID'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.header = '';
        /**
         * Sets/gets the `title` value.
         * ```typescript
         * let title = this.column.title;
         * ```
         * ```html
         * <igx-column [title] = "'Some column tooltip'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.title = '';
        /**
         * Sets/gets whether the column is sortable.
         * Default value is `false`.
         * ```typescript
         * let isSortable = this.column.sortable;
         * ```
         * ```html
         * <igx-column [sortable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.sortable = false;
        /**
         * Sets/gets whether the column is groupable.
         * Default value is `false`.
         * ```typescript
         * let isGroupable = this.column.groupable;
         * ```
         * ```html
         * <igx-column [groupable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.groupable = false;
        /**
         * Sets/gets whether the column is filterable.
         * Default value is `true`.
         * ```typescript
         * let isFilterable = this.column.filterable;
         * ```
         * ```html
         * <igx-column [filterable] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.filterable = true;
        /**
         * Sets/gets whether the column is resizable.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.resizable = false;
        /**
         * Sets/gets whether the column header is included in autosize logic.
         * Useful when template for a column header is sized based on parent, for example a default `div`.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.autosizeHeader = true;
        /**
         * @hidden
         */
        this.hiddenChange = new EventEmitter();
        /** @hidden */
        this.expandedChange = new EventEmitter();
        /** @hidden */
        this.collapsibleChange = new EventEmitter();
        /** @hidden */
        this.visibleWhenCollapsedChange = new EventEmitter();
        /** @hidden */
        this.columnChange = new EventEmitter();
        /**
         * Gets whether the hiding is disabled.
         * ```typescript
         * let isHidingDisabled =  this.column.disableHiding;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.disableHiding = false;
        /**
         * Gets whether the pinning is disabled.
         * ```typescript
         * let isPinningDisabled =  this.column.disablePinning;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.disablePinning = false;
        /**
         * @deprecated in version 13.1.0. Use `IgxGridComponent.moving` instead.
         *
         * Sets/gets whether the column is movable.
         * Default value is `false`.
         *
         * ```typescript
         * let isMovable = this.column.movable;
         * ```
         * ```html
         * <igx-column [movable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.movable = false;
        /**
         * Sets/gets the class selector of the column header.
         * ```typescript
         * let columnHeaderClass = this.column.headerClasses;
         * ```
         * ```html
         * <igx-column [headerClasses] = "'column-header'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerClasses = '';
        /**
         * Sets conditional style properties on the column header.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (column) => column.pinned ? 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [headerStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerStyles = null;
        /**
         * Sets/gets the class selector of the column group header.
         * ```typescript
         * let columnHeaderClass = this.column.headerGroupClasses;
         * ```
         * ```html
         * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerGroupClasses = '';
        /**
         * Sets conditional style properties on the column header group wrapper.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (column) => column.pinned ? 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [headerGroupStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerGroupStyles = null;
        /**
         * Sets conditional style properties on the column cells.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * As with `cellClasses` it accepts a callback function.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') ? 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [cellStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.cellStyles = null;
        /**
         * Sets/gets whether the column filtering should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let filteringIgnoreCase = this.column.filteringIgnoreCase;
         * ```
         * ```html
         * <igx-column [filteringIgnoreCase] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.filteringIgnoreCase = true;
        /**
         * Sets/gets whether the column sorting should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let sortingIgnoreCase = this.column.sortingIgnoreCase;
         * ```
         * ```html
         * <igx-column [sortingIgnoreCase] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.sortingIgnoreCase = true;
        /**
         * Sets/gets whether the column is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.column.searchable';
         * ```
         * ```html
         *  <igx-column [searchable] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.searchable = true;
        /**
         * Sets/gets the data type of the column values.
         * Default value is `string`.
         * ```typescript
         * let columnDataType = this.column.dataType;
         * ```
         * ```html
         * <igx-column [dataType] = "'number'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.dataType = GridColumnDataType.String;
        /**
         * @hidden
         */
        this.widthChange = new EventEmitter();
        /**
         * @hidden
         */
        this.pinnedChange = new EventEmitter();
        /**
         * @hidden
         * @internal
         */
        this.defaultTimeFormat = 'hh:mm:ss tt';
        /**
         * @hidden
         * @internal
         */
        this.defaultDateTimeFormat = 'dd/MM/yyyy HH:mm:ss tt';
        /**
         * Sets/gets the parent column.
         * ```typescript
         * let parentColumn = this.column.parent;
         * ```
         * ```typescript
         * this.column.parent = higherLevelColumn;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.parent = null;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        /**
         * @hidden
         */
        this._applySelectableClass = false;
        this._vIndex = NaN;
        /**
         * @hidden
         */
        this._pinned = false;
        /**
         * @hidden
         */
        this._summaries = null;
        /**
         * @hidden
         */
        this._filters = null;
        /**
         * @hidden
         */
        this._sortStrategy = DefaultSortingStrategy.instance();
        /**
         * @hidden
         */
        this._hidden = false;
        /**
         * @hidden
         */
        this._disablePinning = false;
        /**
         * @hidden
         */
        this._defaultMinWidth = '';
        /**
         * @hidden
         */
        this._hasSummary = false;
        /**
         * @hidden
         */
        this._collapsible = false;
        /**
         * @hidden
         */
        this._expanded = true;
        /**
         * @hidden
         */
        this._selectable = true;
        this._calcWidth = null;
        this._columnPipeArgs = { digitsInfo: DEFAULT_DIGITS_INFO };
        this.validators = _validators;
    }
    /**
     * Sets/gets the `field` value.
     * ```typescript
     * let columnField = this.column.field;
     * ```
     * ```html
     * <igx-column [field] = "'ID'"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set field(value) {
        this._field = value;
        this.hasNestedPath = value?.includes('.');
    }
    get field() {
        return this._field;
    }
    /**
     * Returns if the column is selectable.
     * ```typescript
     * let columnSelectable = this.column.selectable;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get selectable() {
        return this._selectable;
    }
    /**
     * Sets if the column is selectable.
     * Default value is `true`.
     * ```html
     * <igx-column [selectable] = "false"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set selectable(value) {
        this._selectable = value;
    }
    /**
     * Gets whether the column is editable.
     * Default value is `false`.
     * ```typescript
     * let isEditable = this.column.editable;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get editable() {
        // Updating the primary key when grid has transactions (incl. row edit)
        // should not be allowed, as that can corrupt transaction state.
        const rowEditable = this.grid && this.grid.rowEditable;
        const hasTransactions = this.grid && this.grid.transactions.enabled;
        if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {
            return false;
        }
        if (this._editable !== undefined) {
            return this._editable;
        }
        else {
            return rowEditable;
        }
    }
    /**
     * Sets whether the column is editable.
     * ```typescript
     * this.column.editable = true;
     * ```
     * ```html
     * <igx-column [editable] = "true"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set editable(editable) {
        this._editable = editable;
    }
    /**
     * Gets a value indicating whether the summary for the column is enabled.
     * ```typescript
     * let hasSummary = this.column.hasSummary;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get hasSummary() {
        return this._hasSummary;
    }
    /**
     * Sets a value indicating whether the summary for the column is enabled.
     * Default value is `false`.
     * ```html
     * <igx-column [hasSummary] = "true"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set hasSummary(value) {
        this._hasSummary = value;
        if (this.grid) {
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets whether the column is hidden.
     * ```typescript
     * let isHidden = this.column.hidden;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column hidden property.
     * Default value is `false`.
     * ```html
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(hidden)] = "model.isHidden"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set hidden(value) {
        if (this._hidden !== value) {
            this._hidden = value;
            this.hiddenChange.emit(this._hidden);
            if (this.columnLayoutChild && this.parent.hidden !== value) {
                this.parent.hidden = value;
                return;
            }
            if (this.grid) {
                this.grid.crudService.endEdit(false);
                this.grid.summaryService.resetSummaryHeight();
                this.grid.filteringService.refreshExpressions();
                this.grid.filteringService.hideFilteringRowOnColumnVisibilityChange(this);
                this.grid.notifyChanges();
            }
        }
    }
    /**
     * Returns if the column is selected.
     * ```typescript
     * let isSelected = this.column.selected;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get selected() {
        return this.grid.selectionService.isColumnSelected(this.field);
    }
    /**
     * Select/deselect a column.
     * Default value is `false`.
     * ```typescript
     * this.column.selected = true;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set selected(value) {
        if (this.selectable && value !== this.selected) {
            if (value) {
                this.grid.selectionService.selectColumnsWithNoEvent([this.field]);
            }
            else {
                this.grid.selectionService.deselectColumnsWithNoEvent([this.field]);
            }
            this.grid.notifyChanges();
        }
    }
    /**
     * Gets the `width` of the column.
     * ```typescript
     * let columnWidth = this.column.width;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get width() {
        const isAutoWidth = this._width && typeof this._width === 'string' && this._width === 'auto';
        if (isAutoWidth) {
            if (!this.autoSize) {
                return 'fit-content';
            }
            else {
                return this.autoSize + 'px';
            }
        }
        return this.widthSetByUser ? this._width : this.defaultWidth;
    }
    /**
     * Sets the `width` of the column.
     * ```html
     * <igx-column [width] = "'25%'"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(width)]="model.columns[0].width"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set width(value) {
        if (value) {
            this._calcWidth = null;
            this.calcPixelWidth = NaN;
            this.widthSetByUser = true;
            // width could be passed as number from the template
            // host bindings are not px affixed so we need to ensure we affix simple number strings
            if (typeof (value) === 'number' || value.match(/^[0-9]*$/)) {
                value = value + 'px';
            }
            if (value === 'fit-content') {
                value = 'auto';
            }
            this._width = value;
            if (this.grid) {
                this.cacheCalcWidth();
            }
            this.widthChange.emit(this._width);
        }
    }
    /**
     * @hidden
     */
    get calcWidth() {
        return this.getCalcWidth();
    }
    /**
     * @hidden
     */
    get maxWidthPx() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.maxWidth) / 100 * gridAvailableSize : parseFloat(this.maxWidth);
    }
    /**
     * @hidden
     */
    get maxWidthPercent() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.maxWidth) : parseFloat(this.maxWidth) / gridAvailableSize * 100;
    }
    /**
     * @hidden
     */
    get minWidthPx() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.minWidth) / 100 * gridAvailableSize : parseFloat(this.minWidth);
    }
    /**
     * @hidden
     */
    get minWidthPercent() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.minWidth) : parseFloat(this.minWidth) / gridAvailableSize * 100;
    }
    /**
     * Sets/gets the minimum `width` of the column.
     * Default value is `88`;
     * ```typescript
     * let columnMinWidth = this.column.minWidth;
     * ```
     * ```html
     * <igx-column [minWidth] = "'100px'"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set minWidth(value) {
        const minVal = parseFloat(value);
        if (Number.isNaN(minVal)) {
            return;
        }
        this._defaultMinWidth = value;
    }
    get minWidth() {
        return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
    }
    /**
     * Gets the column index.
     * ```typescript
     * let columnIndex = this.column.index;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get index() {
        return this.grid._columns.indexOf(this);
    }
    /**
     * Gets whether the column is `pinned`.
     * ```typescript
     * let isPinned = this.column.pinned;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get pinned() {
        return this._pinned;
    }
    /**
     * Sets whether the column is pinned.
     * Default value is `false`.
     * ```html
     * <igx-column [pinned] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set pinned(value) {
        if (this._pinned !== value) {
            const isAutoWidth = this.width && typeof this.width === 'string' && this.width === 'fit-content';
            if (this.grid && this.width && (isAutoWidth || !isNaN(parseInt(this.width, 10)))) {
                if (value) {
                    this.pin();
                }
                else {
                    this.unpin();
                }
                return;
            }
            /* No grid/width available at initialization. `initPinning` in the grid
               will re-init the group (if present)
            */
            this._pinned = value;
            this.pinnedChange.emit(this._pinned);
        }
    }
    /**
     * Gets the column `summaries`.
     * ```typescript
     * let columnSummaries = this.column.summaries;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column `summaries`.
     * ```typescript
     * this.column.summaries = IgxNumberSummaryOperand;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set summaries(classRef) {
        if (isConstructor(classRef)) {
            this._summaries = new classRef();
        }
        if (this.grid) {
            this.grid.summaryService.removeSummariesCachePerColumn(this.field);
            this.grid.summaryPipeTrigger++;
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets the column `filters`.
     * ```typescript
     * let columnFilters = this.column.filters'
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column `filters`.
     * ```typescript
     * this.column.filters = IgxBooleanFilteringOperand.instance().
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set filters(instance) {
        this._filters = instance;
    }
    /**
     * Gets the column `sortStrategy`.
     * ```typescript
     * let sortStrategy = this.column.sortStrategy
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get sortStrategy() {
        return this._sortStrategy;
    }
    /**
     * Sets the column `sortStrategy`.
     * ```typescript
     * this.column.sortStrategy = new CustomSortingStrategy().
     * class CustomSortingStrategy extends SortingStrategy {...}
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set sortStrategy(classRef) {
        this._sortStrategy = classRef;
    }
    /**
     * Gets the function that compares values for grouping.
     * ```typescript
     * let groupingComparer = this.column.groupingComparer'
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get groupingComparer() {
        return this._groupingComparer;
    }
    /**
     * Sets a custom function to compare values for grouping.
     * Subsequent values in the sorted data that the function returns 0 for are grouped.
     * ```typescript
     * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set groupingComparer(funcRef) {
        this._groupingComparer = funcRef;
    }
    /**
     * Gets the default minimum `width` of the column.
     * ```typescript
     * let defaultMinWidth =  this.column.defaultMinWidth;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get defaultMinWidth() {
        if (!this.grid) {
            return '80';
        }
        switch (this.grid.displayDensity) {
            case DisplayDensity.cosy:
                return '64';
            case DisplayDensity.compact:
                return '56';
            default:
                return '80';
        }
    }
    /**
     * Returns a reference to the `summaryTemplate`.
     * ```typescript
     * let summaryTemplate = this.column.summaryTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get summaryTemplate() {
        return this._summaryTemplate;
    }
    /**
     * Sets the summary template.
     * ```html
     * <ng-template #summaryTemplate igxSummary let-summaryResults>
     *    <p>{{ summaryResults[0].label }}: {{ summaryResults[0].summaryResult }}</p>
     *    <p>{{ summaryResults[1].label }}: {{ summaryResults[1].summaryResult }}</p>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'summaryTemplate'", {read: TemplateRef })
     * public summaryTemplate: TemplateRef<any>;
     * this.column.summaryTemplate = this.summaryTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set summaryTemplate(template) {
        this._summaryTemplate = template;
    }
    /**
     * Returns a reference to the `bodyTemplate`.
     * ```typescript
     * let bodyTemplate = this.column.bodyTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * Sets the body template.
     * ```html
     * <ng-template #bodyTemplate igxCell let-val>
     *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
     *       <span> {{val}} </span>
     *    </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'bodyTemplate'", {read: TemplateRef })
     * public bodyTemplate: TemplateRef<any>;
     * this.column.bodyTemplate = this.bodyTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set bodyTemplate(template) {
        this._bodyTemplate = template;
    }
    /**
     * Returns a reference to the header template.
     * ```typescript
     * let headerTemplate = this.column.headerTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get headerTemplate() {
        return this._headerTemplate;
    }
    /**
     * Sets the header template.
     * Note that the column header height is fixed and any content bigger than it will be cut off.
     * ```html
     * <ng-template #headerTemplate>
     *   <div style = "background-color:black" (click) = "changeColor(val)">
     *       <span style="color:red" >{{column.field}}</span>
     *   </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'headerTemplate'", {read: TemplateRef })
     * public headerTemplate: TemplateRef<any>;
     * this.column.headerTemplate = this.headerTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set headerTemplate(template) {
        this._headerTemplate = template;
    }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.column.inlineEditorTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * Sets the inline editor template.
     * ```html
     * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
     *     <input type="string" [(ngModel)]="cell.value"/>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
     * public inlineEditorTemplate: TemplateRef<any>;
     * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set inlineEditorTemplate(template) {
        this._inlineEditorTemplate = template;
    }
    /**
     * Returns a reference to the validation error template.
     * ```typescript
     * let errorTemplate = this.column.errorTemplate;
     * ```
     */
    get errorTemplate() {
        return this._errorTemplate;
    }
    /**
     * Sets the error template.
     * ```html
     * <ng-template igxCellValidationError let-cell="cell" #errorTemplate >
     *     <div *ngIf="cell.validation.errors?.['forbiddenName']">
     *      This name is forbidden.
     *     </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'errorTemplate'", {read: TemplateRef })
     * public errorTemplate: TemplateRef<any>;
     * this.column.errorTemplate = this.errorTemplate;
     * ```
     */
    set errorTemplate(template) {
        this._errorTemplate = template;
    }
    /**
     * Returns a reference to the `filterCellTemplate`.
     * ```typescript
     * let filterCellTemplate = this.column.filterCellTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filterCellTemplate() {
        return this._filterCellTemplate;
    }
    /**
     * Sets the quick filter template.
     * ```html
     * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
     *    <input (input)="onInput()">
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'filterCellTemplate'", {read: TemplateRef })
     * public filterCellTemplate: TemplateRef<any>;
     * this.column.filterCellTemplate = this.filterCellTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set filterCellTemplate(template) {
        this._filterCellTemplate = template;
    }
    /**
     * Gets the cells of the column.
     * ```typescript
     * let columnCells = this.column.cells;
     * ```
     *
     */
    get cells() {
        return this.grid.dataView
            .map((rec, index) => {
            if (!this.grid.isGroupByRecord(rec) && !this.grid.isSummaryRow(rec)) {
                this.grid.pagingMode === 1 && this.grid.paginator.page !== 0 ? index = index + this.grid.paginator.perPage * this.grid.paginator.page : index = this.grid.dataRowList.first.index + index;
                const cell = new IgxGridCell(this.grid, index, this.field);
                return cell;
            }
        }).filter(cell => cell);
    }
    /**
     * @hidden @internal
     */
    get _cells() {
        return this.grid.rowList.filter((row) => row instanceof IgxRowDirective)
            .map((row) => {
            if (row._cells) {
                return row._cells.filter((cell) => cell.columnIndex === this.index);
            }
        }).reduce((a, b) => a.concat(b), []);
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => !c.columnGroup);
        const pinnedColumns = this.grid.pinnedColumns.filter(c => !c.columnGroup);
        let col = this;
        let vIndex = -1;
        if (this.columnGroup) {
            col = this.allChildren.filter(c => !c.columnGroup && !c.hidden)[0];
        }
        if (this.columnLayoutChild) {
            return this.parent.childrenVisibleIndexes.find(x => x.column === this).index;
        }
        if (!this.pinned) {
            const indexInCollection = unpinnedColumns.indexOf(col);
            vIndex = indexInCollection === -1 ?
                -1 :
                (this.grid.isPinningToStart ?
                    pinnedColumns.length + indexInCollection :
                    indexInCollection);
        }
        else {
            const indexInCollection = pinnedColumns.indexOf(col);
            vIndex = this.grid.isPinningToStart ?
                indexInCollection :
                unpinnedColumns.length + indexInCollection;
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnGroup() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnLayout() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnLayoutChild =  this.column.columnLayoutChild;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnLayoutChild() {
        return this.parent && this.parent.columnLayout;
    }
    /**
     * Returns the children columns collection.
     * Returns an empty array if the column does not contain children columns.
     * ```typescript
     * let childrenColumns =  this.column.allChildren;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get allChildren() {
        return [];
    }
    /**
     * Returns the level of the column in a column group.
     * Returns `0` if the column doesn't have a `parent`.
     * ```typescript
     * let columnLevel =  this.column.level;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get level() {
        let ptr = this.parent;
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parent;
        }
        return lvl;
    }
    get isLastPinned() {
        return this.grid.isPinningToStart &&
            this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
    }
    get isFirstPinned() {
        const pinnedCols = this.grid.pinnedColumns.filter(x => !x.columnGroup);
        return !this.grid.isPinningToStart && pinnedCols[0] === this;
    }
    get rightPinnedOffset() {
        return this.pinned && !this.grid.isPinningToStart ?
            -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' :
            null;
    }
    get gridRowSpan() {
        return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
    }
    get gridColumnSpan() {
        return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
    }
    /**
     * Indicates whether the column will be visible when its parent is collapsed.
     * ```html
     * <igx-column-group>
     *   <igx-column [visibleWhenCollapsed]="true"></igx-column>
     * </igx-column-group>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set visibleWhenCollapsed(value) {
        this._visibleWhenCollapsed = value;
        this.visibleWhenCollapsedChange.emit(this._visibleWhenCollapsed);
        if (this.parent) {
            this.parent.setExpandCollapseState();
        }
    }
    get visibleWhenCollapsed() {
        return this._visibleWhenCollapsed;
    }
    /**
     * @remarks
     * Pass optional parameters for DatePipe and/or DecimalPipe to format the display value for date and numeric columns.
     * Accepts an `IColumnPipeArgs` object with any of the `format`, `timezone` and `digitsInfo` properties.
     * For more details see https://angular.io/api/common/DatePipe and https://angular.io/api/common/DecimalPipe
     * @example
     * ```typescript
     * const pipeArgs: IColumnPipeArgs = {
     *      format: 'longDate',
     *      timezone: 'UTC',
     *      digitsInfo: '1.1-2'
     * }
     * ```
     * ```html
     * <igx-column dataType="date" [pipeArgs]="pipeArgs"></igx-column>
     * <igx-column dataType="number" [pipeArgs]="pipeArgs"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set pipeArgs(value) {
        this._columnPipeArgs = Object.assign(this._columnPipeArgs, value);
        this.grid.summaryService.clearSummaryCache();
        this.grid.pipeTrigger++;
    }
    get pipeArgs() {
        return this._columnPipeArgs;
    }
    /**
     * @hidden
     * @internal
     */
    get collapsible() {
        return false;
    }
    set collapsible(_value) { }
    /**
     * @hidden
     * @internal
     */
    get expanded() {
        return true;
    }
    set expanded(_value) { }
    /**
     * Returns the filteringExpressionsTree of the column.
     * ```typescript
     * let tree =  this.column.filteringExpressionsTree;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filteringExpressionsTree() {
        return this.grid.filteringExpressionsTree.find(this.field);
    }
    /**
     * @hidden
     */
    get isPrimaryColumn() {
        return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;
    }
    /**
     * @hidden
     * @internal
     */
    resetCaches() {
        this._vIndex = NaN;
        if (this.grid) {
            this.cacheCalcWidth();
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.summaryTemplateDirective) {
            this._summaryTemplate = this.summaryTemplateDirective.template;
        }
        if (this.cellTemplate) {
            this._bodyTemplate = this.cellTemplate.template;
        }
        if (this.cellValidationErrorTemplate) {
            this._errorTemplate = this.cellValidationErrorTemplate.template;
        }
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        if (this.editorTemplate) {
            this._inlineEditorTemplate = this.editorTemplate.template;
        }
        if (this.filterCellTemplateDirective) {
            this._filterCellTemplate = this.filterCellTemplateDirective.template;
        }
        if (!this._columnPipeArgs.format) {
            this._columnPipeArgs.format = this.dataType === GridColumnDataType.Time ?
                DEFAULT_TIME_FORMAT : this.dataType === GridColumnDataType.DateTime ?
                DEFAULT_DATE_TIME_FORMAT : DEFAULT_DATE_FORMAT;
        }
        if (!this.summaries) {
            switch (this.dataType) {
                case GridColumnDataType.Number:
                case GridColumnDataType.Currency:
                case GridColumnDataType.Percent:
                    this.summaries = IgxNumberSummaryOperand;
                    break;
                case GridColumnDataType.Date:
                case GridColumnDataType.DateTime:
                    this.summaries = IgxDateSummaryOperand;
                    break;
                case GridColumnDataType.Time:
                    this.summaries = IgxTimeSummaryOperand;
                    break;
                case GridColumnDataType.String:
                case GridColumnDataType.Boolean:
                default:
                    this.summaries = IgxSummaryOperand;
                    break;
            }
        }
        if (!this.filters) {
            switch (this.dataType) {
                case GridColumnDataType.Boolean:
                    this.filters = IgxBooleanFilteringOperand.instance();
                    break;
                case GridColumnDataType.Number:
                case GridColumnDataType.Currency:
                case GridColumnDataType.Percent:
                    this.filters = IgxNumberFilteringOperand.instance();
                    break;
                case GridColumnDataType.Date:
                    this.filters = IgxDateFilteringOperand.instance();
                    break;
                case GridColumnDataType.Time:
                    this.filters = IgxTimeFilteringOperand.instance();
                    break;
                case GridColumnDataType.DateTime:
                    this.filters = IgxDateTimeFilteringOperand.instance();
                    break;
                case GridColumnDataType.Image:
                    this.filterable = false;
                    break;
                case GridColumnDataType.String:
                default:
                    this.filters = IgxStringFilteringOperand.instance();
                    break;
            }
        }
    }
    /**
     * @hidden
     */
    getGridTemplate(isRow) {
        if (isRow) {
            const rowsCount = !this.grid.isPivot ? this.grid.multiRowLayoutRowSize : this.children.length - 1;
            return `repeat(${rowsCount},1fr)`;
        }
        else {
            return this.getColumnSizesString(this.children);
        }
    }
    getInitialChildColumnSizes(children) {
        const columnSizes = [];
        // find the smallest col spans
        children.forEach(col => {
            if (!col.colStart) {
                return;
            }
            const newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            const newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
            const bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
            const bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            if (columnSizes[col.colStart - 1] === undefined) {
                // If nothing is defined yet take any column at first
                // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.width === 'fit-content' ? col.autoSize :
                        col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                /**
                 *  If replaced column has bigger span, we want to fill the remaining columns
                 *  that the replacing column does not fill with the old one.
                 */
                if (bothWidthsSet && newSpanSmaller) {
                    // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                    // We have not yet replaced it so we can use it directly from the columnSizes collection.
                    // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                    for (let i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = columnSizes[col.colStart - 1];
                        }
                        else {
                            break;
                        }
                    }
                }
                // Replace the old column with the new one.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.width === 'fit-content' ? col.autoSize :
                        col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                for (let i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                    if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                        columnSizes[i] = {
                            ref: col,
                            width: col.width === 'fit-content' ? col.autoSize :
                                col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                            colSpan: col.gridColumnSpan,
                            colEnd: col.colStart + col.gridColumnSpan,
                            widthSetByUser: col.widthSetByUser
                        };
                    }
                    else {
                        break;
                    }
                }
            }
        });
        // Flatten columnSizes so there are not columns with colSpan > 1
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                let j = 1;
                // Replace all empty places depending on how much the current column spans starting from next col.
                for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                    if (columnSizes[i + j] &&
                        ((!columnSizes[i].width && columnSizes[i + j].width) ||
                            (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                            (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                        // If we reach an already defined column that has width and the current doesn't have or
                        // if the reached column has bigger colSpan we stop.
                        break;
                    }
                    else {
                        const width = columnSizes[i].widthSetByUser ?
                            columnSizes[i].width / columnSizes[i].colSpan :
                            columnSizes[i].width;
                        columnSizes[i + j] = {
                            ref: columnSizes[i].ref,
                            width,
                            colSpan: 1,
                            colEnd: columnSizes[i].colEnd,
                            widthSetByUser: columnSizes[i].widthSetByUser
                        };
                    }
                }
                // Update the current column width so it is divided between all columns it spans and set it to 1.
                columnSizes[i].width = columnSizes[i].widthSetByUser ?
                    columnSizes[i].width / columnSizes[i].colSpan :
                    columnSizes[i].width;
                columnSizes[i].colSpan = 1;
                // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                i += j - 1;
            }
        }
        return columnSizes;
    }
    getFilledChildColumnSizes(children) {
        const columnSizes = this.getInitialChildColumnSizes(children);
        // fill the gaps if there are any
        const result = [];
        for (const size of columnSizes) {
            if (size && !!size.width) {
                result.push(size.width + 'px');
            }
            else {
                result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
            }
        }
        return result;
    }
    getResizableColUnderEnd() {
        if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
            return [{ target: this, spanUsed: 1 }];
        }
        const columnSized = this.getInitialChildColumnSizes(this.parent.children);
        const targets = [];
        const colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
        for (let i = 0; i < columnSized.length; i++) {
            if (this.colStart <= i + 1 && i + 1 < colEnd) {
                targets.push({ target: columnSized[i].ref, spanUsed: 1 });
            }
        }
        const targetsSquashed = [];
        for (const target of targets) {
            if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === target.target.field) {
                targetsSquashed[targetsSquashed.length - 1].spanUsed++;
            }
            else {
                targetsSquashed.push(target);
            }
        }
        return targetsSquashed;
    }
    /**
     * Pins the column at the provided index in the pinned area.
     * Defaults to index `0` if not provided, or to the initial index in the pinned area.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     *
     * @memberof IgxColumnComponent
     */
    pin(index) {
        // TODO: Probably should the return type of the old functions
        // should be moved as a event parameter.
        const grid = this.grid;
        if (this._pinned) {
            return false;
        }
        if (this.parent && !this.parent.pinned) {
            return this.topLevelParent.pin(index);
        }
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index > grid.pinnedColumns.length)) {
            return false;
        }
        if (!this.parent && !this.pinnable) {
            return false;
        }
        const rootPinnedCols = grid._pinnedColumns.filter((c) => c.level === 0);
        index = hasIndex ? index : rootPinnedCols.length;
        const args = { column: this, insertAtIndex: index, isPinned: false, cancel: false };
        this.grid.columnPin.emit(args);
        if (args.cancel) {
            return;
        }
        this.grid.crudService.endEdit(false);
        this._pinned = true;
        this.pinnedChange.emit(this._pinned);
        // it is possible that index is the last position, so will need to find target column by [index-1]
        const targetColumn = args.insertAtIndex === grid._pinnedColumns.length ?
            grid._pinnedColumns[args.insertAtIndex - 1] : grid._pinnedColumns[args.insertAtIndex];
        if (grid._pinnedColumns.indexOf(this) === -1) {
            if (!grid.hasColumnGroups) {
                grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
            }
            else {
                // insert based only on root collection
                rootPinnedCols.splice(args.insertAtIndex, 0, this);
                let allPinned = [];
                // re-create hierarchy
                rootPinnedCols.forEach(group => {
                    allPinned.push(group);
                    allPinned = allPinned.concat(group.allChildren);
                });
                grid._pinnedColumns = allPinned;
            }
            if (grid._unpinnedColumns.indexOf(this) !== -1) {
                const childrenCount = this.allChildren.length;
                grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1 + childrenCount);
            }
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.pin());
            grid.reinitPinStates();
        }
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        const eventArgs = { column: this, insertAtIndex: index, isPinned: true };
        this.grid.columnPinned.emit(eventArgs);
        return true;
    }
    /**
     * Unpins the column and place it at the provided index in the unpinned area.
     * Defaults to index `0` if not provided, or to the initial index in the unpinned area.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     *
     * @memberof IgxColumnComponent
     */
    unpin(index) {
        const grid = this.grid;
        if (!this._pinned) {
            return false;
        }
        if (this.parent && this.parent.pinned) {
            return this.topLevelParent.unpin(index);
        }
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index > grid._unpinnedColumns.length)) {
            return false;
        }
        // estimate the exact index at which column will be inserted
        // takes into account initial unpinned index of the column
        if (!hasIndex) {
            const indices = grid.unpinnedColumns.map(col => col.index);
            indices.push(this.index);
            indices.sort((a, b) => a - b);
            index = indices.indexOf(this.index);
        }
        const args = { column: this, insertAtIndex: index, isPinned: true, cancel: false };
        this.grid.columnPin.emit(args);
        if (args.cancel) {
            return;
        }
        this.grid.crudService.endEdit(false);
        this._pinned = false;
        this.pinnedChange.emit(this._pinned);
        // it is possible that index is the last position, so will need to find target column by [index-1]
        const targetColumn = args.insertAtIndex === grid._unpinnedColumns.length ?
            grid._unpinnedColumns[args.insertAtIndex - 1] : grid._unpinnedColumns[args.insertAtIndex];
        if (!hasIndex) {
            grid._unpinnedColumns.splice(index, 0, this);
            if (grid._pinnedColumns.indexOf(this) !== -1) {
                grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
            }
        }
        if (hasIndex) {
            grid.moveColumn(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.unpin());
        }
        grid.reinitPinStates();
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        this.grid.columnPinned.emit({ column: this, insertAtIndex: index, isPinned: false });
        return true;
    }
    /**
     * Moves a column to the specified visible index.
     * If passed index is invalid, or if column would receive a different visible index after moving, moving is not performed.
     * If passed index would move the column to a different column group. moving is not performed.
     *
     * @example
     * ```typescript
     * column.move(index);
     * ```
     * @memberof IgxColumnComponent
     */
    move(index) {
        let target;
        let columns = this.grid.columns.filter(c => c.visibleIndex > -1);
        // grid last visible index
        const li = columns.map(c => c.visibleIndex).reduce((a, b) => Math.max(a, b));
        const parent = this.parent;
        const isPreceding = this.visibleIndex < index;
        if (index === this.visibleIndex || index < 0 || index > li) {
            return;
        }
        if (parent) {
            columns = columns.filter(c => c.level >= this.level && c !== this && c.parent !== this &&
                c.topLevelParent === this.topLevelParent);
        }
        /* eslint-disable max-len */
        // If isPreceding, find a target such that when the current column is placed after it, current colummn will receive a visibleIndex === index. This takes into account visible children of the columns.
        // If !isPreceding, finds a column of the same level and visible index that equals the passed index agument (c.visibleIndex === index). No need to consider the children here.
        /* eslint-enable max-len */
        if (isPreceding) {
            columns = columns.filter(c => c.visibleIndex > this.visibleIndex);
            target = columns.find(c => c.level === this.level && c.visibleIndex + c.calcChildren() - this.calcChildren() === index);
        }
        else {
            columns = columns.filter(c => c.visibleIndex < this.visibleIndex);
            target = columns.find(c => c.level === this.level && c.visibleIndex === index);
        }
        if (!target || (target.pinned && this.disablePinning)) {
            return;
        }
        const pos = isPreceding ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;
        this.grid.moveColumn(this, target, pos);
    }
    /**
     * No children for the column, so will returns 1 or 0, if the column is hidden.
     *
     * @hidden
     */
    calcChildren() {
        const children = this.hidden ? 0 : 1;
        return children;
    }
    /**
     * Toggles column vibisility and emits the respective event.
     *
     * @hidden
     */
    toggleVisibility(value) {
        const newValue = value ?? !this.hidden;
        const eventArgs = { column: this, newValue, cancel: false };
        this.grid.columnVisibilityChanging.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        this.hidden = newValue;
        this.grid.columnVisibilityChanged.emit({ column: this, newValue });
    }
    /**
     * Returns a reference to the top level parent column.
     * ```typescript
     * let topLevelParent =  this.column.topLevelParent;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get topLevelParent() {
        let parent = this.parent;
        while (parent && parent.parent) {
            parent = parent.parent;
        }
        return parent;
    }
    /**
     * Returns a reference to the header of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let headerCell = column.headerCell;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get headerCell() {
        return this.grid.headerCellList.find((header) => header.column === this);
    }
    /**
     * Returns a reference to the filter cell of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let filterell = column.filterell;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filterCell() {
        return this.grid.filterCellList.find((filterCell) => filterCell.column === this);
    }
    /**
     * Returns a reference to the header group of the column.
     *
     * @memberof IgxColumnComponent
     */
    get headerGroup() {
        return this.grid.headerGroupsList.find(group => group.column === this);
    }
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     *
     * @memberof IgxColumnComponent
     * @param byHeaderOnly Set if column should be autosized based only on the header content.
     */
    autosize(byHeaderOnly = false) {
        if (!this.columnGroup) {
            this.width = this.getAutoSize(byHeaderOnly);
            this.grid.reflow();
        }
    }
    /**
     * @hidden
     */
    getAutoSize(byHeader = false) {
        const size = !byHeader ? this.getLargestCellWidth() :
            (Object.values(this.getHeaderCellWidths()).reduce((a, b) => a + b) + 'px');
        const isPercentageWidth = this.width && typeof this.width === 'string' && this.width.indexOf('%') !== -1;
        let newWidth;
        if (isPercentageWidth) {
            const gridAvailableSize = this.grid.calcWidth;
            const percentageSize = parseFloat(size) / gridAvailableSize * 100;
            newWidth = percentageSize + '%';
        }
        else {
            newWidth = size;
        }
        const maxWidth = isPercentageWidth ? this.maxWidthPercent : this.maxWidthPx;
        const minWidth = isPercentageWidth ? this.minWidthPercent : this.minWidthPx;
        if (this.maxWidth && (parseFloat(newWidth) > maxWidth)) {
            newWidth = isPercentageWidth ? maxWidth + '%' : maxWidth + 'px';
        }
        else if (parseFloat(newWidth) < minWidth) {
            newWidth = isPercentageWidth ? minWidth + '%' : minWidth + 'px';
        }
        return newWidth;
    }
    /**
     * @hidden
     */
    getCalcWidth() {
        if (this._calcWidth && !isNaN(this.calcPixelWidth)) {
            return this._calcWidth;
        }
        this.cacheCalcWidth();
        return this._calcWidth;
    }
    /**
     * @hidden
     * Returns the width and padding of a header cell.
     */
    getHeaderCellWidths() {
        return this.grid.getHeaderCellWidth(this.headerCell.nativeElement);
    }
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * @memberof IgxColumnComponent
     */
    getLargestCellWidth() {
        const range = this.grid.document.createRange();
        const largest = new Map();
        if (this._cells.length > 0) {
            const cellsContentWidths = [];
            this._cells.forEach((cell) => cellsContentWidths.push(cell.calculateSizeToFit(range)));
            const index = cellsContentWidths.indexOf(Math.max(...cellsContentWidths));
            const cellStyle = this.grid.document.defaultView.getComputedStyle(this._cells[index].nativeElement);
            const cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                parseFloat(cellStyle.borderLeftWidth) + parseFloat(cellStyle.borderRightWidth);
            largest.set(Math.max(...cellsContentWidths), cellPadding);
        }
        if (this.headerCell && this.autosizeHeader) {
            const headerCellWidths = this.getHeaderCellWidths();
            largest.set(headerCellWidths.width, headerCellWidths.padding);
        }
        const largestCell = Math.max(...Array.from(largest.keys()));
        const width = Math.ceil(largestCell + largest.get(largestCell));
        if (Number.isNaN(width)) {
            return this.width;
        }
        else {
            return width + 'px';
        }
    }
    /**
     * @hidden
     */
    getCellWidth() {
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (this.columnLayoutChild) {
            return '';
        }
        if (colWidth && !isPercentageWidth) {
            let cellWidth = colWidth;
            if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                cellWidth += 'px';
            }
            return cellWidth;
        }
        else {
            return colWidth;
        }
    }
    /**
     * @hidden
     */
    populateVisibleIndexes() { }
    getColumnSizesString(children) {
        const res = this.getFilledChildColumnSizes(children);
        return res.join(' ');
    }
    /**
     * @hidden
     * @internal
     */
    cacheCalcWidth() {
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        const isAutoWidth = colWidth && typeof colWidth === 'string' && colWidth === 'fit-content';
        if (isPercentageWidth) {
            this._calcWidth = parseFloat(colWidth) / 100 * this.grid.calcWidth;
        }
        else if (!colWidth || isAutoWidth && !this.autoSize) {
            // no width
            this._calcWidth = this.defaultWidth || this.grid.getPossibleColumnWidth();
        }
        else {
            this._calcWidth = this.width;
        }
        this.calcPixelWidth = parseFloat(this._calcWidth);
    }
    /**
     * @hidden
     * @internal
     */
    setExpandCollapseState() {
        this.children.filter(col => (col.visibleWhenCollapsed !== undefined)).forEach(c => {
            if (!this.collapsible) {
                c.hidden = this.hidden;
                return;
            }
            c.hidden = this._expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
        });
    }
    /**
     * @hidden
     * @internal
     */
    checkCollapsibleState() {
        if (!this.children) {
            return false;
        }
        const cols = this.children.map(child => child.visibleWhenCollapsed);
        return (cols.some(c => c === true) && cols.some(c => c === false));
    }
    /**
     * @hidden
     */
    get pinnable() {
        return this.grid._init || !this.pinned;
    }
    /**
     * @hidden
     */
    get applySelectableClass() {
        return this._applySelectableClass;
    }
    /**
     * @hidden
     */
    set applySelectableClass(value) {
        if (this.selectable) {
            this._applySelectableClass = value;
        }
    }
}
IgxColumnComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: IgxColumnComponent, deps: [{ token: IGX_GRID_BASE }, { token: NG_VALIDATORS, optional: true, self: true }, { token: i0.ChangeDetectorRef }, { token: i1.PlatformUtil }], target: i0.ɵɵFactoryTarget.Component });
IgxColumnComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.0", type: IgxColumnComponent, selector: "igx-column", inputs: { field: "field", header: "header", title: "title", sortable: "sortable", selectable: "selectable", groupable: "groupable", editable: "editable", filterable: "filterable", resizable: "resizable", autosizeHeader: "autosizeHeader", hasSummary: "hasSummary", hidden: "hidden", disableHiding: "disableHiding", disablePinning: "disablePinning", movable: "movable", width: "width", maxWidth: "maxWidth", headerClasses: "headerClasses", headerStyles: "headerStyles", headerGroupClasses: "headerGroupClasses", headerGroupStyles: "headerGroupStyles", cellClasses: "cellClasses", cellStyles: "cellStyles", formatter: "formatter", summaryFormatter: "summaryFormatter", filteringIgnoreCase: "filteringIgnoreCase", sortingIgnoreCase: "sortingIgnoreCase", searchable: "searchable", dataType: "dataType", collapsibleIndicatorTemplate: "collapsibleIndicatorTemplate", rowEnd: "rowEnd", colEnd: "colEnd", rowStart: "rowStart", colStart: "colStart", additionalTemplateContext: "additionalTemplateContext", minWidth: "minWidth", pinned: "pinned", summaries: "summaries", filters: "filters", sortStrategy: "sortStrategy", groupingComparer: "groupingComparer", summaryTemplate: "summaryTemplate", bodyTemplate: ["cellTemplate", "bodyTemplate"], headerTemplate: "headerTemplate", inlineEditorTemplate: ["cellEditorTemplate", "inlineEditorTemplate"], errorTemplate: "errorTemplate", filterCellTemplate: "filterCellTemplate", visibleWhenCollapsed: "visibleWhenCollapsed", pipeArgs: "pipeArgs" }, outputs: { hiddenChange: "hiddenChange", expandedChange: "expandedChange", collapsibleChange: "collapsibleChange", visibleWhenCollapsedChange: "visibleWhenCollapsedChange", columnChange: "columnChange", widthChange: "widthChange", pinnedChange: "pinnedChange" }, queries: [{ propertyName: "filterCellTemplateDirective", first: true, predicate: IgxFilterCellTemplateDirective, descendants: true, read: IgxFilterCellTemplateDirective }, { propertyName: "summaryTemplateDirective", first: true, predicate: IgxSummaryTemplateDirective, descendants: true, read: IgxSummaryTemplateDirective }, { propertyName: "cellTemplate", first: true, predicate: IgxCellTemplateDirective, descendants: true, read: IgxCellTemplateDirective }, { propertyName: "cellValidationErrorTemplate", first: true, predicate: IgxCellValidationErrorDirective, descendants: true, read: IgxCellValidationErrorDirective }, { propertyName: "editorTemplate", first: true, predicate: IgxCellEditorTemplateDirective, descendants: true, read: IgxCellEditorTemplateDirective }, { propertyName: "collapseIndicatorTemplate", first: true, predicate: IgxCollapsibleIndicatorTemplateDirective, descendants: true, read: IgxCollapsibleIndicatorTemplateDirective }, { propertyName: "headTemplate", predicate: IgxCellHeaderTemplateDirective, read: IgxCellHeaderTemplateDirective }], ngImport: i0, template: ``, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "header", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "title", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "sortable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "selectable", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "groupable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "editable", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filterable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "resizable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "autosizeHeader", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "hasSummary", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "hidden", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "disableHiding", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "disablePinning", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "width", null);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "maxWidth", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerGroupClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerGroupStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "cellClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "cellStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "formatter", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "summaryFormatter", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filteringIgnoreCase", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "sortingIgnoreCase", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "searchable", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "minWidth", null);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "pinned", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "summaries", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "summaryTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "bodyTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "inlineEditorTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "errorTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filterCellTemplate", null);
__decorate([
    notifyChanges(true)
], IgxColumnComponent.prototype, "visibleWhenCollapsed", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "pipeArgs", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: IgxColumnComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'igx-column',
                    template: ``
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }, {
                    type: Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: i0.ChangeDetectorRef }, { type: i1.PlatformUtil }]; }, propDecorators: { field: [{
                type: Input
            }], header: [{
                type: Input
            }], title: [{
                type: Input
            }], sortable: [{
                type: Input
            }], selectable: [{
                type: Input
            }], groupable: [{
                type: Input
            }], editable: [{
                type: Input
            }], filterable: [{
                type: Input
            }], resizable: [{
                type: Input
            }], autosizeHeader: [{
                type: Input
            }], hasSummary: [{
                type: Input
            }], hidden: [{
                type: Input
            }], hiddenChange: [{
                type: Output
            }], expandedChange: [{
                type: Output
            }], collapsibleChange: [{
                type: Output
            }], visibleWhenCollapsedChange: [{
                type: Output
            }], columnChange: [{
                type: Output
            }], disableHiding: [{
                type: Input
            }], disablePinning: [{
                type: Input
            }], movable: [{
                type: Input
            }], width: [{
                type: Input
            }], maxWidth: [{
                type: Input
            }], headerClasses: [{
                type: Input
            }], headerStyles: [{
                type: Input
            }], headerGroupClasses: [{
                type: Input
            }], headerGroupStyles: [{
                type: Input
            }], cellClasses: [{
                type: Input
            }], cellStyles: [{
                type: Input
            }], formatter: [{
                type: Input
            }], summaryFormatter: [{
                type: Input
            }], filteringIgnoreCase: [{
                type: Input
            }], sortingIgnoreCase: [{
                type: Input
            }], searchable: [{
                type: Input
            }], dataType: [{
                type: Input
            }], collapsibleIndicatorTemplate: [{
                type: Input
            }], rowEnd: [{
                type: Input
            }], colEnd: [{
                type: Input
            }], rowStart: [{
                type: Input
            }], colStart: [{
                type: Input
            }], additionalTemplateContext: [{
                type: Input
            }], widthChange: [{
                type: Output
            }], pinnedChange: [{
                type: Output
            }], filterCellTemplateDirective: [{
                type: ContentChild,
                args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective }]
            }], summaryTemplateDirective: [{
                type: ContentChild,
                args: [IgxSummaryTemplateDirective, { read: IgxSummaryTemplateDirective }]
            }], cellTemplate: [{
                type: ContentChild,
                args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective }]
            }], cellValidationErrorTemplate: [{
                type: ContentChild,
                args: [IgxCellValidationErrorDirective, { read: IgxCellValidationErrorDirective }]
            }], headTemplate: [{
                type: ContentChildren,
                args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false }]
            }], editorTemplate: [{
                type: ContentChild,
                args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective }]
            }], collapseIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxCollapsibleIndicatorTemplateDirective, { read: IgxCollapsibleIndicatorTemplateDirective, static: false }]
            }], minWidth: [{
                type: Input
            }], pinned: [{
                type: Input
            }], summaries: [{
                type: Input
            }], filters: [{
                type: Input
            }], sortStrategy: [{
                type: Input
            }], groupingComparer: [{
                type: Input
            }], summaryTemplate: [{
                type: Input
            }], bodyTemplate: [{
                type: Input,
                args: ['cellTemplate']
            }], headerTemplate: [{
                type: Input
            }], inlineEditorTemplate: [{
                type: Input,
                args: ['cellEditorTemplate']
            }], errorTemplate: [{
                type: Input,
                args: ['errorTemplate']
            }], filterCellTemplate: [{
                type: Input,
                args: ['filterCellTemplate']
            }], visibleWhenCollapsed: [{
                type: Input
            }], pipeArgs: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9jb2x1bW5zL2NvbHVtbi5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUdILHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsWUFBWSxFQUNaLGVBQWUsRUFDZixLQUFLLEVBR0wsTUFBTSxFQUNOLFlBQVksRUFFWixNQUFNLEVBQ04sUUFBUSxFQUNSLElBQUksR0FDUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDakQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDdEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDckUsT0FBTyxFQUVILDBCQUEwQixFQUMxQix5QkFBeUIsRUFDekIsdUJBQXVCLEVBQ3ZCLHlCQUF5QixFQUN6QiwyQkFBMkIsRUFDM0IsdUJBQXVCLEVBQzFCLE1BQU0sMkNBQTJDLENBQUM7QUFDbkQsT0FBTyxFQUFvQixzQkFBc0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQ2xHLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFbkQsT0FBTyxFQUErRyxhQUFhLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUl0SyxPQUFPLEVBQ0gsaUJBQWlCLEVBQUUsdUJBQXVCLEVBQUUscUJBQXFCLEVBQy9DLHFCQUFxQixFQUMxQyxNQUFNLDJCQUEyQixDQUFDO0FBQ25DLE9BQU8sRUFDSCx3QkFBd0IsRUFDeEIsOEJBQThCLEVBQzlC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QUFFLDhCQUE4QixFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUU7Z0JBTW5HLGNBQWM7c0JBRHZCLFlBQVk7dUJBQUMsOEJBQThCLEVBQUUsRUFBRSxJQUFJLEVBQUUsOEJBQThCLEVBQUU7Z0JBTTVFLHlCQUF5QjtzQkFEbEMsWUFBWTt1QkFBQyx3Q0FBd0MsRUFBRSxFQUFFLElBQUksRUFBRSx3Q0FBd0MsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO2dCQStEOUcsUUFBUTtzQkFEbEIsS0FBSztnQkFtQ0ssTUFBTTtzQkFEaEIsS0FBSztnQkFnREssU0FBUztzQkFEbkIsS0FBSztnQkFnQ0ssT0FBTztzQkFEakIsS0FBSztnQkF3QkssWUFBWTtzQkFEdEIsS0FBSztnQkF5QkssZ0JBQWdCO3NCQUQxQixLQUFLO2dCQWdESyxlQUFlO3NCQUR6QixLQUFLO2dCQW1DSyxZQUFZO3NCQUR0QixLQUFLO3VCQUFDLGNBQWM7Z0JBbUNWLGNBQWM7c0JBRHhCLEtBQUs7Z0JBb0NLLG9CQUFvQjtzQkFEOUIsS0FBSzt1QkFBQyxvQkFBb0I7Z0JBZ0NoQixhQUFhO3NCQUR2QixLQUFLO3VCQUFDLGVBQWU7Z0JBa0NYLGtCQUFrQjtzQkFENUIsS0FBSzt1QkFBQyxvQkFBb0I7Z0JBcU1oQixvQkFBb0I7c0JBRDlCLEtBQUs7Z0JBbUNLLFFBQVE7c0JBRGxCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgSW5wdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIE91dHB1dCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgT25EZXN0cm95LFxuICAgIEluamVjdCxcbiAgICBPcHRpb25hbCxcbiAgICBTZWxmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG5vdGlmeUNoYW5nZXMgfSBmcm9tICcuLi93YXRjaC1jaGFuZ2VzJztcbmltcG9ydCB7IFdhdGNoQ29sdW1uQ2hhbmdlcyB9IGZyb20gJy4uL3dhdGNoLWNoYW5nZXMnO1xuaW1wb3J0IHsgR3JpZENvbHVtbkRhdGFUeXBlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2RhdGEtdXRpbCc7XG5pbXBvcnQge1xuICAgIElneEZpbHRlcmluZ09wZXJhbmQsXG4gICAgSWd4Qm9vbGVhbkZpbHRlcmluZ09wZXJhbmQsXG4gICAgSWd4TnVtYmVyRmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hEYXRlRmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hTdHJpbmdGaWx0ZXJpbmdPcGVyYW5kLFxuICAgIElneERhdGVUaW1lRmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hUaW1lRmlsdGVyaW5nT3BlcmFuZFxufSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZmlsdGVyaW5nLWNvbmRpdGlvbic7XG5pbXBvcnQgeyBJU29ydGluZ1N0cmF0ZWd5LCBEZWZhdWx0U29ydGluZ1N0cmF0ZWd5IH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL3NvcnRpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgRGlzcGxheURlbnNpdHkgfSBmcm9tICcuLi8uLi9jb3JlL2Rpc3BsYXlEZW5zaXR5JztcbmltcG9ydCB7IElneFJvd0RpcmVjdGl2ZSB9IGZyb20gJy4uL3Jvdy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1leHByZXNzaW9ucy10cmVlJztcbmltcG9ydCB7IENlbGxUeXBlLCBDb2x1bW5UeXBlLCBHcmlkVHlwZSwgSWd4Q2VsbFRlbXBsYXRlQ29udGV4dCwgSWd4Q29sdW1uVGVtcGxhdGVDb250ZXh0LCBJZ3hTdW1tYXJ5VGVtcGxhdGVDb250ZXh0LCBJR1hfR1JJRF9CQVNFIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuLi9oZWFkZXJzL2dyaWQtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hHcmlkRmlsdGVyaW5nQ2VsbENvbXBvbmVudCB9IGZyb20gJy4uL2ZpbHRlcmluZy9iYXNlL2dyaWQtZmlsdGVyaW5nLWNlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudCB9IGZyb20gJy4uL2hlYWRlcnMvZ3JpZC1oZWFkZXItZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgSWd4U3VtbWFyeU9wZXJhbmQsIElneE51bWJlclN1bW1hcnlPcGVyYW5kLCBJZ3hEYXRlU3VtbWFyeU9wZXJhbmQsXG4gICAgSWd4U3VtbWFyeVJlc3VsdCwgSWd4VGltZVN1bW1hcnlPcGVyYW5kXG59IGZyb20gJy4uL3N1bW1hcmllcy9ncmlkLXN1bW1hcnknO1xuaW1wb3J0IHtcbiAgICBJZ3hDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSWd4Q2VsbEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIElneENlbGxFZGl0b3JUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJZ3hDb2xsYXBzaWJsZUluZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIElneEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJZ3hTdW1tYXJ5VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSWd4Q2VsbFZhbGlkYXRpb25FcnJvckRpcmVjdGl2ZVxufSBmcm9tICcuL3RlbXBsYXRlcy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTVJMUmVzaXplQ29sdW1uSW5mbywgTVJMQ29sdW1uU2l6ZUluZm8sIElDb2x1bW5QaXBlQXJncyB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBEcm9wUG9zaXRpb24gfSBmcm9tICcuLi9tb3ZpbmcvbW92aW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgSUNvbHVtblZpc2liaWxpdHlDaGFuZ2luZ0V2ZW50QXJncywgSVBpbkNvbHVtbkNhbmNlbGxhYmxlRXZlbnRBcmdzLCBJUGluQ29sdW1uRXZlbnRBcmdzIH0gZnJvbSAnLi4vY29tbW9uL2V2ZW50cyc7XG5pbXBvcnQgeyBpc0NvbnN0cnVjdG9yLCBQbGF0Zm9ybVV0aWwgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IElneEdyaWRDZWxsIH0gZnJvbSAnLi4vZ3JpZC1wdWJsaWMtY2VsbCc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmNvbnN0IERFRkFVTFRfREFURV9GT1JNQVQgPSAnbWVkaXVtRGF0ZSc7XG5jb25zdCBERUZBVUxUX1RJTUVfRk9STUFUID0gJ21lZGl1bVRpbWUnO1xuY29uc3QgREVGQVVMVF9EQVRFX1RJTUVfRk9STUFUID0gJ21lZGl1bSc7XG5jb25zdCBERUZBVUxUX0RJR0lUU19JTkZPID0gJzEuMC0zJztcblxuLyoqXG4gKiAqKklnbml0ZSBVSSBmb3IgQW5ndWxhciBDb2x1bW4qKiAtXG4gKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuaW5mcmFnaXN0aWNzLmNvbS9wcm9kdWN0cy9pZ25pdGUtdWktYW5ndWxhci9hbmd1bGFyL2NvbXBvbmVudHMvZ3JpZC9ncmlkI2NvbHVtbnMtY29uZmlndXJhdGlvbilcbiAqXG4gKiBUaGUgSWduaXRlIFVJIENvbHVtbiBpcyB1c2VkIHdpdGhpbiBhbiBgaWd4LWdyaWRgIGVsZW1lbnQgdG8gZGVmaW5lIHdoYXQgZGF0YSB0aGUgY29sdW1uIHdpbGwgc2hvdy4gRmVhdHVyZXMgc3VjaCBhcyBzb3J0aW5nLFxuICogZmlsdGVyaW5nICYgZWRpdGluZyBhcmUgZW5hYmxlZCBhdCB0aGUgY29sdW1uIGxldmVsLiAgWW91IGNhbiBhbHNvIHByb3ZpZGUgYSB0ZW1wbGF0ZSBjb250YWluaW5nIGN1c3RvbSBjb250ZW50IGluc2lkZVxuICogdGhlIGNvbHVtbiB1c2luZyBgbmctdGVtcGxhdGVgIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgYWxsIGNlbGxzIHdpdGhpbiB0aGUgY29sdW1uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBzZWxlY3RvcjogJ2lneC1jb2x1bW4nLFxuICAgIHRlbXBsYXRlOiBgYFxufSlcbmV4cG9ydCBjbGFzcyBJZ3hDb2x1bW5Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3ksIENvbHVtblR5cGUge1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgYGZpZWxkYCB2YWx1ZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkZpZWxkID0gdGhpcy5jb2x1bW4uZmllbGQ7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtmaWVsZF0gPSBcIidJRCdcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IGZpZWxkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fZmllbGQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNOZXN0ZWRQYXRoID0gdmFsdWU/LmluY2x1ZGVzKCcuJyk7XG4gICAgfVxuICAgIHB1YmxpYyBnZXQgZmllbGQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgdmFsaWRhdG9yczogVmFsaWRhdG9yW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgYGhlYWRlcmAgdmFsdWUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5IZWFkZXIgPSB0aGlzLmNvbHVtbi5oZWFkZXI7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtoZWFkZXJdID0gXCInSUQnXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoZWFkZXIgPSAnJztcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGB0aXRsZWAgdmFsdWUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB0aXRsZSA9IHRoaXMuY29sdW1uLnRpdGxlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbdGl0bGVdID0gXCInU29tZSBjb2x1bW4gdG9vbHRpcCdcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRpdGxlID0gJyc7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc1NvcnRhYmxlID0gdGhpcy5jb2x1bW4uc29ydGFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtzb3J0YWJsZV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc29ydGFibGUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBjb2x1bW4gaXMgc2VsZWN0YWJsZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtblNlbGVjdGFibGUgPSB0aGlzLmNvbHVtbi5zZWxlY3RhYmxlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBzZWxlY3RhYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0YWJsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGlmIHRoZSBjb2x1bW4gaXMgc2VsZWN0YWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3NlbGVjdGFibGVdID0gXCJmYWxzZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHNlbGVjdGFibGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0YWJsZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgZ3JvdXBhYmxlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzR3JvdXBhYmxlID0gdGhpcy5jb2x1bW4uZ3JvdXBhYmxlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZ3JvdXBhYmxlXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcyh0cnVlKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdyb3VwYWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGVkaXRhYmxlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzRWRpdGFibGUgPSB0aGlzLmNvbHVtbi5lZGl0YWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZWRpdGFibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIFVwZGF0aW5nIHRoZSBwcmltYXJ5IGtleSB3aGVuIGdyaWQgaGFzIHRyYW5zYWN0aW9ucyAoaW5jbC4gcm93IGVkaXQpXG4gICAgICAgIC8vIHNob3VsZCBub3QgYmUgYWxsb3dlZCwgYXMgdGhhdCBjYW4gY29ycnVwdCB0cmFuc2FjdGlvbiBzdGF0ZS5cbiAgICAgICAgY29uc3Qgcm93RWRpdGFibGUgPSB0aGlzLmdyaWQgJiYgdGhpcy5ncmlkLnJvd0VkaXRhYmxlO1xuICAgICAgICBjb25zdCBoYXNUcmFuc2FjdGlvbnMgPSB0aGlzLmdyaWQgJiYgdGhpcy5ncmlkLnRyYW5zYWN0aW9ucy5lbmFibGVkO1xuXG4gICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeUNvbHVtbiAmJiAocm93RWRpdGFibGUgfHwgaGFzVHJhbnNhY3Rpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2VkaXRhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lZGl0YWJsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByb3dFZGl0YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBlZGl0YWJsZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4uZWRpdGFibGUgPSB0cnVlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZWRpdGFibGVdID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgZWRpdGFibGUoZWRpdGFibGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZWRpdGFibGUgPSBlZGl0YWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBmaWx0ZXJhYmxlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNGaWx0ZXJhYmxlID0gdGhpcy5jb2x1bW4uZmlsdGVyYWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2ZpbHRlcmFibGVdID0gXCJmYWxzZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZmlsdGVyYWJsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyByZXNpemFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNSZXNpemFibGUgPSB0aGlzLmNvbHVtbi5yZXNpemFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtyZXNpemFibGVdID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJlc2l6YWJsZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBoZWFkZXIgaXMgaW5jbHVkZWQgaW4gYXV0b3NpemUgbG9naWMuXG4gICAgICogVXNlZnVsIHdoZW4gdGVtcGxhdGUgZm9yIGEgY29sdW1uIGhlYWRlciBpcyBzaXplZCBiYXNlZCBvbiBwYXJlbnQsIGZvciBleGFtcGxlIGEgZGVmYXVsdCBgZGl2YC5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc1Jlc2l6YWJsZSA9IHRoaXMuY29sdW1uLnJlc2l6YWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3Jlc2l6YWJsZV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgYXV0b3NpemVIZWFkZXIgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3VtbWFyeSBmb3IgdGhlIGNvbHVtbiBpcyBlbmFibGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaGFzU3VtbWFyeSA9IHRoaXMuY29sdW1uLmhhc1N1bW1hcnk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXModHJ1ZSlcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgaGFzU3VtbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1N1bW1hcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHN1bW1hcnkgZm9yIHRoZSBjb2x1bW4gaXMgZW5hYmxlZC5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtoYXNTdW1tYXJ5XSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGhhc1N1bW1hcnkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGFzU3VtbWFyeSA9IHZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5U2VydmljZS5yZXNldFN1bW1hcnlIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBoaWRkZW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0hpZGRlbiA9IHRoaXMuY29sdW1uLmhpZGRlbjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcyh0cnVlKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBoaWRkZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWRkZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbHVtbiBoaWRkZW4gcHJvcGVydHkuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGlkZGVuXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFR3by13YXkgZGF0YSBiaW5kaW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbKGhpZGRlbildID0gXCJtb2RlbC5pc0hpZGRlblwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGhpZGRlbih2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5faGlkZGVuICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGlkZGVuID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhpZGRlbkNoYW5nZS5lbWl0KHRoaXMuX2hpZGRlbik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW5MYXlvdXRDaGlsZCAmJiB0aGlzLnBhcmVudC5oaWRkZW4gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuaGlkZGVuID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5jcnVkU2VydmljZS5lbmRFZGl0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuc3VtbWFyeVNlcnZpY2UucmVzZXRTdW1tYXJ5SGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UucmVmcmVzaEV4cHJlc3Npb25zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UuaGlkZUZpbHRlcmluZ1Jvd09uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgY29sdW1uIGlzIHNlbGVjdGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNTZWxlY3RlZCA9IHRoaXMuY29sdW1uLnNlbGVjdGVkO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuc2VsZWN0aW9uU2VydmljZS5pc0NvbHVtblNlbGVjdGVkKHRoaXMuZmllbGQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdC9kZXNlbGVjdCBhIGNvbHVtbi5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHNlbGVjdGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUgJiYgdmFsdWUgIT09IHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdENvbHVtbnNXaXRoTm9FdmVudChbdGhpcy5maWVsZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuc2VsZWN0aW9uU2VydmljZS5kZXNlbGVjdENvbHVtbnNXaXRoTm9FdmVudChbdGhpcy5maWVsZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ncmlkLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgaGlkZGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBjb2xsYXBzaWJsZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyB2aXNpYmxlV2hlbkNvbGxhcHNlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGNvbHVtbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgaGlkaW5nIGlzIGRpc2FibGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNIaWRpbmdEaXNhYmxlZCA9ICB0aGlzLmNvbHVtbi5kaXNhYmxlSGlkaW5nO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkaXNhYmxlSGlkaW5nID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwaW5uaW5nIGlzIGRpc2FibGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNQaW5uaW5nRGlzYWJsZWQgPSAgdGhpcy5jb2x1bW4uZGlzYWJsZVBpbm5pbmc7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRpc2FibGVQaW5uaW5nID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgaW4gdmVyc2lvbiAxMy4xLjAuIFVzZSBgSWd4R3JpZENvbXBvbmVudC5tb3ZpbmdgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIG1vdmFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc01vdmFibGUgPSB0aGlzLmNvbHVtbi5tb3ZhYmxlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbbW92YWJsZV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbW92YWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGB3aWR0aGAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbldpZHRoID0gdGhpcy5jb2x1bW4ud2lkdGg7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXModHJ1ZSlcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgd2lkdGgoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgaXNBdXRvV2lkdGggPSB0aGlzLl93aWR0aCAmJiB0eXBlb2YgdGhpcy5fd2lkdGggPT09ICdzdHJpbmcnICYmIHRoaXMuX3dpZHRoID09PSAnYXV0byc7XG4gICAgICAgIGlmIChpc0F1dG9XaWR0aCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF1dG9TaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmaXQtY29udGVudCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF1dG9TaXplICsgJ3B4JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoU2V0QnlVc2VyID8gdGhpcy5fd2lkdGggOiB0aGlzLmRlZmF1bHRXaWR0aDtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXV0b1NpemU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB3aWR0aGAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3dpZHRoXSA9IFwiJzI1JSdcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUd28td2F5IGRhdGEgYmluZGluZy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gWyh3aWR0aCldPVwibW9kZWwuY29sdW1uc1swXS53aWR0aFwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHdpZHRoKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjV2lkdGggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jYWxjUGl4ZWxXaWR0aCA9IE5hTjtcbiAgICAgICAgICAgIHRoaXMud2lkdGhTZXRCeVVzZXIgPSB0cnVlO1xuICAgICAgICAgICAgLy8gd2lkdGggY291bGQgYmUgcGFzc2VkIGFzIG51bWJlciBmcm9tIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgLy8gaG9zdCBiaW5kaW5ncyBhcmUgbm90IHB4IGFmZml4ZWQgc28gd2UgbmVlZCB0byBlbnN1cmUgd2UgYWZmaXggc2ltcGxlIG51bWJlciBzdHJpbmdzXG4gICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09ICdudW1iZXInIHx8IHZhbHVlLm1hdGNoKC9eWzAtOV0qJC8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICdmaXQtY29udGVudCcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICdhdXRvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZUNhbGNXaWR0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53aWR0aENoYW5nZS5lbWl0KHRoaXMuX3dpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgbWF4aW11bSBgd2lkdGhgIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5NYXhXaWR0aCA9IHRoaXMuY29sdW1uLndpZHRoO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbbWF4V2lkdGhdID0gXCInMTUwcHgnXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIG1heFdpZHRoOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGNsYXNzIHNlbGVjdG9yIG9mIHRoZSBjb2x1bW4gaGVhZGVyLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uSGVhZGVyQ2xhc3MgPSB0aGlzLmNvbHVtbi5oZWFkZXJDbGFzc2VzO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGVhZGVyQ2xhc3Nlc10gPSBcIidjb2x1bW4taGVhZGVyJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaGVhZGVyQ2xhc3NlcyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb25kaXRpb25hbCBzdHlsZSBwcm9wZXJ0aWVzIG9uIHRoZSBjb2x1bW4gaGVhZGVyLlxuICAgICAqIFNpbWlsYXIgdG8gYG5nU3R5bGVgIGl0IGFjY2VwdHMgYW4gb2JqZWN0IGxpdGVyYWwgd2hlcmUgdGhlIGtleXMgYXJlXG4gICAgICogdGhlIHN0eWxlIHByb3BlcnRpZXMgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgZXhwcmVzc2lvbiB0byBiZSBldmFsdWF0ZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHN0eWxlcyA9IHtcbiAgICAgKiAgYmFja2dyb3VuZDogJ3JveWFsYmx1ZScsXG4gICAgICogIGNvbG9yOiAoY29sdW1uKSA9PiBjb2x1bW4ucGlubmVkID8gJ3JlZCc6ICdpbmhlcml0J1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2hlYWRlclN0eWxlc109XCJzdHlsZXNcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhlYWRlclN0eWxlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGNsYXNzIHNlbGVjdG9yIG9mIHRoZSBjb2x1bW4gZ3JvdXAgaGVhZGVyLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uSGVhZGVyQ2xhc3MgPSB0aGlzLmNvbHVtbi5oZWFkZXJHcm91cENsYXNzZXM7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtoZWFkZXJHcm91cENsYXNzZXNdID0gXCInY29sdW1uLWdyb3VwLWhlYWRlcidcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhlYWRlckdyb3VwQ2xhc3NlcyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb25kaXRpb25hbCBzdHlsZSBwcm9wZXJ0aWVzIG9uIHRoZSBjb2x1bW4gaGVhZGVyIGdyb3VwIHdyYXBwZXIuXG4gICAgICogU2ltaWxhciB0byBgbmdTdHlsZWAgaXQgYWNjZXB0cyBhbiBvYmplY3QgbGl0ZXJhbCB3aGVyZSB0aGUga2V5cyBhcmVcbiAgICAgKiB0aGUgc3R5bGUgcHJvcGVydGllcyBhbmQgdGhlIHZhbHVlIGlzIHRoZSBleHByZXNzaW9uIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogc3R5bGVzID0ge1xuICAgICAqICBiYWNrZ3JvdW5kOiAncm95YWxibHVlJyxcbiAgICAgKiAgY29sb3I6IChjb2x1bW4pID0+IGNvbHVtbi5waW5uZWQgPyAncmVkJzogJ2luaGVyaXQnXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGVhZGVyR3JvdXBTdHlsZXNdPVwic3R5bGVzXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoZWFkZXJHcm91cFN0eWxlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY29uZGl0aW9uYWwgY2xhc3Mgc2VsZWN0b3Igb2YgdGhlIGNvbHVtbiBjZWxscy5cbiAgICAgKiBBY2NlcHRzIGFuIG9iamVjdCBsaXRlcmFsLCBjb250YWluaW5nIGtleS12YWx1ZSBwYWlycyxcbiAgICAgKiB3aGVyZSB0aGUga2V5IGlzIHRoZSBuYW1lIG9mIHRoZSBDU1MgY2xhc3MsIHdoaWxlIHRoZVxuICAgICAqIHZhbHVlIGlzIGVpdGhlciBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGJvb2xlYW4sXG4gICAgICogb3IgYm9vbGVhbiwgbGlrZSBzbzpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY2FsbGJhY2sgPSAocm93RGF0YSwgY29sdW1uS2V5LCBjZWxsVmFsdWUsIHJvd0luZGV4KSA9PiB7IHJldHVybiByb3dEYXRhW2NvbHVtbktleV0gPiA2OyB9XG4gICAgICogY2VsbENsYXNzZXMgPSB7ICdjbGFzc05hbWUnIDogdGhpcy5jYWxsYmFjayB9O1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbY2VsbENsYXNzZXNdID0gXCJjZWxsQ2xhc3Nlc1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8aWd4LWNvbHVtbiBbY2VsbENsYXNzZXNdID0gXCJ7J2NsYXNzMScgOiB0cnVlIH1cIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNlbGxDbGFzc2VzOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNvbmRpdGlvbmFsIHN0eWxlIHByb3BlcnRpZXMgb24gdGhlIGNvbHVtbiBjZWxscy5cbiAgICAgKiBTaW1pbGFyIHRvIGBuZ1N0eWxlYCBpdCBhY2NlcHRzIGFuIG9iamVjdCBsaXRlcmFsIHdoZXJlIHRoZSBrZXlzIGFyZVxuICAgICAqIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGFuZCB0aGUgdmFsdWUgaXMgdGhlIGV4cHJlc3Npb24gdG8gYmUgZXZhbHVhdGVkLlxuICAgICAqIEFzIHdpdGggYGNlbGxDbGFzc2VzYCBpdCBhY2NlcHRzIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHN0eWxlcyA9IHtcbiAgICAgKiAgYmFja2dyb3VuZDogJ3JveWFsYmx1ZScsXG4gICAgICogIGNvbG9yOiAocm93RGF0YSwgY29sdW1uS2V5LCBjZWxsVmFsdWUsIHJvd0luZGV4KSA9PiB2YWx1ZS5zdGFydHNXaXRoKCdJbXBvcnRhbnQnKSA/ICdyZWQnOiAnaW5oZXJpdCdcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtjZWxsU3R5bGVzXT1cInN0eWxlc1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2VsbFN0eWxlcyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBkaXNwbGF5IGZvcm1hdCB0byBjZWxsIHZhbHVlcyBpbiB0aGUgY29sdW1uLiBEb2VzIG5vdCBtb2RpZnkgdGhlIHVuZGVybHlpbmcgZGF0YS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtcbiAgICAgKiBOb3RlOiBBcyB0aGUgZm9ybWF0dGVyIGlzIHVzZWQgaW4gcGxhY2VzIGxpa2UgdGhlIEV4Y2VsIHN0eWxlIGZpbHRlcmluZyBkaWFsb2csIGluIGNlcnRhaW5cbiAgICAgKiBzY2VuYXJpb3MgKHJlbW90ZSBmaWx0ZXJpbmcgZm9yIGV4YW1wbGUpLCB0aGUgcm93IGRhdGEgYXJndW1lbnQgY2FuIGJlIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGV4YW1wbGUsIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgY29sdW1uIG5hbWUgaXMgU2FsYXJ5LCBhbmQgdGhlbiBwcm92aWRlIGEgbWV0aG9kIGFzIHRoZSBjb2x1bW4gZm9ybWF0dGVyXG4gICAgICogdG8gZm9ybWF0IHRoZSB2YWx1ZSBpbnRvIGEgY3VycmVuY3kgc3RyaW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29sdW1uSW5pdChjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCkge1xuICAgICAqICAgaWYgKGNvbHVtbi5maWVsZCA9PSBcIlNhbGFyeVwiKSB7XG4gICAgICogICAgIGNvbHVtbi5mb3JtYXR0ZXIgPSAoc2FsYXJ5ID0+IHRoaXMuZm9ybWF0KHNhbGFyeSkpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZvcm1hdCh2YWx1ZTogbnVtYmVyKSA6IHN0cmluZyB7XG4gICAgICogICByZXR1cm4gZm9ybWF0Q3VycmVuY3kodmFsdWUsIFwiZW4tdXNcIiwgXCIkXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbHVtbiA9IHRoaXMuZ3JpZC5nZXRDb2x1bW5CeU5hbWUoJ0FkZHJlc3MnKTtcbiAgICAgKiBjb25zdCBhZGRyZXNzRm9ybWF0dGVyID0gKGFkZHJlc3M6IHN0cmluZywgcm93RGF0YTogYW55KSA9PiBkYXRhLnByaXZhY3lFbmFibGVkID8gJ3Vua25vd24nIDogYWRkcmVzcztcbiAgICAgKiBjb2x1bW4uZm9ybWF0dGVyID0gYWRkcmVzc0Zvcm1hdHRlcjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZm9ybWF0dGVyOiAodmFsdWU6IGFueSwgcm93RGF0YT86IGFueSkgPT4gYW55O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN1bW1hcnlGb3JtYXR0ZXIgaXMgdXNlZCB0byBmb3JtYXQgdGhlIGRpc3BsYXkgb2YgdGhlIGNvbHVtbiBzdW1tYXJpZXMuXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGV4YW1wbGUsIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgY29sdW1uIG5hbWUgaXMgT3JkZXJEYXRlLCBhbmQgdGhlbiBwcm92aWRlIGEgbWV0aG9kIGFzIHRoZSBzdW1tYXJ5Rm9ybWF0dGVyXG4gICAgICogdG8gY2hhbmdlIHRoZSBsb2NhbGUgZm9yIHRoZSBkYXRlcyB0byAnZnItRlInLiBUaGUgc3VtbWFyaWVzIHdpdGggdGhlIGNvdW50IGtleSBhcmUgc2tpcHBlZCBzbyB0aGV5IGFyZSBkaXNwbGF5ZWQgYXMgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb2x1bW5Jbml0KGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50KSB7XG4gICAgICogICBpZiAoY29sdW1uLmZpZWxkID09IFwiT3JkZXJEYXRlXCIpIHtcbiAgICAgKiAgICAgY29sdW1uLnN1bW1hcnlGb3JtYXR0ZXIgPSB0aGlzLnN1bW1hcnlGb3JtYXQ7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogc3VtbWFyeUZvcm1hdChzdW1tYXJ5OiBJZ3hTdW1tYXJ5UmVzdWx0LCBzdW1tYXJ5T3BlcmFuZDogSWd4U3VtbWFyeU9wZXJhbmQpOiBzdHJpbmcge1xuICAgICAqICAgY29uc3QgcmVzdWx0ID0gc3VtbWFyeS5zdW1tYXJ5UmVzdWx0O1xuICAgICAqICAgaWYoc3VtbWFyeVJlc3VsdC5rZXkgIT09ICdjb3VudCcgJiYgcmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICogICAgICBjb25zdCBwaXBlID0gbmV3IERhdGVQaXBlKCdmci1GUicpO1xuICAgICAqICAgICAgcmV0dXJuIHBpcGUudHJhbnNmb3JtKHJlc3VsdCwnbWVkaXVtRGF0ZScpO1xuICAgICAqICAgfVxuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHN1bW1hcnlGb3JtYXR0ZXI6IChzdW1tYXJ5OiBJZ3hTdW1tYXJ5UmVzdWx0LCBzdW1tYXJ5T3BlcmFuZDogSWd4U3VtbWFyeU9wZXJhbmQpID0+IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gZmlsdGVyaW5nIHNob3VsZCBiZSBjYXNlIHNlbnNpdGl2ZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGZpbHRlcmluZ0lnbm9yZUNhc2UgPSB0aGlzLmNvbHVtbi5maWx0ZXJpbmdJZ25vcmVDYXNlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZmlsdGVyaW5nSWdub3JlQ2FzZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGZpbHRlcmluZ0lnbm9yZUNhc2UgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gc29ydGluZyBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzb3J0aW5nSWdub3JlQ2FzZSA9IHRoaXMuY29sdW1uLnNvcnRpbmdJZ25vcmVDYXNlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbc29ydGluZ0lnbm9yZUNhc2VdID0gXCJmYWxzZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzb3J0aW5nSWdub3JlQ2FzZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBgc2VhcmNoYWJsZWAuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc1NlYXJjaGFibGUgPSAgdGhpcy5jb2x1bW4uc2VhcmNoYWJsZSc7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqICA8aWd4LWNvbHVtbiBbc2VhcmNoYWJsZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZWFyY2hhYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgY29sdW1uIHZhbHVlcy5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBzdHJpbmdgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uRGF0YVR5cGUgPSB0aGlzLmNvbHVtbi5kYXRhVHlwZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2RhdGFUeXBlXSA9IFwiJ251bWJlcidcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZGF0YVR5cGU6IEdyaWRDb2x1bW5EYXRhVHlwZSA9IEdyaWRDb2x1bW5EYXRhVHlwZS5TdHJpbmc7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNvbGxhcHNpYmxlSW5kaWNhdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBSb3cgaW5kZXggd2hlcmUgdGhlIGN1cnJlbnQgZmllbGQgc2hvdWxkIGVuZC5cbiAgICAgKiBUaGUgYW1vdW50IG9mIHJvd3MgYmV0d2VlbiByb3dTdGFydCBhbmQgcm93RW5kIHdpbGwgZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2Ygc3Bhbm5pbmcgcm93cyB0byB0aGF0IGZpZWxkXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiAgIDxpZ3gtY29sdW1uIFtyb3dFbmRdPVwiMlwiIFtyb3dTdGFydF09XCIxXCIgW2NvbFN0YXJ0XT1cIjFcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByb3dFbmQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIENvbHVtbiBpbmRleCB3aGVyZSB0aGUgY3VycmVudCBmaWVsZCBzaG91bGQgZW5kLlxuICAgICAqIFRoZSBhbW91bnQgb2YgY29sdW1ucyBiZXR3ZWVuIGNvbFN0YXJ0IGFuZCBjb2xFbmQgd2lsbCBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiBzcGFubmluZyBjb2x1bW5zIHRvIHRoYXQgZmllbGRcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqICAgPGlneC1jb2x1bW4gW2NvbEVuZF09XCIzXCIgW3Jvd1N0YXJ0XT1cIjFcIiBbY29sU3RhcnRdPVwiMVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNvbEVuZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogUm93IGluZGV4IGZyb20gd2hpY2ggdGhlIGZpZWxkIGlzIHN0YXJ0aW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogICA8aWd4LWNvbHVtbiBbcm93U3RhcnRdPVwiMVwiIFtjb2xTdGFydF09XCIxXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDwvaWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgcm93U3RhcnQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIENvbHVtbiBpbmRleCBmcm9tIHdoaWNoIHRoZSBmaWVsZCBpcyBzdGFydGluZy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqICAgPGlneC1jb2x1bW4gW2NvbFN0YXJ0XT1cIjFcIiBbcm93U3RhcnRdPVwiMVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNvbFN0YXJ0OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgY3VzdG9tIHByb3BlcnRpZXMgcHJvdmlkZWQgaW4gYWRkaXRpb25hbCB0ZW1wbGF0ZSBjb250ZXh0LlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFthZGRpdGlvbmFsVGVtcGxhdGVDb250ZXh0XT1cImNvbnRleHRPYmplY3RcIj5cbiAgICAgKiAgIDxuZy10ZW1wbGF0ZSBpZ3hDZWxsIGxldC1jZWxsPVwiY2VsbFwiIGxldC1wcm9wcz1cImFkZGl0aW9uYWxUZW1wbGF0ZUNvbnRleHRcIj5cbiAgICAgKiAgICAgIHt7IHByb3BzIH19XG4gICAgICogICA8L25nLXRlbXBsYXRlPlxuICAgICAqIDwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBhZGRpdGlvbmFsVGVtcGxhdGVDb250ZXh0OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHdpZHRoQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHBpbm5lZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hGaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4RmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlIH0pXG4gICAgcHVibGljIGZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZTogSWd4RmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneFN1bW1hcnlUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hTdW1tYXJ5VGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwcm90ZWN0ZWQgc3VtbWFyeVRlbXBsYXRlRGlyZWN0aXZlOiBJZ3hTdW1tYXJ5VGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4Q2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneENlbGxUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHByb3RlY3RlZCBjZWxsVGVtcGxhdGU6IElneENlbGxUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hDZWxsVmFsaWRhdGlvbkVycm9yRGlyZWN0aXZlLCB7IHJlYWQ6IElneENlbGxWYWxpZGF0aW9uRXJyb3JEaXJlY3RpdmUgfSlcbiAgICBwcm90ZWN0ZWQgY2VsbFZhbGlkYXRpb25FcnJvclRlbXBsYXRlOiBJZ3hDZWxsVmFsaWRhdGlvbkVycm9yRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKElneENlbGxIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hDZWxsSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsIGRlc2NlbmRhbnRzOiBmYWxzZSB9KVxuICAgIHByb3RlY3RlZCBoZWFkVGVtcGxhdGU6IFF1ZXJ5TGlzdDxJZ3hDZWxsSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmU+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneENlbGxFZGl0b3JUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hDZWxsRWRpdG9yVGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwcm90ZWN0ZWQgZWRpdG9yVGVtcGxhdGU6IElneENlbGxFZGl0b3JUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hDb2xsYXBzaWJsZUluZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneENvbGxhcHNpYmxlSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUsIHN0YXRpYzogZmFsc2UgfSlcbiAgICBwcm90ZWN0ZWQgY29sbGFwc2VJbmRpY2F0b3JUZW1wbGF0ZTogSWd4Q29sbGFwc2libGVJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBjYWxjV2lkdGgoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FsY1dpZHRoKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGNhbGNQaXhlbFdpZHRoOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtYXhXaWR0aFB4KCkge1xuICAgICAgICBjb25zdCBncmlkQXZhaWxhYmxlU2l6ZSA9IHRoaXMuZ3JpZC5jYWxjV2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gdGhpcy5tYXhXaWR0aCAmJiB0eXBlb2YgdGhpcy5tYXhXaWR0aCA9PT0gJ3N0cmluZycgJiYgdGhpcy5tYXhXaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuICAgICAgICByZXR1cm4gaXNQZXJjZW50YWdlV2lkdGggPyBwYXJzZUZsb2F0KHRoaXMubWF4V2lkdGgpIC8gMTAwICogZ3JpZEF2YWlsYWJsZVNpemUgOiBwYXJzZUZsb2F0KHRoaXMubWF4V2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heFdpZHRoUGVyY2VudCgpIHtcbiAgICAgICAgY29uc3QgZ3JpZEF2YWlsYWJsZVNpemUgPSB0aGlzLmdyaWQuY2FsY1dpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IHRoaXMubWF4V2lkdGggJiYgdHlwZW9mIHRoaXMubWF4V2lkdGggPT09ICdzdHJpbmcnICYmIHRoaXMubWF4V2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIGlzUGVyY2VudGFnZVdpZHRoID8gcGFyc2VGbG9hdCh0aGlzLm1heFdpZHRoKSA6IHBhcnNlRmxvYXQodGhpcy5tYXhXaWR0aCkgLyBncmlkQXZhaWxhYmxlU2l6ZSAqIDEwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtaW5XaWR0aFB4KCkge1xuICAgICAgICBjb25zdCBncmlkQXZhaWxhYmxlU2l6ZSA9IHRoaXMuZ3JpZC5jYWxjV2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gdGhpcy5taW5XaWR0aCAmJiB0eXBlb2YgdGhpcy5taW5XaWR0aCA9PT0gJ3N0cmluZycgJiYgdGhpcy5taW5XaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuICAgICAgICByZXR1cm4gaXNQZXJjZW50YWdlV2lkdGggPyBwYXJzZUZsb2F0KHRoaXMubWluV2lkdGgpIC8gMTAwICogZ3JpZEF2YWlsYWJsZVNpemUgOiBwYXJzZUZsb2F0KHRoaXMubWluV2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1pbldpZHRoUGVyY2VudCgpIHtcbiAgICAgICAgY29uc3QgZ3JpZEF2YWlsYWJsZVNpemUgPSB0aGlzLmdyaWQuY2FsY1dpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IHRoaXMubWluV2lkdGggJiYgdHlwZW9mIHRoaXMubWluV2lkdGggPT09ICdzdHJpbmcnICYmIHRoaXMubWluV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIGlzUGVyY2VudGFnZVdpZHRoID8gcGFyc2VGbG9hdCh0aGlzLm1pbldpZHRoKSA6IHBhcnNlRmxvYXQodGhpcy5taW5XaWR0aCkgLyBncmlkQXZhaWxhYmxlU2l6ZSAqIDEwMDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgbWluaW11bSBgd2lkdGhgIG9mIHRoZSBjb2x1bW4uXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgODhgO1xuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uTWluV2lkdGggPSB0aGlzLmNvbHVtbi5taW5XaWR0aDtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW21pbldpZHRoXSA9IFwiJzEwMHB4J1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IG1pbldpZHRoKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbWluVmFsID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4obWluVmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlZmF1bHRNaW5XaWR0aCA9IHZhbHVlO1xuXG4gICAgfVxuICAgIHB1YmxpYyBnZXQgbWluV2lkdGgoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9kZWZhdWx0TWluV2lkdGggPyB0aGlzLmRlZmF1bHRNaW5XaWR0aCA6IHRoaXMuX2RlZmF1bHRNaW5XaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gaW5kZXguXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5JbmRleCA9IHRoaXMuY29sdW1uLmluZGV4O1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdyaWQgYXMgYW55KS5fY29sdW1ucy5pbmRleE9mKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGBwaW5uZWRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNQaW5uZWQgPSB0aGlzLmNvbHVtbi5waW5uZWQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHBpbm5lZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpbm5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgcGlubmVkLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3Bpbm5lZF0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUd28td2F5IGRhdGEgYmluZGluZy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gWyhwaW5uZWQpXSA9IFwibW9kZWwuY29sdW1uc1swXS5pc1Bpbm5lZFwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHBpbm5lZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5fcGlubmVkICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgaXNBdXRvV2lkdGggPSB0aGlzLndpZHRoICYmIHR5cGVvZiB0aGlzLndpZHRoID09PSAnc3RyaW5nJyAmJiB0aGlzLndpZHRoID09PSAnZml0LWNvbnRlbnQnO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZCAmJiB0aGlzLndpZHRoICYmIChpc0F1dG9XaWR0aCB8fCAhaXNOYU4ocGFyc2VJbnQodGhpcy53aWR0aCwgMTApKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waW4oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVucGluKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIE5vIGdyaWQvd2lkdGggYXZhaWxhYmxlIGF0IGluaXRpYWxpemF0aW9uLiBgaW5pdFBpbm5pbmdgIGluIHRoZSBncmlkXG4gICAgICAgICAgICAgICB3aWxsIHJlLWluaXQgdGhlIGdyb3VwIChpZiBwcmVzZW50KVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3Bpbm5lZCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5waW5uZWRDaGFuZ2UuZW1pdCh0aGlzLl9waW5uZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sdW1uIGBzdW1tYXJpZXNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uU3VtbWFyaWVzID0gdGhpcy5jb2x1bW4uc3VtbWFyaWVzO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKHRydWUpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHN1bW1hcmllcygpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VtbWFyaWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gYHN1bW1hcmllc2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLnN1bW1hcmllcyA9IElneE51bWJlclN1bW1hcnlPcGVyYW5kO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc3VtbWFyaWVzKGNsYXNzUmVmOiBhbnkpIHtcbiAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IoY2xhc3NSZWYpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdW1tYXJpZXMgPSBuZXcgY2xhc3NSZWYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5U2VydmljZS5yZW1vdmVTdW1tYXJpZXNDYWNoZVBlckNvbHVtbih0aGlzLmZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5UGlwZVRyaWdnZXIrKztcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5U2VydmljZS5yZXNldFN1bW1hcnlIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gYGZpbHRlcnNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uRmlsdGVycyA9IHRoaXMuY29sdW1uLmZpbHRlcnMnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGZpbHRlcnMoKTogSWd4RmlsdGVyaW5nT3BlcmFuZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gYGZpbHRlcnNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5maWx0ZXJzID0gSWd4Qm9vbGVhbkZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKS5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGZpbHRlcnMoaW5zdGFuY2U6IElneEZpbHRlcmluZ09wZXJhbmQpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVycyA9IGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gYHNvcnRTdHJhdGVneWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzb3J0U3RyYXRlZ3kgPSB0aGlzLmNvbHVtbi5zb3J0U3RyYXRlZ3lcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgc29ydFN0cmF0ZWd5KCk6IElTb3J0aW5nU3RyYXRlZ3kge1xuICAgICAgICByZXR1cm4gdGhpcy5fc29ydFN0cmF0ZWd5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gYHNvcnRTdHJhdGVneWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLnNvcnRTdHJhdGVneSA9IG5ldyBDdXN0b21Tb3J0aW5nU3RyYXRlZ3koKS5cbiAgICAgKiBjbGFzcyBDdXN0b21Tb3J0aW5nU3RyYXRlZ3kgZXh0ZW5kcyBTb3J0aW5nU3RyYXRlZ3kgey4uLn1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHNvcnRTdHJhdGVneShjbGFzc1JlZjogSVNvcnRpbmdTdHJhdGVneSkge1xuICAgICAgICB0aGlzLl9zb3J0U3RyYXRlZ3kgPSBjbGFzc1JlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZnVuY3Rpb24gdGhhdCBjb21wYXJlcyB2YWx1ZXMgZm9yIGdyb3VwaW5nLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZ3JvdXBpbmdDb21wYXJlciA9IHRoaXMuY29sdW1uLmdyb3VwaW5nQ29tcGFyZXInXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGdyb3VwaW5nQ29tcGFyZXIoKTogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBpbmdDb21wYXJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGN1c3RvbSBmdW5jdGlvbiB0byBjb21wYXJlIHZhbHVlcyBmb3IgZ3JvdXBpbmcuXG4gICAgICogU3Vic2VxdWVudCB2YWx1ZXMgaW4gdGhlIHNvcnRlZCBkYXRhIHRoYXQgdGhlIGZ1bmN0aW9uIHJldHVybnMgMCBmb3IgYXJlIGdyb3VwZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLmdyb3VwaW5nQ29tcGFyZXIgPSAoYTogYW55LCBiOiBhbnkpID0+IHsgcmV0dXJuIGEgPT09IGIgPyAwIDogLTE7IH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGdyb3VwaW5nQ29tcGFyZXIoZnVuY1JlZjogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBpbmdDb21wYXJlciA9IGZ1bmNSZWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRlZmF1bHQgbWluaW11bSBgd2lkdGhgIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBkZWZhdWx0TWluV2lkdGggPSAgdGhpcy5jb2x1bW4uZGVmYXVsdE1pbldpZHRoO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZGVmYXVsdE1pbldpZHRoKCk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdGhpcy5ncmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJzgwJztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuZ3JpZC5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb3N5OlxuICAgICAgICAgICAgICAgIHJldHVybiAnNjQnO1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnNTYnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJzgwJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgc3VtbWFyeVRlbXBsYXRlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHN1bW1hcnlUZW1wbGF0ZSA9IHRoaXMuY29sdW1uLnN1bW1hcnlUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHN1bW1hcnlUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxJZ3hTdW1tYXJ5VGVtcGxhdGVDb250ZXh0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdW1tYXJ5VGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN1bW1hcnkgdGVtcGxhdGUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjc3VtbWFyeVRlbXBsYXRlIGlneFN1bW1hcnkgbGV0LXN1bW1hcnlSZXN1bHRzPlxuICAgICAqICAgIDxwPnt7IHN1bW1hcnlSZXN1bHRzWzBdLmxhYmVsIH19OiB7eyBzdW1tYXJ5UmVzdWx0c1swXS5zdW1tYXJ5UmVzdWx0IH19PC9wPlxuICAgICAqICAgIDxwPnt7IHN1bW1hcnlSZXN1bHRzWzFdLmxhYmVsIH19OiB7eyBzdW1tYXJ5UmVzdWx0c1sxXS5zdW1tYXJ5UmVzdWx0IH19PC9wPlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCInc3VtbWFyeVRlbXBsYXRlJ1wiLCB7cmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICAgKiBwdWJsaWMgc3VtbWFyeVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgICAqIHRoaXMuY29sdW1uLnN1bW1hcnlUZW1wbGF0ZSA9IHRoaXMuc3VtbWFyeVRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc3VtbWFyeVRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJZ3hTdW1tYXJ5VGVtcGxhdGVDb250ZXh0Pikge1xuICAgICAgICB0aGlzLl9zdW1tYXJ5VGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgYm9keVRlbXBsYXRlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGJvZHlUZW1wbGF0ZSA9IHRoaXMuY29sdW1uLmJvZHlUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KCdjZWxsVGVtcGxhdGUnKVxuICAgIHB1YmxpYyBnZXQgYm9keVRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPElneENlbGxUZW1wbGF0ZUNvbnRleHQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHlUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm9keSB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNib2R5VGVtcGxhdGUgaWd4Q2VsbCBsZXQtdmFsPlxuICAgICAqICAgIDxkaXYgc3R5bGUgPSBcImJhY2tncm91bmQtY29sb3I6IHllbGxvd2dyZWVuXCIgKGNsaWNrKSA9IFwiY2hhbmdlQ29sb3IodmFsKVwiPlxuICAgICAqICAgICAgIDxzcGFuPiB7e3ZhbH19IDwvc3Bhbj5cbiAgICAgKiAgICA8L2Rpdj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiJ2JvZHlUZW1wbGF0ZSdcIiwge3JlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIGJvZHlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAgKiB0aGlzLmNvbHVtbi5ib2R5VGVtcGxhdGUgPSB0aGlzLmJvZHlUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGJvZHlUZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8SWd4Q2VsbFRlbXBsYXRlQ29udGV4dD4pIHtcbiAgICAgICAgdGhpcy5fYm9keVRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGhlYWRlciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGhlYWRlclRlbXBsYXRlID0gdGhpcy5jb2x1bW4uaGVhZGVyVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBoZWFkZXJUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxJZ3hDb2x1bW5UZW1wbGF0ZUNvbnRleHQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlclRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoZWFkZXIgdGVtcGxhdGUuXG4gICAgICogTm90ZSB0aGF0IHRoZSBjb2x1bW4gaGVhZGVyIGhlaWdodCBpcyBmaXhlZCBhbmQgYW55IGNvbnRlbnQgYmlnZ2VyIHRoYW4gaXQgd2lsbCBiZSBjdXQgb2ZmLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgI2hlYWRlclRlbXBsYXRlPlxuICAgICAqICAgPGRpdiBzdHlsZSA9IFwiYmFja2dyb3VuZC1jb2xvcjpibGFja1wiIChjbGljaykgPSBcImNoYW5nZUNvbG9yKHZhbClcIj5cbiAgICAgKiAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZFwiID57e2NvbHVtbi5maWVsZH19PC9zcGFuPlxuICAgICAqICAgPC9kaXY+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIidoZWFkZXJUZW1wbGF0ZSdcIiwge3JlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIGhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgICAqIHRoaXMuY29sdW1uLmhlYWRlclRlbXBsYXRlID0gdGhpcy5oZWFkZXJUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGhlYWRlclRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJZ3hDb2x1bW5UZW1wbGF0ZUNvbnRleHQ+KSB7XG4gICAgICAgIHRoaXMuX2hlYWRlclRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGlubGluZSBlZGl0b3IgdGVtcGxhdGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpbmxpbmVFZGl0b3JUZW1wbGF0ZSA9IHRoaXMuY29sdW1uLmlubGluZUVkaXRvclRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoJ2NlbGxFZGl0b3JUZW1wbGF0ZScpXG4gICAgcHVibGljIGdldCBpbmxpbmVFZGl0b3JUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxJZ3hDZWxsVGVtcGxhdGVDb250ZXh0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmxpbmVFZGl0b3JUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5saW5lIGVkaXRvciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNpbmxpbmVFZGl0b3JUZW1wbGF0ZSBpZ3hDZWxsRWRpdG9yIGxldC1jZWxsPVwiY2VsbFwiPlxuICAgICAqICAgICA8aW5wdXQgdHlwZT1cInN0cmluZ1wiIFsobmdNb2RlbCldPVwiY2VsbC52YWx1ZVwiLz5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiJ2lubGluZUVkaXRvclRlbXBsYXRlJ1wiLCB7cmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICAgKiBwdWJsaWMgaW5saW5lRWRpdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgICogdGhpcy5jb2x1bW4uaW5saW5lRWRpdG9yVGVtcGxhdGUgPSB0aGlzLmlubGluZUVkaXRvclRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgaW5saW5lRWRpdG9yVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneENlbGxUZW1wbGF0ZUNvbnRleHQ+KSB7XG4gICAgICAgIHRoaXMuX2lubGluZUVkaXRvclRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgdmFsaWRhdGlvbiBlcnJvciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGVycm9yVGVtcGxhdGUgPSB0aGlzLmNvbHVtbi5lcnJvclRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoJ2Vycm9yVGVtcGxhdGUnKVxuICAgIHB1YmxpYyBnZXQgZXJyb3JUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxJZ3hDZWxsVGVtcGxhdGVDb250ZXh0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvclRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlcnJvciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlIGlneENlbGxWYWxpZGF0aW9uRXJyb3IgbGV0LWNlbGw9XCJjZWxsXCIgI2Vycm9yVGVtcGxhdGUgPlxuICAgICAqICAgICA8ZGl2ICpuZ0lmPVwiY2VsbC52YWxpZGF0aW9uLmVycm9ycz8uWydmb3JiaWRkZW5OYW1lJ11cIj5cbiAgICAgKiAgICAgIFRoaXMgbmFtZSBpcyBmb3JiaWRkZW4uXG4gICAgICogICAgIDwvZGl2PlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCInZXJyb3JUZW1wbGF0ZSdcIiwge3JlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIGVycm9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgICogdGhpcy5jb2x1bW4uZXJyb3JUZW1wbGF0ZSA9IHRoaXMuZXJyb3JUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGVycm9yVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneENlbGxUZW1wbGF0ZUNvbnRleHQ+KSB7XG4gICAgICAgIHRoaXMuX2Vycm9yVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgZmlsdGVyQ2VsbFRlbXBsYXRlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGZpbHRlckNlbGxUZW1wbGF0ZSA9IHRoaXMuY29sdW1uLmZpbHRlckNlbGxUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KCdmaWx0ZXJDZWxsVGVtcGxhdGUnKVxuICAgIHB1YmxpYyBnZXQgZmlsdGVyQ2VsbFRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPElneENvbHVtblRlbXBsYXRlQ29udGV4dD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyQ2VsbFRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBxdWljayBmaWx0ZXIgdGVtcGxhdGUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjZmlsdGVyQ2VsbFRlbXBsYXRlIElneEZpbHRlckNlbGxUZW1wbGF0ZSBsZXQtY29sdW1uPVwiY29sdW1uXCI+XG4gICAgICogICAgPGlucHV0IChpbnB1dCk9XCJvbklucHV0KClcIj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiJ2ZpbHRlckNlbGxUZW1wbGF0ZSdcIiwge3JlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIGZpbHRlckNlbGxUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAgKiB0aGlzLmNvbHVtbi5maWx0ZXJDZWxsVGVtcGxhdGUgPSB0aGlzLmZpbHRlckNlbGxUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGZpbHRlckNlbGxUZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8SWd4Q29sdW1uVGVtcGxhdGVDb250ZXh0Pikge1xuICAgICAgICB0aGlzLl9maWx0ZXJDZWxsVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZWxscyBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uQ2VsbHMgPSB0aGlzLmNvbHVtbi5jZWxscztcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY2VsbHMoKTogQ2VsbFR5cGVbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZGF0YVZpZXdcbiAgICAgICAgICAgIC5tYXAoKHJlYywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ3JpZC5pc0dyb3VwQnlSZWNvcmQocmVjKSAmJiAhdGhpcy5ncmlkLmlzU3VtbWFyeVJvdyhyZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5wYWdpbmdNb2RlID09PSAxICYmIHRoaXMuZ3JpZC5wYWdpbmF0b3IucGFnZSAhPT0gMCA/IGluZGV4ID0gaW5kZXggKyB0aGlzLmdyaWQucGFnaW5hdG9yLnBlclBhZ2UgKiB0aGlzLmdyaWQucGFnaW5hdG9yLnBhZ2UgOiBpbmRleCA9IHRoaXMuZ3JpZC5kYXRhUm93TGlzdC5maXJzdC5pbmRleCArIGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gbmV3IElneEdyaWRDZWxsKHRoaXMuZ3JpZCBhcyBhbnksIGluZGV4LCB0aGlzLmZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuZmlsdGVyKGNlbGwgPT4gY2VsbCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgX2NlbGxzKCk6IENlbGxUeXBlW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnJvd0xpc3QuZmlsdGVyKChyb3cpID0+IHJvdyBpbnN0YW5jZW9mIElneFJvd0RpcmVjdGl2ZSlcbiAgICAgICAgICAgIC5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuX2NlbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3cuX2NlbGxzLmZpbHRlcigoY2VsbCkgPT4gY2VsbC5jb2x1bW5JbmRleCA9PT0gdGhpcy5pbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiB2aXNpYmxlIGluZGV4LlxuICAgICAqIElmIHRoZSBjb2x1bW4gaXMgbm90IHZpc2libGUsIHJldHVybnMgYC0xYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHZpc2libGVDb2x1bW5JbmRleCA9ICB0aGlzLmNvbHVtbi52aXNpYmxlSW5kZXg7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCB2aXNpYmxlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCFpc05hTih0aGlzLl92SW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdkluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVucGlubmVkQ29sdW1ucyA9IHRoaXMuZ3JpZC51bnBpbm5lZENvbHVtbnMuZmlsdGVyKGMgPT4gIWMuY29sdW1uR3JvdXApO1xuICAgICAgICBjb25zdCBwaW5uZWRDb2x1bW5zID0gdGhpcy5ncmlkLnBpbm5lZENvbHVtbnMuZmlsdGVyKGMgPT4gIWMuY29sdW1uR3JvdXApO1xuICAgICAgICBsZXQgY29sID0gdGhpcztcbiAgICAgICAgbGV0IHZJbmRleCA9IC0xO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICBjb2wgPSB0aGlzLmFsbENoaWxkcmVuLmZpbHRlcihjID0+ICFjLmNvbHVtbkdyb3VwICYmICFjLmhpZGRlbilbMF0gYXMgYW55O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dENoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGRyZW5WaXNpYmxlSW5kZXhlcy5maW5kKHggPT4geC5jb2x1bW4gPT09IHRoaXMpLmluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnBpbm5lZCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhJbkNvbGxlY3Rpb24gPSB1bnBpbm5lZENvbHVtbnMuaW5kZXhPZihjb2wpO1xuICAgICAgICAgICAgdkluZGV4ID0gaW5kZXhJbkNvbGxlY3Rpb24gPT09IC0xID9cbiAgICAgICAgICAgICAgICAtMSA6XG4gICAgICAgICAgICAgICAgKHRoaXMuZ3JpZC5pc1Bpbm5pbmdUb1N0YXJ0ID9cbiAgICAgICAgICAgICAgICAgICAgcGlubmVkQ29sdW1ucy5sZW5ndGggKyBpbmRleEluQ29sbGVjdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgIGluZGV4SW5Db2xsZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4SW5Db2xsZWN0aW9uID0gcGlubmVkQ29sdW1ucy5pbmRleE9mKGNvbCk7XG4gICAgICAgICAgICB2SW5kZXggPSB0aGlzLmdyaWQuaXNQaW5uaW5nVG9TdGFydCA/XG4gICAgICAgICAgICAgICAgaW5kZXhJbkNvbGxlY3Rpb24gOlxuICAgICAgICAgICAgICAgIHVucGlubmVkQ29sdW1ucy5sZW5ndGggKyBpbmRleEluQ29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92SW5kZXggPSB2SW5kZXg7XG4gICAgICAgIHJldHVybiB2SW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGNvbHVtbiBpcyBhIGBDb2x1bW5Hcm91cGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5Hcm91cCA9ICB0aGlzLmNvbHVtbi5jb2x1bW5Hcm91cDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNvbHVtbkdyb3VwKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGNvbHVtbiBpcyBhIGBDb2x1bW5MYXlvdXRgIGZvciBtdWx0aS1yb3cgbGF5b3V0LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uR3JvdXAgPSAgdGhpcy5jb2x1bW4uY29sdW1uR3JvdXA7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBjb2x1bW5MYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBjb2x1bW4gaXMgYSBjaGlsZCBvZiBhIGBDb2x1bW5MYXlvdXRgIGZvciBtdWx0aS1yb3cgbGF5b3V0LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uTGF5b3V0Q2hpbGQgPSAgdGhpcy5jb2x1bW4uY29sdW1uTGF5b3V0Q2hpbGQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBjb2x1bW5MYXlvdXRDaGlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNvbHVtbkxheW91dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjaGlsZHJlbiBjb2x1bW5zIGNvbGxlY3Rpb24uXG4gICAgICogUmV0dXJucyBhbiBlbXB0eSBhcnJheSBpZiB0aGUgY29sdW1uIGRvZXMgbm90IGNvbnRhaW4gY2hpbGRyZW4gY29sdW1ucy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNoaWxkcmVuQ29sdW1ucyA9ICB0aGlzLmNvbHVtbi5hbGxDaGlsZHJlbjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGFsbENoaWxkcmVuKCk6IElneENvbHVtbkNvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZXZlbCBvZiB0aGUgY29sdW1uIGluIGEgY29sdW1uIGdyb3VwLlxuICAgICAqIFJldHVybnMgYDBgIGlmIHRoZSBjb2x1bW4gZG9lc24ndCBoYXZlIGEgYHBhcmVudGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5MZXZlbCA9ICB0aGlzLmNvbHVtbi5sZXZlbDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxldmVsKCkge1xuICAgICAgICBsZXQgcHRyID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGxldCBsdmwgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwdHIpIHtcbiAgICAgICAgICAgIGx2bCsrO1xuICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbHZsO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaXNMYXN0UGlubmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmlzUGlubmluZ1RvU3RhcnQgJiZcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5waW5uZWRDb2x1bW5zW3RoaXMuZ3JpZC5waW5uZWRDb2x1bW5zLmxlbmd0aCAtIDFdID09PSB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaXNGaXJzdFBpbm5lZCgpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgcGlubmVkQ29scyA9IHRoaXMuZ3JpZC5waW5uZWRDb2x1bW5zLmZpbHRlcih4ID0+ICF4LmNvbHVtbkdyb3VwKTtcbiAgICAgICAgcmV0dXJuICF0aGlzLmdyaWQuaXNQaW5uaW5nVG9TdGFydCAmJiBwaW5uZWRDb2xzWzBdID09PSB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgcmlnaHRQaW5uZWRPZmZzZXQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlubmVkICYmICF0aGlzLmdyaWQuaXNQaW5uaW5nVG9TdGFydCA/XG4gICAgICAgICAgICAtIHRoaXMuZ3JpZC5waW5uZWRXaWR0aCAtIHRoaXMuZ3JpZC5oZWFkZXJGZWF0dXJlc1dpZHRoICsgJ3B4JyA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZ3JpZFJvd1NwYW4oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93RW5kICYmIHRoaXMucm93U3RhcnQgPyB0aGlzLnJvd0VuZCAtIHRoaXMucm93U3RhcnQgOiAxO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0IGdyaWRDb2x1bW5TcGFuKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbEVuZCAmJiB0aGlzLmNvbFN0YXJ0ID8gdGhpcy5jb2xFbmQgLSB0aGlzLmNvbFN0YXJ0IDogMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY29sdW1uIHdpbGwgYmUgdmlzaWJsZSB3aGVuIGl0cyBwYXJlbnQgaXMgY29sbGFwc2VkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbi1ncm91cD5cbiAgICAgKiAgIDxpZ3gtY29sdW1uIFt2aXNpYmxlV2hlbkNvbGxhcHNlZF09XCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDwvaWd4LWNvbHVtbi1ncm91cD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcyh0cnVlKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCB2aXNpYmxlV2hlbkNvbGxhcHNlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl92aXNpYmxlV2hlbkNvbGxhcHNlZCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnZpc2libGVXaGVuQ29sbGFwc2VkQ2hhbmdlLmVtaXQodGhpcy5fdmlzaWJsZVdoZW5Db2xsYXBzZWQpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnNldEV4cGFuZENvbGxhcHNlU3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgdmlzaWJsZVdoZW5Db2xsYXBzZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlV2hlbkNvbGxhcHNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFBhc3Mgb3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgRGF0ZVBpcGUgYW5kL29yIERlY2ltYWxQaXBlIHRvIGZvcm1hdCB0aGUgZGlzcGxheSB2YWx1ZSBmb3IgZGF0ZSBhbmQgbnVtZXJpYyBjb2x1bW5zLlxuICAgICAqIEFjY2VwdHMgYW4gYElDb2x1bW5QaXBlQXJnc2Agb2JqZWN0IHdpdGggYW55IG9mIHRoZSBgZm9ybWF0YCwgYHRpbWV6b25lYCBhbmQgYGRpZ2l0c0luZm9gIHByb3BlcnRpZXMuXG4gICAgICogRm9yIG1vcmUgZGV0YWlscyBzZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9jb21tb24vRGF0ZVBpcGUgYW5kIGh0dHBzOi8vYW5ndWxhci5pby9hcGkvY29tbW9uL0RlY2ltYWxQaXBlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcGlwZUFyZ3M6IElDb2x1bW5QaXBlQXJncyA9IHtcbiAgICAgKiAgICAgIGZvcm1hdDogJ2xvbmdEYXRlJyxcbiAgICAgKiAgICAgIHRpbWV6b25lOiAnVVRDJyxcbiAgICAgKiAgICAgIGRpZ2l0c0luZm86ICcxLjEtMidcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIGRhdGFUeXBlPVwiZGF0ZVwiIFtwaXBlQXJnc109XCJwaXBlQXJnc1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8aWd4LWNvbHVtbiBkYXRhVHlwZT1cIm51bWJlclwiIFtwaXBlQXJnc109XCJwaXBlQXJnc1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBwaXBlQXJncyh2YWx1ZTogSUNvbHVtblBpcGVBcmdzKSB7XG4gICAgICAgIHRoaXMuX2NvbHVtblBpcGVBcmdzID0gT2JqZWN0LmFzc2lnbih0aGlzLl9jb2x1bW5QaXBlQXJncywgdmFsdWUpO1xuICAgICAgICB0aGlzLmdyaWQuc3VtbWFyeVNlcnZpY2UuY2xlYXJTdW1tYXJ5Q2FjaGUoKTtcbiAgICAgICAgdGhpcy5ncmlkLnBpcGVUcmlnZ2VyKys7XG4gICAgfVxuICAgIHB1YmxpYyBnZXQgcGlwZUFyZ3MoKTogSUNvbHVtblBpcGVBcmdzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtblBpcGVBcmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNvbGxhcHNpYmxlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgY29sbGFwc2libGUoX3ZhbHVlOiBib29sZWFuKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcHVibGljIHNldCBleHBhbmRlZChfdmFsdWU6IGJvb2xlYW4pIHsgfVxuXG4gICAgLyoqXG4gICAgICogaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGRlZmF1bHRXaWR0aDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHdpZHRoU2V0QnlVc2VyOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBoYXNOZXN0ZWRQYXRoOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBkZWZhdWx0VGltZUZvcm1hdCA9ICdoaDptbTpzcyB0dCc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGRlZmF1bHREYXRlVGltZUZvcm1hdCA9ICdkZC9NTS95eXl5IEhIOm1tOnNzIHR0JztcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB0cmVlID0gIHRoaXMuY29sdW1uLmZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSgpOiBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZS5maW5kKHRoaXMuZmllbGQpIGFzIEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBwYXJlbnQgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgcGFyZW50Q29sdW1uID0gdGhpcy5jb2x1bW4ucGFyZW50O1xuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5wYXJlbnQgPSBoaWdoZXJMZXZlbENvbHVtbjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgcGFyZW50ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGNoaWxkcmVuIGNvbHVtbnMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5DaGlsZHJlbiA9IHRoaXMuY29sdW1uLmNoaWxkcmVuO1xuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5jaGlsZHJlbiA9IGNoaWxkcmVuQ29sdW1ucztcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgY2hpbGRyZW46IFF1ZXJ5TGlzdDxJZ3hDb2x1bW5Db21wb25lbnQ+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZGVzdHJveSQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9hcHBseVNlbGVjdGFibGVDbGFzcyA9IGZhbHNlO1xuXG4gICAgcHJvdGVjdGVkIF92SW5kZXggPSBOYU47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfcGlubmVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJZ3hDZWxsVGVtcGxhdGVDb250ZXh0PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9lcnJvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJZ3hDZWxsVGVtcGxhdGVDb250ZXh0PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9oZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8SWd4Q29sdW1uVGVtcGxhdGVDb250ZXh0PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zdW1tYXJ5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneFN1bW1hcnlUZW1wbGF0ZUNvbnRleHQ+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2lubGluZUVkaXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJZ3hDZWxsVGVtcGxhdGVDb250ZXh0PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9maWx0ZXJDZWxsVGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneENvbHVtblRlbXBsYXRlQ29udGV4dD47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfc3VtbWFyaWVzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9maWx0ZXJzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zb3J0U3RyYXRlZ3k6IElTb3J0aW5nU3RyYXRlZ3kgPSBEZWZhdWx0U29ydGluZ1N0cmF0ZWd5Lmluc3RhbmNlKCk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ3JvdXBpbmdDb21wYXJlcjogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaGlkZGVuID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaW5kZXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kaXNhYmxlUGlubmluZyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3dpZHRoOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZGVmYXVsdE1pbldpZHRoID0gJyc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaGFzU3VtbWFyeSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2VkaXRhYmxlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqICBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF92aXNpYmxlV2hlbkNvbGxhcHNlZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jb2xsYXBzaWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2V4cGFuZGVkID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldCBpc1ByaW1hcnlDb2x1bW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ncmlkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWVsZCA9PT0gdGhpcy5ncmlkLnByaW1hcnlLZXk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZmllbGQ6IHN0cmluZztcbiAgICBwcml2YXRlIF9jYWxjV2lkdGggPSBudWxsO1xuICAgIHByaXZhdGUgX2NvbHVtblBpcGVBcmdzOiBJQ29sdW1uUGlwZUFyZ3MgPSB7IGRpZ2l0c0luZm86IERFRkFVTFRfRElHSVRTX0lORk8gfTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KElHWF9HUklEX0JBU0UpIHB1YmxpYyBncmlkOiBHcmlkVHlwZSxcbiAgICAgICAgQE9wdGlvbmFsKCkgQFNlbGYoKSBASW5qZWN0KE5HX1ZBTElEQVRPUlMpIHByaXZhdGUgX3ZhbGlkYXRvcnM6IFZhbGlkYXRvcltdLFxuICAgICAgICBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJvdGVjdGVkIHBsYXRmb3JtOiBQbGF0Zm9ybVV0aWwsXG4gICAgKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdG9ycyAgPSBfdmFsaWRhdG9ycztcbiAgICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyByZXNldENhY2hlcygpIHtcbiAgICAgICAgdGhpcy5fdkluZGV4ID0gTmFOO1xuICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlQ2FsY1dpZHRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN1bW1hcnlUZW1wbGF0ZURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3VtbWFyeVRlbXBsYXRlID0gdGhpcy5zdW1tYXJ5VGVtcGxhdGVEaXJlY3RpdmUudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2VsbFRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9ib2R5VGVtcGxhdGUgPSB0aGlzLmNlbGxUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jZWxsVmFsaWRhdGlvbkVycm9yVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yVGVtcGxhdGUgPSB0aGlzLmNlbGxWYWxpZGF0aW9uRXJyb3JUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWFkVGVtcGxhdGUgJiYgdGhpcy5oZWFkVGVtcGxhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJUZW1wbGF0ZSA9IHRoaXMuaGVhZFRlbXBsYXRlLnRvQXJyYXkoKVswXS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3JUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5faW5saW5lRWRpdG9yVGVtcGxhdGUgPSB0aGlzLmVkaXRvclRlbXBsYXRlLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyQ2VsbFRlbXBsYXRlID0gdGhpcy5maWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jb2x1bW5QaXBlQXJncy5mb3JtYXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtblBpcGVBcmdzLmZvcm1hdCA9IHRoaXMuZGF0YVR5cGUgPT09IEdyaWRDb2x1bW5EYXRhVHlwZS5UaW1lID9cbiAgICAgICAgICAgICAgICBERUZBVUxUX1RJTUVfRk9STUFUIDogdGhpcy5kYXRhVHlwZSA9PT0gR3JpZENvbHVtbkRhdGFUeXBlLkRhdGVUaW1lID9cbiAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9EQVRFX1RJTUVfRk9STUFUIDogREVGQVVMVF9EQVRFX0ZPUk1BVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3VtbWFyaWVzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF0YVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuQ3VycmVuY3k6XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuUGVyY2VudDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hOdW1iZXJTdW1tYXJ5T3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuRGF0ZTpcbiAgICAgICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5EYXRlVGltZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hEYXRlU3VtbWFyeU9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgR3JpZENvbHVtbkRhdGFUeXBlLlRpbWU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyaWVzID0gSWd4VGltZVN1bW1hcnlPcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgR3JpZENvbHVtbkRhdGFUeXBlLlN0cmluZzpcbiAgICAgICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5Cb29sZWFuOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyaWVzID0gSWd4U3VtbWFyeU9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF0YVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5Cb29sZWFuOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSBJZ3hCb29sZWFuRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuQ3VycmVuY3k6XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuUGVyY2VudDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gSWd4TnVtYmVyRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5EYXRlOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSBJZ3hEYXRlRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5UaW1lOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSBJZ3hUaW1lRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5EYXRlVGltZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gSWd4RGF0ZVRpbWVGaWx0ZXJpbmdPcGVyYW5kLmluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgR3JpZENvbHVtbkRhdGFUeXBlLkltYWdlOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuU3RyaW5nOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IElneFN0cmluZ0ZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldEdyaWRUZW1wbGF0ZShpc1JvdzogYm9vbGVhbik6IHN0cmluZyB7XG4gICAgICAgIGlmIChpc1Jvdykge1xuICAgICAgICAgICAgY29uc3Qgcm93c0NvdW50ID0gIXRoaXMuZ3JpZC5pc1Bpdm90ID8gdGhpcy5ncmlkLm11bHRpUm93TGF5b3V0Um93U2l6ZSA6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHJldHVybiBgcmVwZWF0KCR7cm93c0NvdW50fSwxZnIpYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtblNpemVzU3RyaW5nKHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldEluaXRpYWxDaGlsZENvbHVtblNpemVzKGNoaWxkcmVuOiBRdWVyeUxpc3Q8SWd4Q29sdW1uQ29tcG9uZW50Pik6IEFycmF5PE1STENvbHVtblNpemVJbmZvPiB7XG4gICAgICAgIGNvbnN0IGNvbHVtblNpemVzOiBNUkxDb2x1bW5TaXplSW5mb1tdID0gW107XG4gICAgICAgIC8vIGZpbmQgdGhlIHNtYWxsZXN0IGNvbCBzcGFuc1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNvbCA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbC5jb2xTdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1dpZHRoU2V0ID0gY29sLndpZHRoU2V0QnlVc2VyICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdICYmICFjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXS53aWR0aFNldEJ5VXNlcjtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NwYW5TbWFsbGVyID0gY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0uY29sU3BhbiA+IGNvbC5ncmlkQ29sdW1uU3BhbjtcbiAgICAgICAgICAgIGNvbnN0IGJvdGhXaWR0aHNTZXQgPSBjb2wud2lkdGhTZXRCeVVzZXIgJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0ud2lkdGhTZXRCeVVzZXI7XG4gICAgICAgICAgICBjb25zdCBib3RoV2lkdGhzTm90U2V0ID0gIWNvbC53aWR0aFNldEJ5VXNlciAmJiBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSAmJiAhY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0ud2lkdGhTZXRCeVVzZXI7XG5cbiAgICAgICAgICAgIGlmIChjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm90aGluZyBpcyBkZWZpbmVkIHlldCB0YWtlIGFueSBjb2x1bW4gYXQgZmlyc3RcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgY29sRW5kIHRvIGtub3cgd2hlcmUgdGhlIGNvbHVtbiBhY3R1YWxseSBlbmRzLCBiZWNhdXNlIG5vdCBhbHdheXMgaXQgc3RhcnRzIHdoZXJlIHdlIGhhdmUgaXQgc2V0IGluIGNvbHVtblNpemVzLlxuICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdID0ge1xuICAgICAgICAgICAgICAgICAgICByZWY6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbC53aWR0aCA9PT0gJ2ZpdC1jb250ZW50JyA/IGNvbC5hdXRvU2l6ZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wud2lkdGhTZXRCeVVzZXIgfHwgdGhpcy5ncmlkLmNvbHVtbldpZHRoU2V0QnlVc2VyID8gcGFyc2VJbnQoY29sLmNhbGNXaWR0aCwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICBjb2xFbmQ6IGNvbC5jb2xTdGFydCArIGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhTZXRCeVVzZXI6IGNvbC53aWR0aFNldEJ5VXNlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1dpZHRoU2V0IHx8IChuZXdTcGFuU21hbGxlciAmJiAoKGJvdGhXaWR0aHNTZXQpIHx8IChib3RoV2lkdGhzTm90U2V0KSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBjb2x1bW4gaXMgc2V0IGFscmVhZHkgaXQgc2hvdWxkIGVpdGhlciBub3QgaGF2ZSB3aWR0aCBkZWZpbmVkIG9yIGhhdmUgd2lkdGggd2l0aCBiaWdnZXIgc3BhbiB0aGFuIHRoZSBuZXcgb25lLlxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogIElmIHJlcGxhY2VkIGNvbHVtbiBoYXMgYmlnZ2VyIHNwYW4sIHdlIHdhbnQgdG8gZmlsbCB0aGUgcmVtYWluaW5nIGNvbHVtbnNcbiAgICAgICAgICAgICAgICAgKiAgdGhhdCB0aGUgcmVwbGFjaW5nIGNvbHVtbiBkb2VzIG5vdCBmaWxsIHdpdGggdGhlIG9sZCBvbmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGJvdGhXaWR0aHNTZXQgJiYgbmV3U3BhblNtYWxsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB3aGVyZSB0aGUgbmV3IGNvbHVtbiBzZXQgd291bGQgZW5kIGFuZCBhcHBseSB0aGUgb2xkIGNvbHVtbiB0byB0aGUgcmVzdCBkZXBlbmRpbmcgb24gaG93IG11Y2ggaXQgc3BhbnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgbm90IHlldCByZXBsYWNlZCBpdCBzbyB3ZSBjYW4gdXNlIGl0IGRpcmVjdGx5IGZyb20gdGhlIGNvbHVtblNpemVzIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgY29sRW5kIGlzIHVzZWQgYmVjYXVzZSB0aGUgY29sU3RhcnQgb2YgdGhlIG9sZCBjb2x1bW4gaXMgbm90IGFjdHVhbGx5IGkgKyAxLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY29sLmNvbFN0YXJ0IC0gMSArIGNvbC5ncmlkQ29sdW1uU3BhbjsgaSA8IGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLmNvbEVuZCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2x1bW5TaXplc1tpXSB8fCAhY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXSA9IGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIG9sZCBjb2x1bW4gd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2wud2lkdGggPT09ICdmaXQtY29udGVudCcgPyBjb2wuYXV0b1NpemUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29sLndpZHRoU2V0QnlVc2VyIHx8IHRoaXMuZ3JpZC5jb2x1bW5XaWR0aFNldEJ5VXNlciA/IHBhcnNlSW50KGNvbC5jYWxjV2lkdGgsIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNvbFNwYW46IGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgY29sRW5kOiBjb2wuY29sU3RhcnQgKyBjb2wuZ3JpZENvbHVtblNwYW4sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoU2V0QnlVc2VyOiBjb2wud2lkdGhTZXRCeVVzZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChib3RoV2lkdGhzU2V0ICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLmNvbFNwYW4gPCBjb2wuZ3JpZENvbHVtblNwYW4pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29sdW1uIGFscmVhZHkgaW4gdGhlIGNvbHVtblNpemVzIGhhcyBzbWFsbGVyIHNwYW4sIHdlIHN0aWxsIG5lZWQgdG8gZmlsbCBhbnkgZW1wdHkgcGxhY2VzIHdpdGggdGhlIGN1cnJlbnQgY29sLlxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZyb20gd2hlcmUgdGhlIHNtYWxsZXIgY29sdW1uIHNldCB3b3VsZCBlbmQgYW5kIGFwcGx5IHRoZSBiaWdnZXIgY29sdW1uIHRvIHRoZSByZXN0IGRlcGVuZGluZyBvbiBob3cgbXVjaCBpdCBzcGFucy5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBoZXJlIHdlIGRvIG5vdCBoYXZlIGl0IGluIGNvbHVtblNpemVzIHdlIHNldCBpdCBhcyBhIG5ldyBjb2x1bW4ga2VlcGluZyB0aGUgc2FtZSBjb2xTcGFuLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjb2wuY29sU3RhcnQgLSAxICsgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0uY29sU3BhbjsgaSA8IGNvbC5jb2xTdGFydCAtIDEgKyBjb2wuZ3JpZENvbHVtblNwYW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbHVtblNpemVzW2ldIHx8ICFjb2x1bW5TaXplc1tpXS53aWR0aFNldEJ5VXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbC53aWR0aCA9PT0gJ2ZpdC1jb250ZW50JyA/IGNvbC5hdXRvU2l6ZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC53aWR0aFNldEJ5VXNlciB8fCB0aGlzLmdyaWQuY29sdW1uV2lkdGhTZXRCeVVzZXIgPyBwYXJzZUludChjb2wuY2FsY1dpZHRoLCAxMCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbFNwYW46IGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xFbmQ6IGNvbC5jb2xTdGFydCArIGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aFNldEJ5VXNlcjogY29sLndpZHRoU2V0QnlVc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZsYXR0ZW4gY29sdW1uU2l6ZXMgc28gdGhlcmUgYXJlIG5vdCBjb2x1bW5zIHdpdGggY29sU3BhbiA+IDFcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5TaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtblNpemVzW2ldICYmIGNvbHVtblNpemVzW2ldLmNvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IGogPSAxO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBhbGwgZW1wdHkgcGxhY2VzIGRlcGVuZGluZyBvbiBob3cgbXVjaCB0aGUgY3VycmVudCBjb2x1bW4gc3BhbnMgc3RhcnRpbmcgZnJvbSBuZXh0IGNvbC5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaiA8IGNvbHVtblNpemVzW2ldLmNvbFNwYW4gJiYgaSArIGogKyAxIDwgY29sdW1uU2l6ZXNbaV0uY29sRW5kOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtblNpemVzW2kgKyBqXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCghY29sdW1uU2l6ZXNbaV0ud2lkdGggJiYgY29sdW1uU2l6ZXNbaSArIGpdLndpZHRoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghY29sdW1uU2l6ZXNbaV0ud2lkdGggJiYgIWNvbHVtblNpemVzW2kgKyBqXS53aWR0aCAmJiBjb2x1bW5TaXplc1tpICsgal0uY29sU3BhbiA8PSBjb2x1bW5TaXplc1tpXS5jb2xTcGFuKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghIWNvbHVtblNpemVzW2kgKyBqXS53aWR0aCAmJiBjb2x1bW5TaXplc1tpICsgal0uY29sU3BhbiA8PSBjb2x1bW5TaXplc1tpXS5jb2xTcGFuKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoIGFuIGFscmVhZHkgZGVmaW5lZCBjb2x1bW4gdGhhdCBoYXMgd2lkdGggYW5kIHRoZSBjdXJyZW50IGRvZXNuJ3QgaGF2ZSBvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHJlYWNoZWQgY29sdW1uIGhhcyBiaWdnZXIgY29sU3BhbiB3ZSBzdG9wLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtblNpemVzW2ldLndpZHRoU2V0QnlVc2VyID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS53aWR0aCAvIGNvbHVtblNpemVzW2ldLmNvbFNwYW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaSArIGpdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogY29sdW1uU2l6ZXNbaV0ucmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbFNwYW46IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sRW5kOiBjb2x1bW5TaXplc1tpXS5jb2xFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhTZXRCeVVzZXI6IGNvbHVtblNpemVzW2ldLndpZHRoU2V0QnlVc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGNvbHVtbiB3aWR0aCBzbyBpdCBpcyBkaXZpZGVkIGJldHdlZW4gYWxsIGNvbHVtbnMgaXQgc3BhbnMgYW5kIHNldCBpdCB0byAxLlxuICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoID0gY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXIgP1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS53aWR0aCAvIGNvbHVtblNpemVzW2ldLmNvbFNwYW4gOlxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS53aWR0aDtcbiAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS5jb2xTcGFuID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5kZXggYmFzZWQgb24gaG93IG11Y2ggd2UgaGF2ZSByZXBsYWNlZC4gU3VidHJhY3QgMSBiZWNhdXNlIHdlIHN0YXJ0ZWQgZnJvbSAxLlxuICAgICAgICAgICAgICAgIGkgKz0gaiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sdW1uU2l6ZXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEZpbGxlZENoaWxkQ29sdW1uU2l6ZXMoY2hpbGRyZW46IFF1ZXJ5TGlzdDxJZ3hDb2x1bW5Db21wb25lbnQ+KTogQXJyYXk8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGNvbHVtblNpemVzID0gdGhpcy5nZXRJbml0aWFsQ2hpbGRDb2x1bW5TaXplcyhjaGlsZHJlbik7XG5cbiAgICAgICAgLy8gZmlsbCB0aGUgZ2FwcyBpZiB0aGVyZSBhcmUgYW55XG4gICAgICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzaXplIG9mIGNvbHVtblNpemVzKSB7XG4gICAgICAgICAgICBpZiAoc2l6ZSAmJiAhIXNpemUud2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzaXplLndpZHRoICsgJ3B4Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHRoaXMuZ3JpZC5nZXRQb3NzaWJsZUNvbHVtbldpZHRoKCksIDEwKSArICdweCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFJlc2l6YWJsZUNvbFVuZGVyRW5kKCk6IE1STFJlc2l6ZUNvbHVtbkluZm9bXSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dCB8fCAhdGhpcy5jb2x1bW5MYXlvdXRDaGlsZCB8fCB0aGlzLmNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gW3sgdGFyZ2V0OiB0aGlzLCBzcGFuVXNlZDogMSB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbHVtblNpemVkID0gdGhpcy5nZXRJbml0aWFsQ2hpbGRDb2x1bW5TaXplcyh0aGlzLnBhcmVudC5jaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IHRhcmdldHM6IE1STFJlc2l6ZUNvbHVtbkluZm9bXSA9IFtdO1xuICAgICAgICBjb25zdCBjb2xFbmQgPSB0aGlzLmNvbEVuZCA/IHRoaXMuY29sRW5kIDogdGhpcy5jb2xTdGFydCArIDE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5TaXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sU3RhcnQgPD0gaSArIDEgJiYgaSArIDEgPCBjb2xFbmQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzLnB1c2goeyB0YXJnZXQ6IGNvbHVtblNpemVkW2ldLnJlZiwgc3BhblVzZWQ6IDEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXRzU3F1YXNoZWQ6IE1STFJlc2l6ZUNvbHVtbkluZm9bXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0c1NxdWFzaGVkLmxlbmd0aCAmJiB0YXJnZXRzU3F1YXNoZWRbdGFyZ2V0c1NxdWFzaGVkLmxlbmd0aCAtIDFdLnRhcmdldC5maWVsZCA9PT0gdGFyZ2V0LnRhcmdldC5maWVsZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldHNTcXVhc2hlZFt0YXJnZXRzU3F1YXNoZWQubGVuZ3RoIC0gMV0uc3BhblVzZWQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0c1NxdWFzaGVkLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRzU3F1YXNoZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlucyB0aGUgY29sdW1uIGF0IHRoZSBwcm92aWRlZCBpbmRleCBpbiB0aGUgcGlubmVkIGFyZWEuXG4gICAgICogRGVmYXVsdHMgdG8gaW5kZXggYDBgIGlmIG5vdCBwcm92aWRlZCwgb3IgdG8gdGhlIGluaXRpYWwgaW5kZXggaW4gdGhlIHBpbm5lZCBhcmVhLlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBjb2x1bW4gaXMgc3VjY2Vzc2Z1bGx5IHBpbm5lZC4gUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBjb2x1bW4gY2Fubm90IGJlIHBpbm5lZC5cbiAgICAgKiBDb2x1bW4gY2Fubm90IGJlIHBpbm5lZCBpZjpcbiAgICAgKiAtIElzIGFscmVhZHkgcGlubmVkXG4gICAgICogLSBpbmRleCBhcmd1bWVudCBpcyBvdXQgb2YgcmFuZ2VcbiAgICAgKiAtIFRoZSBwaW5uZWQgYXJlYSBleGNlZWRzIDgwJSBvZiB0aGUgZ3JpZCB3aWR0aFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgc3VjY2VzcyA9IHRoaXMuY29sdW1uLnBpbigpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBwaW4oaW5kZXg/OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgLy8gVE9ETzogUHJvYmFibHkgc2hvdWxkIHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgb2xkIGZ1bmN0aW9uc1xuICAgICAgICAvLyBzaG91bGQgYmUgbW92ZWQgYXMgYSBldmVudCBwYXJhbWV0ZXIuXG4gICAgICAgIGNvbnN0IGdyaWQgPSAodGhpcy5ncmlkIGFzIGFueSk7XG4gICAgICAgIGlmICh0aGlzLl9waW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAhdGhpcy5wYXJlbnQucGlubmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3BMZXZlbFBhcmVudC5waW4oaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGFzSW5kZXggPSBpbmRleCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaGFzSW5kZXggJiYgKGluZGV4IDwgMCB8fCBpbmRleCA+IGdyaWQucGlubmVkQ29sdW1ucy5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucGFyZW50ICYmICF0aGlzLnBpbm5hYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb290UGlubmVkQ29scyA9IGdyaWQuX3Bpbm5lZENvbHVtbnMuZmlsdGVyKChjKSA9PiBjLmxldmVsID09PSAwKTtcbiAgICAgICAgaW5kZXggPSBoYXNJbmRleCA/IGluZGV4IDogcm9vdFBpbm5lZENvbHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBhcmdzOiBJUGluQ29sdW1uQ2FuY2VsbGFibGVFdmVudEFyZ3MgPSB7IGNvbHVtbjogdGhpcywgaW5zZXJ0QXRJbmRleDogaW5kZXgsIGlzUGlubmVkOiBmYWxzZSwgY2FuY2VsOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLmdyaWQuY29sdW1uUGluLmVtaXQoYXJncyk7XG5cbiAgICAgICAgaWYgKGFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdyaWQuY3J1ZFNlcnZpY2UuZW5kRWRpdChmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5fcGlubmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5waW5uZWRDaGFuZ2UuZW1pdCh0aGlzLl9waW5uZWQpO1xuICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IGluZGV4IGlzIHRoZSBsYXN0IHBvc2l0aW9uLCBzbyB3aWxsIG5lZWQgdG8gZmluZCB0YXJnZXQgY29sdW1uIGJ5IFtpbmRleC0xXVxuICAgICAgICBjb25zdCB0YXJnZXRDb2x1bW4gPSBhcmdzLmluc2VydEF0SW5kZXggPT09IGdyaWQuX3Bpbm5lZENvbHVtbnMubGVuZ3RoID9cbiAgICAgICAgICAgIGdyaWQuX3Bpbm5lZENvbHVtbnNbYXJncy5pbnNlcnRBdEluZGV4IC0gMV0gOiBncmlkLl9waW5uZWRDb2x1bW5zW2FyZ3MuaW5zZXJ0QXRJbmRleF07XG5cbiAgICAgICAgaWYgKGdyaWQuX3Bpbm5lZENvbHVtbnMuaW5kZXhPZih0aGlzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmICghZ3JpZC5oYXNDb2x1bW5Hcm91cHMpIHtcbiAgICAgICAgICAgICAgICBncmlkLl9waW5uZWRDb2x1bW5zLnNwbGljZShhcmdzLmluc2VydEF0SW5kZXgsIDAsIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgYmFzZWQgb25seSBvbiByb290IGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICByb290UGlubmVkQ29scy5zcGxpY2UoYXJncy5pbnNlcnRBdEluZGV4LCAwLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBsZXQgYWxsUGlubmVkID0gW107XG4gICAgICAgICAgICAgICAgLy8gcmUtY3JlYXRlIGhpZXJhcmNoeVxuICAgICAgICAgICAgICAgIHJvb3RQaW5uZWRDb2xzLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhbGxQaW5uZWQucHVzaChncm91cCk7XG4gICAgICAgICAgICAgICAgICAgIGFsbFBpbm5lZCA9IGFsbFBpbm5lZC5jb25jYXQoZ3JvdXAuYWxsQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyaWQuX3Bpbm5lZENvbHVtbnMgPSBhbGxQaW5uZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChncmlkLl91bnBpbm5lZENvbHVtbnMuaW5kZXhPZih0aGlzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbkNvdW50ID0gdGhpcy5hbGxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZ3JpZC5fdW5waW5uZWRDb2x1bW5zLnNwbGljZShncmlkLl91bnBpbm5lZENvbHVtbnMuaW5kZXhPZih0aGlzKSwgMSArIGNoaWxkcmVuQ291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0luZGV4KSB7XG4gICAgICAgICAgICBncmlkLl9tb3ZlQ29sdW1ucyh0aGlzLCB0YXJnZXRDb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuYWxsQ2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5waW4oKSk7XG4gICAgICAgICAgICBncmlkLnJlaW5pdFBpblN0YXRlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXNldENhY2hlcygpO1xuICAgICAgICBncmlkLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5jb2x1bW5zLmZpbHRlcih4ID0+IHguY29sdW1uTGF5b3V0KS5mb3JFYWNoKHggPT4geC5wb3B1bGF0ZVZpc2libGVJbmRleGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLnJlZnJlc2hFeHByZXNzaW9ucygpO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElQaW5Db2x1bW5FdmVudEFyZ3MgPSB7IGNvbHVtbjogdGhpcywgaW5zZXJ0QXRJbmRleDogaW5kZXgsIGlzUGlubmVkOiB0cnVlIH07XG4gICAgICAgIHRoaXMuZ3JpZC5jb2x1bW5QaW5uZWQuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5waW5zIHRoZSBjb2x1bW4gYW5kIHBsYWNlIGl0IGF0IHRoZSBwcm92aWRlZCBpbmRleCBpbiB0aGUgdW5waW5uZWQgYXJlYS5cbiAgICAgKiBEZWZhdWx0cyB0byBpbmRleCBgMGAgaWYgbm90IHByb3ZpZGVkLCBvciB0byB0aGUgaW5pdGlhbCBpbmRleCBpbiB0aGUgdW5waW5uZWQgYXJlYS5cbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29sdW1uIGlzIHN1Y2Nlc3NmdWxseSB1bnBpbm5lZC4gUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBjb2x1bW4gY2Fubm90IGJlIHVucGlubmVkLlxuICAgICAqIENvbHVtbiBjYW5ub3QgYmUgdW5waW5uZWQgaWY6XG4gICAgICogLSBJcyBhbHJlYWR5IHVucGlubmVkXG4gICAgICogLSBpbmRleCBhcmd1bWVudCBpcyBvdXQgb2YgcmFuZ2VcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHN1Y2Nlc3MgPSB0aGlzLmNvbHVtbi51bnBpbigpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyB1bnBpbihpbmRleD86IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBncmlkID0gKHRoaXMuZ3JpZCBhcyBhbnkpO1xuICAgICAgICBpZiAoIXRoaXMuX3Bpbm5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnBpbm5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9wTGV2ZWxQYXJlbnQudW5waW4oaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc0luZGV4ID0gaW5kZXggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGhhc0luZGV4ICYmIChpbmRleCA8IDAgfHwgaW5kZXggPiBncmlkLl91bnBpbm5lZENvbHVtbnMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXN0aW1hdGUgdGhlIGV4YWN0IGluZGV4IGF0IHdoaWNoIGNvbHVtbiB3aWxsIGJlIGluc2VydGVkXG4gICAgICAgIC8vIHRha2VzIGludG8gYWNjb3VudCBpbml0aWFsIHVucGlubmVkIGluZGV4IG9mIHRoZSBjb2x1bW5cbiAgICAgICAgaWYgKCFoYXNJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IGdyaWQudW5waW5uZWRDb2x1bW5zLm1hcChjb2wgPT4gY29sLmluZGV4KTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIGluZGljZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRpY2VzLmluZGV4T2YodGhpcy5pbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhcmdzOiBJUGluQ29sdW1uQ2FuY2VsbGFibGVFdmVudEFyZ3MgPSB7IGNvbHVtbjogdGhpcywgaW5zZXJ0QXRJbmRleDogaW5kZXgsIGlzUGlubmVkOiB0cnVlLCBjYW5jZWw6IGZhbHNlIH07XG4gICAgICAgIHRoaXMuZ3JpZC5jb2x1bW5QaW4uZW1pdChhcmdzKTtcblxuICAgICAgICBpZiAoYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JpZC5jcnVkU2VydmljZS5lbmRFZGl0KGZhbHNlKTtcblxuICAgICAgICB0aGlzLl9waW5uZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5waW5uZWRDaGFuZ2UuZW1pdCh0aGlzLl9waW5uZWQpO1xuXG4gICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgaW5kZXggaXMgdGhlIGxhc3QgcG9zaXRpb24sIHNvIHdpbGwgbmVlZCB0byBmaW5kIHRhcmdldCBjb2x1bW4gYnkgW2luZGV4LTFdXG4gICAgICAgIGNvbnN0IHRhcmdldENvbHVtbiA9IGFyZ3MuaW5zZXJ0QXRJbmRleCA9PT0gZ3JpZC5fdW5waW5uZWRDb2x1bW5zLmxlbmd0aCA/XG4gICAgICAgICAgICBncmlkLl91bnBpbm5lZENvbHVtbnNbYXJncy5pbnNlcnRBdEluZGV4IC0gMV0gOiBncmlkLl91bnBpbm5lZENvbHVtbnNbYXJncy5pbnNlcnRBdEluZGV4XTtcblxuICAgICAgICBpZiAoIWhhc0luZGV4KSB7XG4gICAgICAgICAgICBncmlkLl91bnBpbm5lZENvbHVtbnMuc3BsaWNlKGluZGV4LCAwLCB0aGlzKTtcbiAgICAgICAgICAgIGlmIChncmlkLl9waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5fcGlubmVkQ29sdW1ucy5zcGxpY2UoZ3JpZC5fcGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNJbmRleCkge1xuICAgICAgICAgICAgZ3JpZC5tb3ZlQ29sdW1uKHRoaXMsIHRhcmdldENvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgdGhpcy5hbGxDaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnVucGluKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZWluaXRQaW5TdGF0ZXMoKTtcbiAgICAgICAgZ3JpZC5yZXNldENhY2hlcygpO1xuXG4gICAgICAgIGdyaWQubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5MYXlvdXRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmNvbHVtbnMuZmlsdGVyKHggPT4geC5jb2x1bW5MYXlvdXQpLmZvckVhY2goeCA9PiB4LnBvcHVsYXRlVmlzaWJsZUluZGV4ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UucmVmcmVzaEV4cHJlc3Npb25zKCk7XG5cbiAgICAgICAgdGhpcy5ncmlkLmNvbHVtblBpbm5lZC5lbWl0KHsgY29sdW1uOiB0aGlzLCBpbnNlcnRBdEluZGV4OiBpbmRleCwgaXNQaW5uZWQ6IGZhbHNlIH0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY29sdW1uIHRvIHRoZSBzcGVjaWZpZWQgdmlzaWJsZSBpbmRleC5cbiAgICAgKiBJZiBwYXNzZWQgaW5kZXggaXMgaW52YWxpZCwgb3IgaWYgY29sdW1uIHdvdWxkIHJlY2VpdmUgYSBkaWZmZXJlbnQgdmlzaWJsZSBpbmRleCBhZnRlciBtb3ZpbmcsIG1vdmluZyBpcyBub3QgcGVyZm9ybWVkLlxuICAgICAqIElmIHBhc3NlZCBpbmRleCB3b3VsZCBtb3ZlIHRoZSBjb2x1bW4gdG8gYSBkaWZmZXJlbnQgY29sdW1uIGdyb3VwLiBtb3ZpbmcgaXMgbm90IHBlcmZvcm1lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbHVtbi5tb3ZlKGluZGV4KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIG1vdmUoaW5kZXg6IG51bWJlcikge1xuICAgICAgICBsZXQgdGFyZ2V0O1xuICAgICAgICBsZXQgY29sdW1ucyA9IHRoaXMuZ3JpZC5jb2x1bW5zLmZpbHRlcihjID0+IGMudmlzaWJsZUluZGV4ID4gLTEpO1xuICAgICAgICAvLyBncmlkIGxhc3QgdmlzaWJsZSBpbmRleFxuICAgICAgICBjb25zdCBsaSA9IGNvbHVtbnMubWFwKGMgPT4gYy52aXNpYmxlSW5kZXgpLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5tYXgoYSwgYikpO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgY29uc3QgaXNQcmVjZWRpbmcgPSB0aGlzLnZpc2libGVJbmRleCA8IGluZGV4O1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy52aXNpYmxlSW5kZXggfHwgaW5kZXggPCAwIHx8IGluZGV4ID4gbGkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zLmZpbHRlcihjID0+IGMubGV2ZWwgPj0gdGhpcy5sZXZlbCAmJiBjICE9PSB0aGlzICYmIGMucGFyZW50ICE9PSB0aGlzICYmXG4gICAgICAgICAgICAgICAgYy50b3BMZXZlbFBhcmVudCA9PT0gdGhpcy50b3BMZXZlbFBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICAvLyBJZiBpc1ByZWNlZGluZywgZmluZCBhIHRhcmdldCBzdWNoIHRoYXQgd2hlbiB0aGUgY3VycmVudCBjb2x1bW4gaXMgcGxhY2VkIGFmdGVyIGl0LCBjdXJyZW50IGNvbHVtbW4gd2lsbCByZWNlaXZlIGEgdmlzaWJsZUluZGV4ID09PSBpbmRleC4gVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgdmlzaWJsZSBjaGlsZHJlbiBvZiB0aGUgY29sdW1ucy5cbiAgICAgICAgLy8gSWYgIWlzUHJlY2VkaW5nLCBmaW5kcyBhIGNvbHVtbiBvZiB0aGUgc2FtZSBsZXZlbCBhbmQgdmlzaWJsZSBpbmRleCB0aGF0IGVxdWFscyB0aGUgcGFzc2VkIGluZGV4IGFndW1lbnQgKGMudmlzaWJsZUluZGV4ID09PSBpbmRleCkuIE5vIG5lZWQgdG8gY29uc2lkZXIgdGhlIGNoaWxkcmVuIGhlcmUuXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICAgICAgICBpZiAoaXNQcmVjZWRpbmcpIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zLmZpbHRlcihjID0+IGMudmlzaWJsZUluZGV4ID4gdGhpcy52aXNpYmxlSW5kZXgpO1xuICAgICAgICAgICAgdGFyZ2V0ID0gY29sdW1ucy5maW5kKGMgPT4gYy5sZXZlbCA9PT0gdGhpcy5sZXZlbCAmJiBjLnZpc2libGVJbmRleCArIChjIGFzIGFueSkuY2FsY0NoaWxkcmVuKCkgLSB0aGlzLmNhbGNDaGlsZHJlbigpID09PSBpbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoYyA9PiBjLnZpc2libGVJbmRleCA8IHRoaXMudmlzaWJsZUluZGV4KTtcbiAgICAgICAgICAgIHRhcmdldCA9IGNvbHVtbnMuZmluZChjID0+IGMubGV2ZWwgPT09IHRoaXMubGV2ZWwgJiYgYy52aXNpYmxlSW5kZXggPT09IGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICh0YXJnZXQucGlubmVkICYmIHRoaXMuZGlzYWJsZVBpbm5pbmcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwb3MgPSBpc1ByZWNlZGluZyA/IERyb3BQb3NpdGlvbi5BZnRlckRyb3BUYXJnZXQgOiBEcm9wUG9zaXRpb24uQmVmb3JlRHJvcFRhcmdldDtcbiAgICAgICAgdGhpcy5ncmlkLm1vdmVDb2x1bW4odGhpcywgdGFyZ2V0IGFzIElneENvbHVtbkNvbXBvbmVudCwgcG9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBObyBjaGlsZHJlbiBmb3IgdGhlIGNvbHVtbiwgc28gd2lsbCByZXR1cm5zIDEgb3IgMCwgaWYgdGhlIGNvbHVtbiBpcyBoaWRkZW4uXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGNhbGNDaGlsZHJlbigpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaGlkZGVuID8gMCA6IDE7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGNvbHVtbiB2aWJpc2lsaXR5IGFuZCBlbWl0cyB0aGUgcmVzcGVjdGl2ZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlVmlzaWJpbGl0eSh2YWx1ZT86IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA/PyAhdGhpcy5oaWRkZW47XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSUNvbHVtblZpc2liaWxpdHlDaGFuZ2luZ0V2ZW50QXJncyA9IHsgY29sdW1uOiB0aGlzLCBuZXdWYWx1ZSwgY2FuY2VsOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLmdyaWQuY29sdW1uVmlzaWJpbGl0eUNoYW5naW5nLmVtaXQoZXZlbnRBcmdzKTtcblxuICAgICAgICBpZiAoZXZlbnRBcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZGVuID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuZ3JpZC5jb2x1bW5WaXNpYmlsaXR5Q2hhbmdlZC5lbWl0KHsgY29sdW1uOiB0aGlzLCBuZXdWYWx1ZSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AgbGV2ZWwgcGFyZW50IGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHRvcExldmVsUGFyZW50ID0gIHRoaXMuY29sdW1uLnRvcExldmVsUGFyZW50O1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdG9wTGV2ZWxQYXJlbnQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgaGVhZGVyIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbiAgICAgKiBsZXQgaGVhZGVyQ2VsbCA9IGNvbHVtbi5oZWFkZXJDZWxsO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaGVhZGVyQ2VsbCgpOiBJZ3hHcmlkSGVhZGVyQ29tcG9uZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5oZWFkZXJDZWxsTGlzdC5maW5kKChoZWFkZXIpID0+IGhlYWRlci5jb2x1bW4gPT09IHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGZpbHRlciBjZWxsIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbiAgICAgKiBsZXQgZmlsdGVyZWxsID0gY29sdW1uLmZpbHRlcmVsbDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGZpbHRlckNlbGwoKTogSWd4R3JpZEZpbHRlcmluZ0NlbGxDb21wb25lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmZpbHRlckNlbGxMaXN0LmZpbmQoKGZpbHRlckNlbGwpID0+IGZpbHRlckNlbGwuY29sdW1uID09PSB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBoZWFkZXIgZ3JvdXAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGhlYWRlckdyb3VwKCk6IElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuaGVhZGVyR3JvdXBzTGlzdC5maW5kKGdyb3VwID0+IGdyb3VwLmNvbHVtbiA9PT0gdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXV0b3NpemUgdGhlIGNvbHVtbiB0byB0aGUgbG9uZ2VzdCBjdXJyZW50bHkgdmlzaWJsZSBjZWxsIHZhbHVlLCBpbmNsdWRpbmcgdGhlIGhlYWRlciBjZWxsLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKCdncmlkJykgZ3JpZDogSWd4R3JpZENvbXBvbmVudDtcbiAgICAgKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4gICAgICogY29sdW1uLmF1dG9zaXplKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICogQHBhcmFtIGJ5SGVhZGVyT25seSBTZXQgaWYgY29sdW1uIHNob3VsZCBiZSBhdXRvc2l6ZWQgYmFzZWQgb25seSBvbiB0aGUgaGVhZGVyIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHVibGljIGF1dG9zaXplKGJ5SGVhZGVyT25seSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuZ2V0QXV0b1NpemUoYnlIZWFkZXJPbmx5KTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5yZWZsb3coKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0QXV0b1NpemUoYnlIZWFkZXIgPSBmYWxzZSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHNpemUgPSAhYnlIZWFkZXIgPyB0aGlzLmdldExhcmdlc3RDZWxsV2lkdGgoKSA6XG4gICAgICAgICAgICAoT2JqZWN0LnZhbHVlcyh0aGlzLmdldEhlYWRlckNlbGxXaWR0aHMoKSkucmVkdWNlKChhLCBiKSA9PiBhICsgYikgKyAncHgnKTtcbiAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlV2lkdGggPSB0aGlzLndpZHRoICYmIHR5cGVvZiB0aGlzLndpZHRoID09PSAnc3RyaW5nJyAmJiB0aGlzLndpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTE7XG5cbiAgICAgICAgbGV0IG5ld1dpZHRoO1xuICAgICAgICBpZiAoaXNQZXJjZW50YWdlV2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyaWRBdmFpbGFibGVTaXplID0gdGhpcy5ncmlkLmNhbGNXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2VTaXplID0gcGFyc2VGbG9hdChzaXplKSAvIGdyaWRBdmFpbGFibGVTaXplICogMTAwO1xuICAgICAgICAgICAgbmV3V2lkdGggPSBwZXJjZW50YWdlU2l6ZSArICclJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gaXNQZXJjZW50YWdlV2lkdGggPyB0aGlzLm1heFdpZHRoUGVyY2VudCA6IHRoaXMubWF4V2lkdGhQeDtcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBpc1BlcmNlbnRhZ2VXaWR0aCA/IHRoaXMubWluV2lkdGhQZXJjZW50IDogdGhpcy5taW5XaWR0aFB4O1xuICAgICAgICBpZiAodGhpcy5tYXhXaWR0aCAmJiAocGFyc2VGbG9hdChuZXdXaWR0aCkgPiBtYXhXaWR0aCkpIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gaXNQZXJjZW50YWdlV2lkdGggPyBtYXhXaWR0aCArICclJyA6IG1heFdpZHRoICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIGlmIChwYXJzZUZsb2F0KG5ld1dpZHRoKSA8IG1pbldpZHRoKSB7XG4gICAgICAgICAgICBuZXdXaWR0aCA9IGlzUGVyY2VudGFnZVdpZHRoID8gbWluV2lkdGggKyAnJScgOiBtaW5XaWR0aCArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3V2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDYWxjV2lkdGgoKTogYW55IHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGNXaWR0aCAmJiAhaXNOYU4odGhpcy5jYWxjUGl4ZWxXaWR0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZUNhbGNXaWR0aCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY1dpZHRoO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIGFuZCBwYWRkaW5nIG9mIGEgaGVhZGVyIGNlbGwuXG4gICAgICovXG4gICAgcHVibGljIGdldEhlYWRlckNlbGxXaWR0aHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0SGVhZGVyQ2VsbFdpZHRoKHRoaXMuaGVhZGVyQ2VsbC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSAoaW4gcGl4ZWxzKSBvZiB0aGUgbG9uZ2VzdCBjdXJyZW50bHkgdmlzaWJsZSBjZWxsLCBpbmNsdWRpbmcgdGhlIGhlYWRlciBjZWxsLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKCdncmlkJykgZ3JpZDogSWd4R3JpZENvbXBvbmVudDtcbiAgICAgKlxuICAgICAqIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbiAgICAgKiBsZXQgc2l6ZSA9IGNvbHVtbi5nZXRMYXJnZXN0Q2VsbFdpZHRoKCk7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRMYXJnZXN0Q2VsbFdpZHRoKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5ncmlkLmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIGNvbnN0IGxhcmdlc3QgPSBuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpO1xuXG4gICAgICAgIGlmICh0aGlzLl9jZWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsc0NvbnRlbnRXaWR0aHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NlbGxzLmZvckVhY2goKGNlbGwpID0+IGNlbGxzQ29udGVudFdpZHRocy5wdXNoKGNlbGwuY2FsY3VsYXRlU2l6ZVRvRml0KHJhbmdlKSkpO1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNlbGxzQ29udGVudFdpZHRocy5pbmRleE9mKE1hdGgubWF4KC4uLmNlbGxzQ29udGVudFdpZHRocykpO1xuICAgICAgICAgICAgY29uc3QgY2VsbFN0eWxlID0gdGhpcy5ncmlkLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5fY2VsbHNbaW5kZXhdLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgY2VsbFBhZGRpbmcgPSBwYXJzZUZsb2F0KGNlbGxTdHlsZS5wYWRkaW5nTGVmdCkgKyBwYXJzZUZsb2F0KGNlbGxTdHlsZS5wYWRkaW5nUmlnaHQpICtcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGNlbGxTdHlsZS5ib3JkZXJMZWZ0V2lkdGgpICsgcGFyc2VGbG9hdChjZWxsU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCk7XG5cbiAgICAgICAgICAgIGxhcmdlc3Quc2V0KE1hdGgubWF4KC4uLmNlbGxzQ29udGVudFdpZHRocyksIGNlbGxQYWRkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhlYWRlckNlbGwgJiYgdGhpcy5hdXRvc2l6ZUhlYWRlcikge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyQ2VsbFdpZHRocyA9IHRoaXMuZ2V0SGVhZGVyQ2VsbFdpZHRocygpO1xuICAgICAgICAgICAgbGFyZ2VzdC5zZXQoaGVhZGVyQ2VsbFdpZHRocy53aWR0aCwgaGVhZGVyQ2VsbFdpZHRocy5wYWRkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhcmdlc3RDZWxsID0gTWF0aC5tYXgoLi4uQXJyYXkuZnJvbShsYXJnZXN0LmtleXMoKSkpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChsYXJnZXN0Q2VsbCArIGxhcmdlc3QuZ2V0KGxhcmdlc3RDZWxsKSk7XG5cbiAgICAgICAgaWYgKE51bWJlci5pc05hTih3aWR0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdpZHRoICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q2VsbFdpZHRoKCkge1xuICAgICAgICBjb25zdCBjb2xXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gY29sV2lkdGggJiYgdHlwZW9mIGNvbFdpZHRoID09PSAnc3RyaW5nJyAmJiBjb2xXaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dENoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sV2lkdGggJiYgIWlzUGVyY2VudGFnZVdpZHRoKSB7XG5cbiAgICAgICAgICAgIGxldCBjZWxsV2lkdGggPSBjb2xXaWR0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2VsbFdpZHRoICE9PSAnc3RyaW5nJyB8fCBjZWxsV2lkdGguZW5kc1dpdGgoJ3B4JykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoICs9ICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjZWxsV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29sV2lkdGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHBvcHVsYXRlVmlzaWJsZUluZGV4ZXMoKSB7IH1cblxuICAgIHByb3RlY3RlZCBnZXRDb2x1bW5TaXplc1N0cmluZyhjaGlsZHJlbjogUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD4pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmdldEZpbGxlZENoaWxkQ29sdW1uU2l6ZXMoY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gcmVzLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNhY2hlQ2FsY1dpZHRoKCk6IGFueSB7XG4gICAgICAgIGNvbnN0IGNvbFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlV2lkdGggPSBjb2xXaWR0aCAmJiB0eXBlb2YgY29sV2lkdGggPT09ICdzdHJpbmcnICYmIGNvbFdpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTE7XG4gICAgICAgIGNvbnN0IGlzQXV0b1dpZHRoID0gY29sV2lkdGggJiYgdHlwZW9mIGNvbFdpZHRoID09PSAnc3RyaW5nJyAmJiBjb2xXaWR0aCA9PT0gJ2ZpdC1jb250ZW50JztcbiAgICAgICAgaWYgKGlzUGVyY2VudGFnZVdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjV2lkdGggPSBwYXJzZUZsb2F0KGNvbFdpZHRoKSAvIDEwMCAqIHRoaXMuZ3JpZC5jYWxjV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbFdpZHRoIHx8IGlzQXV0b1dpZHRoICYmICF0aGlzLmF1dG9TaXplKSB7XG4gICAgICAgICAgICAvLyBubyB3aWR0aFxuICAgICAgICAgICAgdGhpcy5fY2FsY1dpZHRoID0gdGhpcy5kZWZhdWx0V2lkdGggfHwgdGhpcy5ncmlkLmdldFBvc3NpYmxlQ29sdW1uV2lkdGgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGNXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjUGl4ZWxXaWR0aCA9IHBhcnNlRmxvYXQodGhpcy5fY2FsY1dpZHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNldEV4cGFuZENvbGxhcHNlU3RhdGUoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZmlsdGVyKGNvbCA9PiAoY29sLnZpc2libGVXaGVuQ29sbGFwc2VkICE9PSB1bmRlZmluZWQpKS5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbGxhcHNpYmxlKSB7XG4gICAgICAgICAgICAgICAgYy5oaWRkZW4gPSB0aGlzLmhpZGRlbjsgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYy5oaWRkZW4gPSB0aGlzLl9leHBhbmRlZCA/IGMudmlzaWJsZVdoZW5Db2xsYXBzZWQgOiAhYy52aXNpYmxlV2hlbkNvbGxhcHNlZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2hlY2tDb2xsYXBzaWJsZVN0YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudmlzaWJsZVdoZW5Db2xsYXBzZWQpO1xuICAgICAgICByZXR1cm4gKGNvbHMuc29tZShjID0+IGMgPT09IHRydWUpICYmIGNvbHMuc29tZShjID0+IGMgPT09IGZhbHNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcGlubmFibGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ncmlkIGFzIGFueSkuX2luaXQgfHwgIXRoaXMucGlubmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGFwcGx5U2VsZWN0YWJsZUNsYXNzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZWxlY3RhYmxlQ2xhc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgYXBwbHlTZWxlY3RhYmxlQ2xhc3ModmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlTZWxlY3RhYmxlQ2xhc3MgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==