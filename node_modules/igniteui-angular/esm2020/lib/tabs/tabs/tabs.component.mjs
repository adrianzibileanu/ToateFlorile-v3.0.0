import { Component, HostBinding, Inject, Input, ViewChild } from '@angular/core';
import { getResizeObserver, mkenum } from '../../core/utils';
import { IgxAngularAnimationService } from '../../services/animation/angular-animation-service';
import { IgxTabsBase } from '../tabs.base';
import { IgxTabsDirective } from '../tabs.directive';
import * as i0 from "@angular/core";
import * as i1 from "../../services/direction/directionality";
import * as i2 from "@angular/common";
import * as i3 from "../../icon/icon.component";
import * as i4 from "../../directives/ripple/ripple.directive";
export const IgxTabsAlignment = mkenum({
    start: 'start',
    end: 'end',
    center: 'center',
    justify: 'justify'
});
/** @hidden */
var TabScrollButtonStyle;
(function (TabScrollButtonStyle) {
    TabScrollButtonStyle["Enabled"] = "enabled";
    TabScrollButtonStyle["Disabled"] = "disabled";
    TabScrollButtonStyle["NotDisplayed"] = "not_displayed";
})(TabScrollButtonStyle || (TabScrollButtonStyle = {}));
/** @hidden */
let NEXT_TAB_ID = 0;
/**
 * Tabs component is used to organize or switch between similar data sets.
 *
 * @igxModule IgxTabsModule
 *
 * @igxTheme igx-tabs-theme
 *
 * @igxKeywords tabs
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI for Angular Tabs component places tabs at the top and allows for scrolling when there are multiple tab items on the screen.
 *
 * @example
 * ```html
 * <igx-tabs>
 *     <igx-tab-item>
 *         <igx-tab-header>
 *             <igx-icon igxTabHeaderIcon>folder</igx-icon>
 *             <span igxTabHeaderLabel>Tab 1</span>
 *         </igx-tab-header>
 *         <igx-tab-content>
 *             Content 1
 *         </igx-tab-content>
 *     </igx-tab-item>
 *     ...
 * </igx-tabs>
 * ```
 */
export class IgxTabsComponent extends IgxTabsDirective {
    constructor(animationService, cdr, ngZone, dir) {
        super(animationService, cdr, dir);
        this.ngZone = ngZone;
        this.dir = dir;
        /** @hidden */
        this.defaultClass = true;
        /**  @hidden */
        this.offset = 0;
        /** @hidden */
        this.componentName = 'igx-tabs';
        this._tabAlignment = 'start';
    }
    /**
     * An @Input property which determines the tab alignment. Defaults to `start`.
     */
    get tabAlignment() {
        return this._tabAlignment;
    }
    ;
    set tabAlignment(value) {
        this._tabAlignment = value;
        requestAnimationFrame(() => {
            this.updateScrollButtons();
            this.realignSelectedIndicator();
        });
    }
    /** @hidden @internal */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.ngZone.runOutsideAngular(() => {
            this._resizeObserver = new (getResizeObserver())(() => {
                this.updateScrollButtons();
                this.realignSelectedIndicator();
            });
            this._resizeObserver.observe(this.headerContainer.nativeElement);
            this._resizeObserver.observe(this.viewPort.nativeElement);
        });
    }
    /** @hidden @internal */
    ngOnDestroy() {
        super.ngOnDestroy();
        this.ngZone.runOutsideAngular(() => {
            this._resizeObserver?.disconnect();
        });
    }
    /** @hidden */
    scrollPrev() {
        this.scroll(false);
    }
    /** @hidden */
    scrollNext() {
        this.scroll(true);
    }
    /** @hidden */
    realignSelectedIndicator() {
        if (this.selectedIndex >= 0 && this.selectedIndex < this.items.length) {
            const header = this.items.get(this.selectedIndex).headerComponent.nativeElement;
            this.alignSelectedIndicator(header, 0);
        }
    }
    /** @hidden */
    resolveHeaderScrollClasses() {
        return {
            'igx-tabs__header-scroll--start': this.tabAlignment === 'start',
            'igx-tabs__header-scroll--end': this.tabAlignment === 'end',
            'igx-tabs__header-scroll--center': this.tabAlignment === 'center',
            'igx-tabs__header-scroll--justify': this.tabAlignment === 'justify',
        };
    }
    /** @hidden */
    scrollTabHeaderIntoView() {
        if (this.selectedIndex >= 0) {
            const tabItems = this.items.toArray();
            const tabHeaderNativeElement = tabItems[this.selectedIndex].headerComponent.nativeElement;
            // Scroll left if there is need
            if (this.getElementOffset(tabHeaderNativeElement) < this.offset) {
                this.scrollElement(tabHeaderNativeElement, false);
            }
            // Scroll right if there is need
            const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
            const delta = (this.getElementOffset(tabHeaderNativeElement) + tabHeaderNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
            // Fix for IE 11, a difference is accumulated from the widths calculations
            if (delta > 1) {
                this.scrollElement(tabHeaderNativeElement, true);
            }
            this.alignSelectedIndicator(tabHeaderNativeElement);
        }
        else {
            this.hideSelectedIndicator();
        }
    }
    /** @hidden */
    getNextTabId() {
        return NEXT_TAB_ID++;
    }
    /** @hidden */
    onItemChanges() {
        super.onItemChanges();
        Promise.resolve().then(() => {
            this.updateScrollButtons();
        });
    }
    alignSelectedIndicator(element, duration = 0.3) {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
            this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;
            this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;
        }
    }
    hideSelectedIndicator() {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    }
    scroll(scrollNext) {
        const tabsArray = this.items.toArray();
        for (let index = 0; index < tabsArray.length; index++) {
            const tab = tabsArray[index];
            const element = tab.headerComponent.nativeElement;
            if (scrollNext) {
                if (element.offsetWidth + this.getElementOffset(element) > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollNext);
                    break;
                }
            }
            else {
                if (this.getElementOffset(element) >= this.offset) {
                    this.scrollElement(tabsArray[index - 1].headerComponent.nativeElement, scrollNext);
                    break;
                }
            }
        }
    }
    scrollElement(element, scrollNext) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollNext) ? element.offsetWidth + this.getElementOffset(element) - viewPortWidth : this.getElementOffset(element);
        this.viewPort.nativeElement.scrollLeft = this.getOffset(this.offset);
        this.updateScrollButtons();
    }
    updateScrollButtons() {
        const itemsContainerWidth = this.getTabItemsContainerWidth();
        const scrollPrevButtonStyle = this.resolveLeftScrollButtonStyle(itemsContainerWidth);
        this.setScrollButtonStyle(this.scrollPrevButton.nativeElement, scrollPrevButtonStyle);
        const scrollNextButtonStyle = this.resolveRightScrollButtonStyle(itemsContainerWidth);
        this.setScrollButtonStyle(this.scrollNextButton.nativeElement, scrollNextButtonStyle);
    }
    setScrollButtonStyle(button, buttonStyle) {
        if (buttonStyle === TabScrollButtonStyle.Enabled) {
            button.disabled = false;
            button.style.display = '';
        }
        else if (buttonStyle === TabScrollButtonStyle.Disabled) {
            button.disabled = true;
            button.style.display = '';
        }
        else if (buttonStyle === TabScrollButtonStyle.NotDisplayed) {
            button.style.display = 'none';
        }
    }
    resolveLeftScrollButtonStyle(itemsContainerWidth) {
        const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;
        const offset = this.offset;
        if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
                return TabScrollButtonStyle.NotDisplayed;
            }
            return TabScrollButtonStyle.Disabled;
        }
        else {
            return TabScrollButtonStyle.Enabled;
        }
    }
    resolveRightScrollButtonStyle(itemsContainerWidth) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;
        const offset = this.offset;
        const total = offset + viewPortWidth;
        // Fix for IE 11, a difference is accumulated from the widths calculations.
        if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return TabScrollButtonStyle.NotDisplayed;
        }
        if (itemsContainerWidth > total) {
            return TabScrollButtonStyle.Enabled;
        }
        else {
            return TabScrollButtonStyle.Disabled;
        }
    }
    getTabItemsContainerWidth() {
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 1];
            itemsContainerWidth = this.getElementOffset(lastTab) + lastTab.offsetWidth;
        }
        return itemsContainerWidth;
    }
    getOffset(offset) {
        return this.dir.rtl ? -offset : offset;
    }
    getElementOffset(element) {
        return this.dir.rtl ? this.itemsWrapper.nativeElement.offsetWidth - element.offsetLeft - element.offsetWidth : element.offsetLeft;
    }
}
IgxTabsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: IgxTabsComponent, deps: [{ token: IgxAngularAnimationService }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i1.IgxDirectionality }], target: i0.ɵɵFactoryTarget.Component });
IgxTabsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.0", type: IgxTabsComponent, selector: "igx-tabs", inputs: { tabAlignment: "tabAlignment" }, host: { properties: { "class.igx-tabs": "this.defaultClass" } }, providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }], viewQueries: [{ propertyName: "headerContainer", first: true, predicate: ["headerContainer"], descendants: true, static: true }, { propertyName: "viewPort", first: true, predicate: ["viewPort"], descendants: true, static: true }, { propertyName: "itemsWrapper", first: true, predicate: ["itemsWrapper"], descendants: true, static: true }, { propertyName: "itemsContainer", first: true, predicate: ["itemsContainer"], descendants: true, static: true }, { propertyName: "selectedIndicator", first: true, predicate: ["selectedIndicator"], descendants: true }, { propertyName: "scrollPrevButton", first: true, predicate: ["scrollPrevButton"], descendants: true }, { propertyName: "scrollNextButton", first: true, predicate: ["scrollNextButton"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<div #headerContainer class=\"igx-tabs__header\">\n    <button #scrollPrevButton igxButton=\"icon\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollPrev()\">\n        <igx-icon>navigate_before</igx-icon>\n    </button>\n    <div #viewPort class=\"igx-tabs__header-content\">\n        <div #itemsWrapper class=\"igx-tabs__header-wrapper\" role=\"tablist\">\n            <div #itemsContainer class=\"igx-tabs__header-scroll\" [ngClass]=\"resolveHeaderScrollClasses()\">\n                <ng-container *ngFor=\"let tab of items; let i = index\">\n                    <ng-container *ngTemplateOutlet=\"tab.headerTemplate\"></ng-container>\n                </ng-container>\n            </div>\n            <div #selectedIndicator *ngIf=\"items.length > 0\" class=\"igx-tabs__header-active-indicator\">\n            </div>\n        </div>\n    </div>\n    <button #scrollNextButton igxButton=\"icon\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollNext()\">\n        <igx-icon>navigate_next</igx-icon>\n    </button>\n</div>\n<div class=\"igx-tabs__panels\">\n    <ng-container *ngFor=\"let tab of items; let i = index\">\n        <ng-container *ngTemplateOutlet=\"tab.panelTemplate\"></ng-container>\n    </ng-container>\n</div>", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: i3.IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "directive", type: i4.IgxRippleDirective, selector: "[igxRipple]", inputs: ["igxRippleTarget", "igxRipple", "igxRippleDuration", "igxRippleCentered", "igxRippleDisabled"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: IgxTabsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tabs', providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }], template: "<div #headerContainer class=\"igx-tabs__header\">\n    <button #scrollPrevButton igxButton=\"icon\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollPrev()\">\n        <igx-icon>navigate_before</igx-icon>\n    </button>\n    <div #viewPort class=\"igx-tabs__header-content\">\n        <div #itemsWrapper class=\"igx-tabs__header-wrapper\" role=\"tablist\">\n            <div #itemsContainer class=\"igx-tabs__header-scroll\" [ngClass]=\"resolveHeaderScrollClasses()\">\n                <ng-container *ngFor=\"let tab of items; let i = index\">\n                    <ng-container *ngTemplateOutlet=\"tab.headerTemplate\"></ng-container>\n                </ng-container>\n            </div>\n            <div #selectedIndicator *ngIf=\"items.length > 0\" class=\"igx-tabs__header-active-indicator\">\n            </div>\n        </div>\n    </div>\n    <button #scrollNextButton igxButton=\"icon\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollNext()\">\n        <igx-icon>navigate_next</igx-icon>\n    </button>\n</div>\n<div class=\"igx-tabs__panels\">\n    <ng-container *ngFor=\"let tab of items; let i = index\">\n        <ng-container *ngTemplateOutlet=\"tab.panelTemplate\"></ng-container>\n    </ng-container>\n</div>" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IgxAngularAnimationService]
                }] }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.IgxDirectionality }]; }, propDecorators: { tabAlignment: [{
                type: Input
            }], headerContainer: [{
                type: ViewChild,
                args: ['headerContainer', { static: true }]
            }], viewPort: [{
                type: ViewChild,
                args: ['viewPort', { static: true }]
            }], itemsWrapper: [{
                type: ViewChild,
                args: ['itemsWrapper', { static: true }]
            }], itemsContainer: [{
                type: ViewChild,
                args: ['itemsContainer', { static: true }]
            }], selectedIndicator: [{
                type: ViewChild,
                args: ['selectedIndicator']
            }], scrollPrevButton: [{
                type: ViewChild,
                args: ['scrollPrevButton']
            }], scrollNextButton: [{
                type: ViewChild,
                args: ['scrollNextButton']
            }], defaultClass: [{
                type: HostBinding,
                args: ['class.igx-tabs']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvdGFicy90YWJzL3RhYnMuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3RhYnMvdGFicy90YWJzLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBb0MsU0FBUyxFQUFjLFdBQVcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFxQixTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEosT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzdELE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLG9EQUFvRCxDQUFDO0FBR2hHLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDM0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7Ozs7OztBQUVyRCxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUM7SUFDbkMsS0FBSyxFQUFFLE9BQU87SUFDZCxHQUFHLEVBQUUsS0FBSztJQUNWLE1BQU0sRUFBRSxRQUFRO0lBQ2hCLE9BQU8sRUFBRSxTQUFTO0NBQ3JCLENBQUMsQ0FBQztBQUVILGNBQWM7QUFDZCxJQUFLLG9CQUlKO0FBSkQsV0FBSyxvQkFBb0I7SUFDckIsMkNBQW1CLENBQUE7SUFDbkIsNkNBQXFCLENBQUE7SUFDckIsc0RBQThCLENBQUE7QUFDbEMsQ0FBQyxFQUpJLG9CQUFvQixLQUFwQixvQkFBb0IsUUFJeEI7QUFJRCxjQUFjO0FBQ2QsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBRXBCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZCRztBQU9ILE1BQU0s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LEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUtwQyxjQUFjO3NCQURwQixTQUFTO3VCQUFDLGdCQUFnQixFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtnQkFLdEMsaUJBQWlCO3NCQUR2QixTQUFTO3VCQUFDLG1CQUFtQjtnQkFLdkIsZ0JBQWdCO3NCQUR0QixTQUFTO3VCQUFDLGtCQUFrQjtnQkFLdEIsZ0JBQWdCO3NCQUR0QixTQUFTO3VCQUFDLGtCQUFrQjtnQkFLdEIsWUFBWTtzQkFEbEIsV0FBVzt1QkFBQyxnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSW5qZWN0LCBJbnB1dCwgTmdab25lLCBPbkRlc3Ryb3ksIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZ2V0UmVzaXplT2JzZXJ2ZXIsIG1rZW51bSB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSWd4QW5ndWxhckFuaW1hdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9hbmltYXRpb24vYW5ndWxhci1hbmltYXRpb24tc2VydmljZSc7XG5pbXBvcnQgeyBBbmltYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYW5pbWF0aW9uL2FuaW1hdGlvbic7XG5pbXBvcnQgeyBJZ3hEaXJlY3Rpb25hbGl0eSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2RpcmVjdGlvbi9kaXJlY3Rpb25hbGl0eSc7XG5pbXBvcnQgeyBJZ3hUYWJzQmFzZSB9IGZyb20gJy4uL3RhYnMuYmFzZSc7XG5pbXBvcnQgeyBJZ3hUYWJzRGlyZWN0aXZlIH0gZnJvbSAnLi4vdGFicy5kaXJlY3RpdmUnO1xuXG5leHBvcnQgY29uc3QgSWd4VGFic0FsaWdubWVudCA9IG1rZW51bSh7XG4gICAgc3RhcnQ6ICdzdGFydCcsXG4gICAgZW5kOiAnZW5kJyxcbiAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgIGp1c3RpZnk6ICdqdXN0aWZ5J1xufSk7XG5cbi8qKiBAaGlkZGVuICovXG5lbnVtIFRhYlNjcm9sbEJ1dHRvblN0eWxlIHtcbiAgICBFbmFibGVkID0gJ2VuYWJsZWQnLFxuICAgIERpc2FibGVkID0gJ2Rpc2FibGVkJyxcbiAgICBOb3REaXNwbGF5ZWQgPSAnbm90X2Rpc3BsYXllZCdcbn1cblxuZXhwb3J0IHR5cGUgSWd4VGFic0FsaWdubWVudCA9ICh0eXBlb2YgSWd4VGFic0FsaWdubWVudClba2V5b2YgdHlwZW9mIElneFRhYnNBbGlnbm1lbnRdO1xuXG4vKiogQGhpZGRlbiAqL1xubGV0IE5FWFRfVEFCX0lEID0gMDtcblxuLyoqXG4gKiBUYWJzIGNvbXBvbmVudCBpcyB1c2VkIHRvIG9yZ2FuaXplIG9yIHN3aXRjaCBiZXR3ZWVuIHNpbWlsYXIgZGF0YSBzZXRzLlxuICpcbiAqIEBpZ3hNb2R1bGUgSWd4VGFic01vZHVsZVxuICpcbiAqIEBpZ3hUaGVtZSBpZ3gtdGFicy10aGVtZVxuICpcbiAqIEBpZ3hLZXl3b3JkcyB0YWJzXG4gKlxuICogQGlneEdyb3VwIExheW91dHNcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIElnbml0ZSBVSSBmb3IgQW5ndWxhciBUYWJzIGNvbXBvbmVudCBwbGFjZXMgdGFicyBhdCB0aGUgdG9wIGFuZCBhbGxvd3MgZm9yIHNjcm9sbGluZyB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSB0YWIgaXRlbXMgb24gdGhlIHNjcmVlbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC10YWJzPlxuICogICAgIDxpZ3gtdGFiLWl0ZW0+XG4gKiAgICAgICAgIDxpZ3gtdGFiLWhlYWRlcj5cbiAqICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hUYWJIZWFkZXJJY29uPmZvbGRlcjwvaWd4LWljb24+XG4gKiAgICAgICAgICAgICA8c3BhbiBpZ3hUYWJIZWFkZXJMYWJlbD5UYWIgMTwvc3Bhbj5cbiAqICAgICAgICAgPC9pZ3gtdGFiLWhlYWRlcj5cbiAqICAgICAgICAgPGlneC10YWItY29udGVudD5cbiAqICAgICAgICAgICAgIENvbnRlbnQgMVxuICogICAgICAgICA8L2lneC10YWItY29udGVudD5cbiAqICAgICA8L2lneC10YWItaXRlbT5cbiAqICAgICAuLi5cbiAqIDwvaWd4LXRhYnM+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtdGFicycsXG4gICAgdGVtcGxhdGVVcmw6ICd0YWJzLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IElneFRhYnNCYXNlLCB1c2VFeGlzdGluZzogSWd4VGFic0NvbXBvbmVudCB9XVxufSlcblxuZXhwb3J0IGNsYXNzIElneFRhYnNDb21wb25lbnQgZXh0ZW5kcyBJZ3hUYWJzRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB3aGljaCBkZXRlcm1pbmVzIHRoZSB0YWIgYWxpZ25tZW50LiBEZWZhdWx0cyB0byBgc3RhcnRgLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCB0YWJBbGlnbm1lbnQoKTogc3RyaW5nIHwgSWd4VGFic0FsaWdubWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWJBbGlnbm1lbnQ7XG4gICAgfTtcblxuICAgIHB1YmxpYyBzZXQgdGFiQWxpZ25tZW50KHZhbHVlOiBzdHJpbmcgfCBJZ3hUYWJzQWxpZ25tZW50KSB7XG4gICAgICAgIHRoaXMuX3RhYkFsaWdubWVudCA9IHZhbHVlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxCdXR0b25zKCk7XG4gICAgICAgICAgICB0aGlzLnJlYWxpZ25TZWxlY3RlZEluZGljYXRvcigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ2hlYWRlckNvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGhlYWRlckNvbnRhaW5lcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ3ZpZXdQb3J0JywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgdmlld1BvcnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKCdpdGVtc1dyYXBwZXInLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyBpdGVtc1dyYXBwZXI6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKCdpdGVtc0NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGl0ZW1zQ29udGFpbmVyOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQFZpZXdDaGlsZCgnc2VsZWN0ZWRJbmRpY2F0b3InKVxuICAgIHB1YmxpYyBzZWxlY3RlZEluZGljYXRvcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ3Njcm9sbFByZXZCdXR0b24nKVxuICAgIHB1YmxpYyBzY3JvbGxQcmV2QnV0dG9uOiBFbGVtZW50UmVmPEhUTUxCdXR0b25FbGVtZW50PjtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQFZpZXdDaGlsZCgnc2Nyb2xsTmV4dEJ1dHRvbicpXG4gICAgcHVibGljIHNjcm9sbE5leHRCdXR0b246IEVsZW1lbnRSZWY8SFRNTEJ1dHRvbkVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10YWJzJylcbiAgICBwdWJsaWMgZGVmYXVsdENsYXNzID0gdHJ1ZTtcblxuICAgIC8qKiAgQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBvZmZzZXQgPSAwO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcm90ZWN0ZWQgY29tcG9uZW50TmFtZSA9ICdpZ3gtdGFicyc7XG5cbiAgICBwcml2YXRlIF90YWJBbGlnbm1lbnQ6IHN0cmluZyB8IElneFRhYnNBbGlnbm1lbnQgPSAnc3RhcnQnO1xuICAgIHByaXZhdGUgX3Jlc2l6ZU9ic2VydmVyOiBSZXNpemVPYnNlcnZlcjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KElneEFuZ3VsYXJBbmltYXRpb25TZXJ2aWNlKSBhbmltYXRpb25TZXJ2aWNlOiBBbmltYXRpb25TZXJ2aWNlLFxuICAgICAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcml2YXRlIG5nWm9uZTogTmdab25lLFxuICAgICAgICBwdWJsaWMgZGlyOiBJZ3hEaXJlY3Rpb25hbGl0eSkge1xuICAgICAgICBzdXBlcihhbmltYXRpb25TZXJ2aWNlLCBjZHIsIGRpcik7XG4gICAgfVxuXG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICBzdXBlci5uZ0FmdGVyVmlld0luaXQoKTtcblxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlciA9IG5ldyAoZ2V0UmVzaXplT2JzZXJ2ZXIoKSkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsQnV0dG9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbGlnblNlbGVjdGVkSW5kaWNhdG9yKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5oZWFkZXJDb250YWluZXIubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcblxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBzY3JvbGxQcmV2KCkge1xuICAgICAgICB0aGlzLnNjcm9sbChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgc2Nyb2xsTmV4dCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGwodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgcmVhbGlnblNlbGVjdGVkSW5kaWNhdG9yKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID49IDAgJiYgdGhpcy5zZWxlY3RlZEluZGV4IDwgdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IHRoaXMuaXRlbXMuZ2V0KHRoaXMuc2VsZWN0ZWRJbmRleCkuaGVhZGVyQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmFsaWduU2VsZWN0ZWRJbmRpY2F0b3IoaGVhZGVyLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIHJlc29sdmVIZWFkZXJTY3JvbGxDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lneC10YWJzX19oZWFkZXItc2Nyb2xsLS1zdGFydCc6IHRoaXMudGFiQWxpZ25tZW50ID09PSAnc3RhcnQnLFxuICAgICAgICAgICAgJ2lneC10YWJzX19oZWFkZXItc2Nyb2xsLS1lbmQnOiB0aGlzLnRhYkFsaWdubWVudCA9PT0gJ2VuZCcsXG4gICAgICAgICAgICAnaWd4LXRhYnNfX2hlYWRlci1zY3JvbGwtLWNlbnRlcic6IHRoaXMudGFiQWxpZ25tZW50ID09PSAnY2VudGVyJyxcbiAgICAgICAgICAgICdpZ3gtdGFic19faGVhZGVyLXNjcm9sbC0tanVzdGlmeSc6IHRoaXMudGFiQWxpZ25tZW50ID09PSAnanVzdGlmeScsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcm90ZWN0ZWQgc2Nyb2xsVGFiSGVhZGVySW50b1ZpZXcoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgdGFiSXRlbXMgPSB0aGlzLml0ZW1zLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQgPSB0YWJJdGVtc1t0aGlzLnNlbGVjdGVkSW5kZXhdLmhlYWRlckNvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuXG4gICAgICAgICAgICAvLyBTY3JvbGwgbGVmdCBpZiB0aGVyZSBpcyBuZWVkXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRFbGVtZW50T2Zmc2V0KHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQpIDwgdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQodGFiSGVhZGVyTmF0aXZlRWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTY3JvbGwgcmlnaHQgaWYgdGhlcmUgaXMgbmVlZFxuICAgICAgICAgICAgY29uc3Qgdmlld1BvcnRPZmZzZXRXaWR0aCA9IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gKHRoaXMuZ2V0RWxlbWVudE9mZnNldCh0YWJIZWFkZXJOYXRpdmVFbGVtZW50KSArIHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgpIC0gKHZpZXdQb3J0T2Zmc2V0V2lkdGggKyB0aGlzLm9mZnNldCk7XG5cbiAgICAgICAgICAgIC8vIEZpeCBmb3IgSUUgMTEsIGEgZGlmZmVyZW5jZSBpcyBhY2N1bXVsYXRlZCBmcm9tIHRoZSB3aWR0aHMgY2FsY3VsYXRpb25zXG4gICAgICAgICAgICBpZiAoZGVsdGEgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50KHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFsaWduU2VsZWN0ZWRJbmRpY2F0b3IodGFiSGVhZGVyTmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVTZWxlY3RlZEluZGljYXRvcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcm90ZWN0ZWQgZ2V0TmV4dFRhYklkKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9UQUJfSUQrKztcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByb3RlY3RlZCBvbkl0ZW1DaGFuZ2VzKCkge1xuICAgICAgICBzdXBlci5vbkl0ZW1DaGFuZ2VzKCk7XG5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbEJ1dHRvbnMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhbGlnblNlbGVjdGVkSW5kaWNhdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBkdXJhdGlvbiA9IDAuMyk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGljYXRvcikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gPiAwID8gYCR7ZHVyYXRpb259c2AgOiAnaW5pdGlhbCc7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtlbGVtZW50Lm9mZnNldFdpZHRofXB4YDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZWxlbWVudC5vZmZzZXRMZWZ0fXB4KWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGhpZGVTZWxlY3RlZEluZGljYXRvcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNjcm9sbChzY3JvbGxOZXh0OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhYnNBcnJheSA9IHRoaXMuaXRlbXMudG9BcnJheSgpO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0YWJzQXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YWIgPSB0YWJzQXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRhYi5oZWFkZXJDb21wb25lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChzY3JvbGxOZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0V2lkdGggKyB0aGlzLmdldEVsZW1lbnRPZmZzZXQoZWxlbWVudCkgPiB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggKyB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQoZWxlbWVudCwgc2Nyb2xsTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0RWxlbWVudE9mZnNldChlbGVtZW50KSA+PSB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQodGFic0FycmF5W2luZGV4IC0gMV0uaGVhZGVyQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQsIHNjcm9sbE5leHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNjcm9sbEVsZW1lbnQoZWxlbWVudDogYW55LCBzY3JvbGxOZXh0OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0V2lkdGggPSB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAoc2Nyb2xsTmV4dCkgPyBlbGVtZW50Lm9mZnNldFdpZHRoICsgdGhpcy5nZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpIC0gdmlld1BvcnRXaWR0aCA6IHRoaXMuZ2V0RWxlbWVudE9mZnNldChlbGVtZW50KTtcbiAgICAgICAgdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQgPSB0aGlzLmdldE9mZnNldCh0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsQnV0dG9ucygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlU2Nyb2xsQnV0dG9ucygpIHtcbiAgICAgICAgY29uc3QgaXRlbXNDb250YWluZXJXaWR0aCA9IHRoaXMuZ2V0VGFiSXRlbXNDb250YWluZXJXaWR0aCgpO1xuXG4gICAgICAgIGNvbnN0IHNjcm9sbFByZXZCdXR0b25TdHlsZSA9IHRoaXMucmVzb2x2ZUxlZnRTY3JvbGxCdXR0b25TdHlsZShpdGVtc0NvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxCdXR0b25TdHlsZSh0aGlzLnNjcm9sbFByZXZCdXR0b24ubmF0aXZlRWxlbWVudCwgc2Nyb2xsUHJldkJ1dHRvblN0eWxlKTtcblxuICAgICAgICBjb25zdCBzY3JvbGxOZXh0QnV0dG9uU3R5bGUgPSB0aGlzLnJlc29sdmVSaWdodFNjcm9sbEJ1dHRvblN0eWxlKGl0ZW1zQ29udGFpbmVyV2lkdGgpO1xuICAgICAgICB0aGlzLnNldFNjcm9sbEJ1dHRvblN0eWxlKHRoaXMuc2Nyb2xsTmV4dEJ1dHRvbi5uYXRpdmVFbGVtZW50LCBzY3JvbGxOZXh0QnV0dG9uU3R5bGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0U2Nyb2xsQnV0dG9uU3R5bGUoYnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudCwgYnV0dG9uU3R5bGU6IFRhYlNjcm9sbEJ1dHRvblN0eWxlKSB7XG4gICAgICAgIGlmIChidXR0b25TdHlsZSA9PT0gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuRW5hYmxlZCkge1xuICAgICAgICAgICAgYnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICBidXR0b24uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1dHRvblN0eWxlID09PSBUYWJTY3JvbGxCdXR0b25TdHlsZS5EaXNhYmxlZCkge1xuICAgICAgICAgICAgYnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoYnV0dG9uU3R5bGUgPT09IFRhYlNjcm9sbEJ1dHRvblN0eWxlLk5vdERpc3BsYXllZCkge1xuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSByZXNvbHZlTGVmdFNjcm9sbEJ1dHRvblN0eWxlKGl0ZW1zQ29udGFpbmVyV2lkdGg6IG51bWJlcik6IFRhYlNjcm9sbEJ1dHRvblN0eWxlIHtcbiAgICAgICAgY29uc3QgaGVhZGVyQ29udGFpbmVyV2lkdGggPSB0aGlzLmhlYWRlckNvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldDtcblxuICAgICAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBGaXggZm9yIElFIDExLCBhIGRpZmZlcmVuY2UgaXMgYWNjdW11bGF0ZWQgZnJvbSB0aGUgd2lkdGhzIGNhbGN1bGF0aW9ucy5cbiAgICAgICAgICAgIGlmIChpdGVtc0NvbnRhaW5lcldpZHRoIC0gaGVhZGVyQ29udGFpbmVyV2lkdGggPD0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5Ob3REaXNwbGF5ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuRGlzYWJsZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuRW5hYmxlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcmVzb2x2ZVJpZ2h0U2Nyb2xsQnV0dG9uU3R5bGUoaXRlbXNDb250YWluZXJXaWR0aDogbnVtYmVyKTogVGFiU2Nyb2xsQnV0dG9uU3R5bGUge1xuICAgICAgICBjb25zdCB2aWV3UG9ydFdpZHRoID0gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCBoZWFkZXJDb250YWluZXJXaWR0aCA9IHRoaXMuaGVhZGVyQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBjb25zdCB0b3RhbCA9IG9mZnNldCArIHZpZXdQb3J0V2lkdGg7XG5cbiAgICAgICAgLy8gRml4IGZvciBJRSAxMSwgYSBkaWZmZXJlbmNlIGlzIGFjY3VtdWxhdGVkIGZyb20gdGhlIHdpZHRocyBjYWxjdWxhdGlvbnMuXG4gICAgICAgIGlmIChpdGVtc0NvbnRhaW5lcldpZHRoIC0gaGVhZGVyQ29udGFpbmVyV2lkdGggPD0gMSAmJiBvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5Ob3REaXNwbGF5ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbXNDb250YWluZXJXaWR0aCA+IHRvdGFsKSB7XG4gICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuRW5hYmxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5EaXNhYmxlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGFiSXRlbXNDb250YWluZXJXaWR0aCgpIHtcbiAgICAgICAgLy8gV2UgdXNlIHRoaXMgaGFja3kgd2F5IHRvIGdldCB0aGUgd2lkdGggb2YgdGhlIGl0ZW1zQ29udGFpbmVyLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIGluY29uc2lzdGVuY3kgaW4gSUUgd2UgY2Fubm90IHVzZSBvZmZzZXRXaWR0aCBvciBzY3JvbGxPZmZzZXQuXG4gICAgICAgIGNvbnN0IGl0ZW1zQ29udGFpbmVyQ2hpbGRyZW5Db3VudCA9IHRoaXMuaXRlbXNDb250YWluZXIubmF0aXZlRWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGxldCBpdGVtc0NvbnRhaW5lcldpZHRoID0gMDtcblxuICAgICAgICBpZiAoaXRlbXNDb250YWluZXJDaGlsZHJlbkNvdW50ID4gMSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFRhYiA9IHRoaXMuaXRlbXNDb250YWluZXIubmF0aXZlRWxlbWVudC5jaGlsZHJlbltpdGVtc0NvbnRhaW5lckNoaWxkcmVuQ291bnQgLSAxXSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgICAgIGl0ZW1zQ29udGFpbmVyV2lkdGggPSB0aGlzLmdldEVsZW1lbnRPZmZzZXQobGFzdFRhYikgKyBsYXN0VGFiLm9mZnNldFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zQ29udGFpbmVyV2lkdGg7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRPZmZzZXQob2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXIucnRsID8gLW9mZnNldCA6IG9mZnNldDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEVsZW1lbnRPZmZzZXQoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXIucnRsID8gdGhpcy5pdGVtc1dyYXBwZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCAtIGVsZW1lbnQub2Zmc2V0TGVmdCAtIGVsZW1lbnQub2Zmc2V0V2lkdGggOiBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgfVxufVxuXG4iLCI8ZGl2ICNoZWFkZXJDb250YWluZXIgY2xhc3M9XCJpZ3gtdGFic19faGVhZGVyXCI+XG4gICAgPGJ1dHRvbiAjc2Nyb2xsUHJldkJ1dHRvbiBpZ3hCdXR0b249XCJpY29uXCIgaWd4UmlwcGxlIGNsYXNzPVwiaWd4LXRhYnNfX2hlYWRlci1idXR0b25cIiAoY2xpY2spPVwic2Nyb2xsUHJldigpXCI+XG4gICAgICAgIDxpZ3gtaWNvbj5uYXZpZ2F0ZV9iZWZvcmU8L2lneC1pY29uPlxuICAgIDwvYnV0dG9uPlxuICAgIDxkaXYgI3ZpZXdQb3J0IGNsYXNzPVwiaWd4LXRhYnNfX2hlYWRlci1jb250ZW50XCI+XG4gICAgICAgIDxkaXYgI2l0ZW1zV3JhcHBlciBjbGFzcz1cImlneC10YWJzX19oZWFkZXItd3JhcHBlclwiIHJvbGU9XCJ0YWJsaXN0XCI+XG4gICAgICAgICAgICA8ZGl2ICNpdGVtc0NvbnRhaW5lciBjbGFzcz1cImlneC10YWJzX19oZWFkZXItc2Nyb2xsXCIgW25nQ2xhc3NdPVwicmVzb2x2ZUhlYWRlclNjcm9sbENsYXNzZXMoKVwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHRhYiBvZiBpdGVtczsgbGV0IGkgPSBpbmRleFwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwidGFiLmhlYWRlclRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgI3NlbGVjdGVkSW5kaWNhdG9yICpuZ0lmPVwiaXRlbXMubGVuZ3RoID4gMFwiIGNsYXNzPVwiaWd4LXRhYnNfX2hlYWRlci1hY3RpdmUtaW5kaWNhdG9yXCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGJ1dHRvbiAjc2Nyb2xsTmV4dEJ1dHRvbiBpZ3hCdXR0b249XCJpY29uXCIgaWd4UmlwcGxlIGNsYXNzPVwiaWd4LXRhYnNfX2hlYWRlci1idXR0b25cIiAoY2xpY2spPVwic2Nyb2xsTmV4dCgpXCI+XG4gICAgICAgIDxpZ3gtaWNvbj5uYXZpZ2F0ZV9uZXh0PC9pZ3gtaWNvbj5cbiAgICA8L2J1dHRvbj5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cImlneC10YWJzX19wYW5lbHNcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCB0YWIgb2YgaXRlbXM7IGxldCBpID0gaW5kZXhcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRhYi5wYW5lbFRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9uZy1jb250YWluZXI+XG48L2Rpdj4iXX0=